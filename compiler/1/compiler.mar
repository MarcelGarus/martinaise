| The Martinaise Compiler  
| This is the compiler for Martinaise, written in Martinaise.
|
| This file is pretty long, but I tried to write the code in an order so that it
| can be read from top to bottom. Comment sections introduce new concepts as you
| read along.
|
| I really recommend reading this with syntax highlighting enabled.
| If you use VS Code: There's a vscode_extension folder in this project. You can
|   open only that folder (File > Open Folder) and then in the debug panel
|   (default: ctrl + shift + D), you can run the extension. This will open a new
|   VS Code window. If you manage to create a .vsix extension, feel welcome to
|   give it to me to add to the repo – my local npm setup seems to not like the
|   commands given in the official guide.
| If you don't use VS Code: There's a tree text mate grammar in the
|   vscode_extension folder. Good luck!
|
| TODO: what you should know when reading this
|
| Bootstrapping  
| TODO: write this when Martinaise is bootstrapped
|
| Rough overview  
| Like many compilers, the Martinaise compiler works in stages:
| 
| ┌──────┐ parsing ┌─────┐ monomorphization ┌──────┐ lowering ┌───┐ gcc ┌─────┐
| │ Code │ ──────> │ AST │ ───────────────> │ Mono | ───────> │ C │ ──> │ Exe |
| └──────┘         └─────┘                  └──────┘          └───┘     └─────┘
|
| - Code: It starts with source code, read as a string.
| - AST (Abstract Syntax Tree): The source code is parsed into a tree that
|   roughly corresponds to the code.
| - Mono (Monomorphized Tree): When functions get used, for each combination of
|   type arguments, a new version of the function is compiled. In the Mono
|   stage, all functions only take concrete types – there is no generic code
|   anymore.
| - C: Just plain C code.
| - Exe: The executable produced by GCC. Of course, you can also let your C
|   compiler do other stuff such as compiling everything into a WebAssembly
|   module so it can be deployed to a website.
|
| Glossary  
| I'm not generally a fan of abbreviations, but for concepts that pop up
| everywhere in the compiler, reading long names gets tedious. Here's a list of
| abbreviations that are used throughout the code:
|
| arg  = argument
| def  = definition
| env  = environment
| expr = expression
| fun  = function
| str  = string
| var  = variable
|
| Plural forms have an s at the end (as in args or defs).

| Terminal utilities  

fun clear_terminal() {
  todo()
  | var clear = std.ChildProcess.init(&[_]Str{"clear"}, alloc)
  | clear.stdout = std.io.getStdOut()
  | clear.stderr = std.io.getStdErr()
  | _ = try clear.spawnAndWait()
}

fun write_ansi_escape_sequence[W](writer: W, sequence: Slice[U8]) {
  writer.write_byte(27_U8)
  writer.write_str(sequence)
}
fun print_on_same_line(message: Slice[U8]) {
  | Moves the cursor one line up and to the beginning
  stderr().write_ansi_escape_sequence("[1A")
  stderr().write_ansi_escape_sequence("[K")
  eprintsln(message)
}

| Types  
| Types such as Int or Slice[&U8] are represented as a tree. For example, the
| Slice[&U8] type is represented like this:
|
| Type { name = "Slice", args = [
|   Type { name = "&", args = [
|     Type { name = "U8", args = [] }
|   ] }
| ] }

struct Type { name: Slice[U8], args: Vec[Type] }

fun type(name: Slice[U8]): Type { type(name, vec[Type]()) }
fun type(name: Slice[U8], args: Vec[Type]): Type { Type { name, args } }
fun is_never(type: Type): Bool { type.equals(type("Never")) }

fun write[W](writer: W, type: Type) {
  writer.write_str(type.name)
  if type.name.equals("&")
  then writer.write(type.args.get(0))
  else writer.write_type_args(type.args)
}
fun write_type_args[W](writer: W, args: Vec[Type]) {
  if args.is_empty() then return {}
  writer.write_char('[)
  var first = true()
  for arg in args do {
    if first then first = false() else writer.write_str(", ")
    writer.write(arg)
  }
  writer.write_char('])
}
| TODO: merge with the fun above once there's a string type
fun write_type_args[W](writer: W, args: Vec[Slice[U8]]) {
  if args.is_empty() then return {}
  writer.write_char('[)
  var first = true()
  for arg in args do {
    if first then first = false() else writer.write_str(", ")
    writer.write_str(arg)
  }
  writer.write_char('])
}

fun equals(a: Type, b: Type): Bool {
  if a.name.not_equals(b.name) then return false()
  if a.args.len.not_equals(b.args.len) then return false()
  for i in 0.to(a.args.len) do
    if a.args.get(i).not_equals(b.args.get(i)) then return false()
  true()
}

fun hash(hasher: &Hasher, type: Type) {
  hasher.hash(type.name)
  for arg in type.args do hasher.hash(arg)
}

| You can use _ to infer parts of the type, for example like Maybe[_].
fun is_complete(type: Type): Bool {
  if type.name.equals("_") then return false()
  for arg in type.args do if not(arg.is_complete()) then return false()
  true()
}
fun is_incomplete(type: Type): Bool { not(type.is_complete()) }

| Numbers  
| Number types such such as U8 or I32 are special in Candy. These numbers and
| mathematical functions for them are magically in scope. Here are some basic
| concepts needed for representing numbers.

enum Signedness { signed, unsigned }
struct IntConfig { signedness: Signedness, bits: U64 }
| Int literals can't be negative in Martinaise.
struct Int { value: U64, config: IntConfig }

fun all_signednesses(): Vec[Signedness] {
  vec(Signedness.signed, Signedness.unsigned)
}
fun all_bits(): Vec[U64] { vec(8, 16, 32, 64) }
fun all_int_configs(): Vec[IntConfig] {
  var configs = vec[IntConfig]()
  for signedness in all_signednesses() do
    for bits in all_bits() do
      configs.&.push(IntConfig { signedness, bits })
  configs
}

fun to_char(s: Signedness): U8 { switch s case signed 'I case unsigned 'U }
fun to_type(config: IntConfig): Type {
  var name = vec[U8]()
  name.&.write_char(config.signedness.to_char())
  name.&.write(config.bits)
  type(name.to_slice())
}

fun equals(a: Signedness, b: Signedness): Bool {
  a.to_char().equals(b.to_char())
}
fun equals(a: IntConfig, b: IntConfig): Bool {
  a.signedness.equals(b.signedness).and(a.bits.equals(b.bits))
}
fun equals(a: Int, b: Int): Bool {
  a.config.equals(b.config).and(a.value.equals(b.value))
}

fun write[W](writer: W, int: Int) {
  writer.write(int.value)
  writer.write_char('_)
  writer.write_char(int.config.signedness.to_char())
  writer.write(int.config.bits)
}

| The Abstract Syntax Tree  
| The compiler input is parsed into an abstract syntax tree. This tree is a
| representation of the program that roughly corresponds to the structure of the
| source code.

struct Ast { defs: Vec[AstDef] }
enum AstDef {
  builtin_type: Slice[U8], | not parsed from code
  struct_: AstStruct,
  enum_: AstEnum,
  var_: AstVar, | same AstVar as in funs
  fun_: AstFun,
}

struct AstStruct {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  fields: Vec[AstStructField],
}
struct AstStructField { name: Slice[U8], type: Type }

struct AstEnum {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  variants: Vec[AstEnumVariant],
}
struct AstEnumVariant { name: Slice[U8], type: Type }

struct AstFun {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  args: Vec[AstFunArg],
  returns: Type,
  is_builtin: Bool,
  body: Vec[AstExpr],
}
struct AstFunArg { name: Slice[U8], type: Type }
enum AstExpr {
  int: Int,                   | 0_U32
  str: Slice[U8],             | "foo"
  name: Slice[U8],            | foo
  call: AstCall,              | ...(arg)
  make_struct: AstMakeStruct, | Foo { a = ... }
  make_enum: AstMakeEnum,     | Maybe.some(5)
  member: AstMember,          | foo.bar
  var_: AstVar,               | var foo = ...
  assign: AstAssign,          | foo = ...
  switch_: AstSwitch,         | switch foo case a ... case b(bar) ...
  loop_: &AstExpr,            | loop ...
  break_: &AstExpr,           | break(2)
  continue_,                  | continue
  return_: &AstExpr,          | return ...
  try: &AstExpr,              | ...?
  body: Vec[AstExpr],         | { ... }
}
struct AstTypeArged { expr: &AstExpr, type_args: Vec[Type] }
struct AstCall {
  callee: &AstExpr,
  type_args: Maybe[Vec[Type]],
  args: Vec[AstExpr],
}
struct AstMakeStruct { type: Type, fields: Vec[AstMakeStructField] }
struct AstMakeStructField { name: Slice[U8], value: AstExpr }
struct AstMakeEnum { type: Type, variant: Slice[U8], arg: &AstExpr }
struct AstMember { of: &AstExpr, name: Slice[U8] }
struct AstVar { name: Slice[U8], value: &AstExpr }
struct AstAssign { to: &AstExpr, value: &AstExpr }
struct AstSwitch { value: &AstExpr, cases: Vec[AstCase], default_: Maybe[&AstExpr] }
struct AstCase { variant: Slice[U8], binding: Maybe[Slice[U8]], then_: &AstExpr }

fun call(
  expr: AstExpr, type_args: Maybe[Vec[Type]], args: Vec[AstExpr]
): AstExpr {
  AstExpr.call(AstCall { callee = expr.put_on_heap(), type_args, args })
}
fun call(expr: AstExpr, args: Vec[AstExpr]): AstExpr {
  expr.call(none[Vec[Type]](), args)
}
fun call(expr: AstExpr): AstExpr { expr.call(vec[AstExpr]()) }
fun member(expr: AstExpr, name: Slice[U8]): AstExpr {
  AstExpr.member(AstMember { of = expr.put_on_heap(), name })
}
fun var_(name: Slice[U8], value: AstExpr): AstExpr {
  AstExpr.var_(AstVar { name, value = value.put_on_heap() })
}

fun write[W](writer: W, program: Ast) {
  for def in program.defs do { writer.write(def) writer.write_char(newline()) }
}
fun write[W](writer: W, def: AstDef) {
  switch def
  case builtin_type(name) {
    writer.write_str("builtin ")
    writer.write_str(name)
  }
  case struct_(s) writer.write(s)
  case enum_(e) writer.write(e)
  case var_(v) writer.write(v)
  case fun_(f) writer.write(f)
}
fun write_signature[W](writer: W, def: AstDef) {
  switch def
  case builtin_type(name) {
    writer.write_str("builtin ")
    writer.write_str(name)
  }
  case struct_(s) {
    writer.write_str("struct ")
    writer.write_str(s.name)
    writer.write_type_args(s.type_args)
  }
  case enum_(e) {
    writer.write_str("enum ")
    writer.write_str(e.name)
    writer.write_type_args(e.type_args)
  }
  case var_(v) {
    writer.write_str("var ")
    writer.write_str(v.name)
  }
  case fun_(f) {
    writer.write_str(f.name)
    writer.write_type_args(f.type_args)
    writer.write_char('()
    var first = true()
    for arg in f.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(arg.type)
    }
    writer.write_char('))
  }
}
fun write[W](writer: W, s: AstStruct) {
  writer.write_str("struct ")
  writer.write_str(s.name)
  writer.write_type_args(s.type_args)
  if s.fields.is_empty() then writer.write_str(" {}") else {
    writer.write_char(' )
    writer.write_char('{)
    writer.write_char(newline())
    for field in s.fields do {
      writer.write_str("  ")
      writer.write_str(field.name)
      writer.write_str(": ")
      writer.write(field.type)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_char('})
  }
}
fun write[W](writer: W, e: AstEnum) {
  writer.write_str("enum ")
  writer.write_str(e.name)
  writer.write_type_args(e.type_args)
  if e.variants.is_empty() then writer.write_str(" {}") else {
    writer.write_char(' )
    writer.write_char('{)
    writer.write_char(newline())
    for variant in e.variants do {
      writer.write_str("  ")
      writer.write_str(variant.name)
      writer.write_str(": ")
      writer.write(variant.type)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_char('})
  }
}
fun write[W](writer: W, var_: AstVar) { writer.write(0, var_) }
fun write[W](writer: W, indent: U64, var_: AstVar) {
  writer.write_str("var ")
  writer.write_str(var_.name)
  writer.write_str(" = ")
  writer.write(indent, var_.value.*)
}
fun write[W](writer: W, f: AstFun) {
  writer.write_str("fun ")
  writer.write_str(f.name)
  writer.write_type_args(f.type_args)
  writer.write_char('()
  var first = true()
  for arg in f.args do {
    if first then first = false() else writer.write_str(", ")
    writer.write_str(arg.name)
    writer.write_str(": ")
    writer.write(arg.type)
  }
  writer.write_str("): ")
  writer.write(f.returns)
  writer.write_str(" ")
  if f.is_builtin
  then writer.write_str("{ ... }")
  else writer.write_body(0, f.body)
}
fun write_indent[W](writer: W, indent: U64) {
  for i in 0.to(indent.multiply(2)) do writer.write_char(' )
}
fun write_body[W](writer: W, indent: U64, body: Vec[AstExpr]) {
  if body.is_empty() then { writer.write_str("{}") return {} }
  writer.write_char('{)
  writer.write_char(newline())
  for expr in body do {
    writer.write_indent(indent.inc())
    writer.write(indent.inc(), expr)
    writer.write_char(newline())
  }
  writer.write_indent(indent)
  writer.write_char('})
}
fun write[W](writer: W, indent: U64, expr: AstExpr) {
  switch expr
  case int(int) writer.write(int)
  case str(str) {
    writer.write_char('") | to fix syntax highlighting: "'
    writer.write_str(str)
    writer.write_char('") | to fix syntax highlighting: "'
  }
  case name(name) writer.write_str(name)
  case call(call) {
    writer.write(indent, call.callee.*)
    if call.type_args is some(type_args)
    then writer.write_type_args(type_args)
    writer.write_char('()
    var first = true()
    for arg in call.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(indent, arg)
    }
    writer.write_char('))
  }
  case make_struct(struct_) {
    writer.write(struct_.type)
    writer.write_char(' )
    writer.write_char('{)
    if struct_.fields.is_not_empty() then {
      writer.write_char(newline())
      for field in struct_.fields do {
        writer.write_indent(indent.inc())
        writer.write_str(field.name)
        writer.write_str(" = ")
        writer.write(indent.inc(), field.value)
        writer.write_char(',)
        writer.write_char(newline())
      }
      writer.write_indent(indent)
    }
    writer.write_str("}")
  }
  case make_enum(enum_) {
    writer.write(enum_.type)
    writer.write_str(".")
    writer.write_str(enum_.variant)
    writer.write_str("(")
    writer.write(indent, enum_.arg.*)
    writer.write_str(")")
  }
  case member(member) {
    writer.write(indent, member.of.*)
    writer.write_char('.)
    writer.write_str(member.name)
  }
  case var_(var_) writer.write(var_)
  case assign(assign) {
    writer.write(indent, assign.to.*)
    writer.write_str(" = ")
    writer.write(indent, assign.value.*)
  }
  case switch_(switch_) {
    writer.write_str("switch ")
    writer.write(indent, switch_.value.*)
    for case_ in switch_.cases do {
      writer.write_char(newline())
      writer.write_indent(indent)
      writer.write_str("case ")
      writer.write_str(case_.variant)
      if case_.binding is some(binding) then {
        writer.write_char('()
        writer.write_str(binding)
        writer.write_char('))
      }
      writer.write_str(" ")
      writer.write(indent, case_.then_.*)
    }
    if switch_.default_ is some(default_) then {
      writer.write_char(newline())
      writer.write_indent(indent)
      writer.write_str("default ")
      writer.write(indent, default_.*)
    }
  }
  case loop_(expr) {
    writer.write_str("loop ")
    writer.write(indent, expr.*)
  }
  case break_(break_) {
    writer.write_str("<break>(")
    writer.write(indent, break_.*)
    writer.write_str(")")
  }
  case continue_ writer.write_str("<continue>")
  case return_(return_) {
    writer.write_str("return ")
    writer.write(indent, return_.*)
  }
  case try(expr) {
    writer.write(indent, expr.*)
    writer.write_char('?)
  }
  case body(body) writer.write_body(indent, body)
}

| Parsing  
| Unlike the parser in Candy (github.com/candy-lang/candy), the Martinaise
| parser favors simplicity over robustness. The first time it encounters an
| error, it simply gives up. This also means that for invalid code, you'll only
| get the first syntax error reported.
| 
| The parser is structured as a recursive descent parser: Lots of little
| functions call each other, each parsing a specific syntax, and all operate
| with a common cursor. Almost all parser functions return
| Result[Maybe[...], Str], where the return value has this meaning:
|
| - ok(none): The parser function doesn't match what comes next in the input.
|   The cursor remains unchanged.
| - ok(some(...)): The parsing was successful. The result is in the return
|   value.
| - error(...): The input is invalid. The entire parser should give up. The
|   cursor is at the position where the error in the input is.
|
| For example, here are possible results of the parse_number function:
|
| input         | "abc"    | "42 foo"     | "42foo"
| cursor before |  ^       |  ^           |  ^
| cursor after  |  ^       |    ^         |    ^
| result        | ok(none) | ok(some(42)) | error("Expected another digit.")
|
| - In the first case, the parser didn't match because the input doesn't start
|   with a digit.
| - In the second case, the parser does match, and it successfully parses the
|   number, moving the cursor after the number.
| - In the third case, the input starts with a digit – unmistakably a number!
|   However, because it has a lowercase letter in it, it's invalid and results
|   in an error. This is an invalid program.
|
| Whitespace is automatically consumed by the fundamental parsers. This is done
| because Martinaise generally doesn't care about whitespace and it makes the
| code of the higher-level parsers (structs, enums, etc.) much more concise.

struct Parser { code: Slice[U8], cursor: U64 }

fun current(parser: Parser): U8 { parser.code.get(parser.cursor) }
fun rest(parser: Parser): Slice[U8] { parser.code.subslice(parser.cursor) }
fun advance(parser: &Parser) { parser.advance_by(1) }
fun advance_by(parser: &Parser, n: U64) { parser.cursor = parser.cursor.add(n) }
| TODO: move into stdlib
fun is_whitespace(char: U8): Bool {
  char.equals(' ).or(char.equals(tab())).or(char.equals(newline()))
}

fun consume_whitespace(parser: &Parser) {
  loop {
    if parser.cursor.is_at_least(parser.code.len) then break
    var char = parser.current()
    if char.is_whitespace() then {
      parser.cursor = parser.cursor.inc()
      continue
    }
    if char.equals('|) then {
      loop {
        if parser.cursor.is_at_least(parser.code.len) then break
        if parser.current().equals(newline()) then break
        parser.cursor = parser.cursor.inc()
      }
      continue
    }
    break | not a whitespace nor comment
  }
}

fun consume_prefix(parser: &Parser, prefix: Slice[U8]): Maybe[Nothing] {
  parser.consume_whitespace()
  if not(parser.rest().starts_with(prefix)) then return none[Nothing]()
  parser.advance_by(prefix.len)
  some({})
}

| Also makes sure there's a non-letter following, so consume_keyword("fun")
| doesn't match the code "funny".
fun consume_keyword(parser: &Parser, keyword: Slice[U8]): Maybe[Nothing] {
  parser.consume_whitespace()
  if not(parser.rest().starts_with(keyword)) then return none[Nothing]()
  if parser.rest().len.is_greater_than(keyword.len) then {
    var char_after = parser.rest().get(keyword.len)
    var goes_on = char_after.equals('_)
      .or('A.until('Z).contains(char_after))
      .or('a.until('z).contains(char_after))
      .or('0.until('9).contains(char_after))
    if goes_on then return none[Nothing]()
  }
  parser.advance_by(keyword.len)
  some({})
}

fun parse_name(parser: &Parser): Maybe[Slice[U8]] {
  var start = parser.cursor
  loop {
    var char = parser.current()
    if 'A.until('Z).contains(char).or('a.until('z).contains(char)).or(char.equals('_))
    then { parser.advance() continue }
    if '0.until('9).contains(char) then
      if parser.cursor.equals(start)
      then break
      else { parser.advance() continue }
    break
  }
  if parser.cursor.equals(start) then return none[Slice[U8]]()
  some(parser.code.subslice(start, parser.cursor))
}

fun parse_lower_name(parser: &Parser): Maybe[Slice[U8]] {
  parser.consume_whitespace()
  if not('a.until('z).contains(parser.current())) then return none[Slice[U8]]()
  parser.parse_name()
}

fun parse_upper_name(parser: &Parser): Maybe[Slice[U8]] {
  parser.consume_whitespace()
  if not('A.until('Z).contains(parser.current())) then return none[Slice[U8]]()
  parser.parse_name()
}

| Convenience methods for the three possible results of parsers returning a
| Result[Maybe[T]].
| alias ParseResult[T] = Result[Maybe[T], Slice[U8]]
fun bad_input[T](error: Slice[U8]): Result[Maybe[T], Slice[U8]] {
  error[Maybe[T], Slice[U8]](error)
}
fun no_match[T](): Result[Maybe[T], Slice[U8]] {
  ok[Maybe[T], Slice[U8]](none[T]())
}
fun parsed[T](val: T): Result[Maybe[T], Slice[U8]] {
  ok[Maybe[T], Slice[U8]](some(val))
}

fun parse_type(parser: &Parser): Result[Maybe[Type], Slice[U8]] {
  if parser.consume_prefix("&") is some then {
    var arg = parser.parse_type()?
      orelse return bad_input[Type]("After &, there must come a type.")
    return parsed(type("&", vec(arg)))
  }
  if parser.consume_prefix("_") is some then return parsed(type("_"))

  var name = parser.parse_upper_name() orelse return no_match[Type]()
  var args = parser.parse_type_args()? orelse vec[Type]()
  parsed(Type { name, args })
}

fun parse_type_args(parser: &Parser): Result[Maybe[Vec[Type]], Slice[U8]] {
  var args = vec[Type]()
  parser.consume_prefix("[") orelse return no_match[Vec[Type]]()
  loop {
    var arg = parser.parse_type()? orelse break
    args.&.push(arg)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("]") orelse return bad_input[Vec[Type]](
    "Expected a closing bracket to end the type arguments.")
  parsed(args)
}

fun parse_type_params(parser: &Parser): Result[Maybe[Vec[Slice[U8]]], Slice[U8]] {
  var args = vec[Slice[U8]]()
  parser.consume_prefix("[") orelse return no_match[Vec[Slice[U8]]]()
  loop {
    var arg = parser.parse_upper_name() orelse break
    args.&.push(arg)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("]") orelse return bad_input[Vec[Slice[U8]]](
    "Expected a closing bracket to end the type arguments.")
  parsed(args)
}

| TODO: explanation
fun parse_expr(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var expr = parser.parse_expr_without_suffix()?
    orelse return no_match[AstExpr]()
  loop
    switch parser.parse_expr_suffix(expr)? case some(e) expr = e case none break
  parsed(expr)
}
fun parse_expr_without_suffix(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  if parser.parse_int()? is some(i) then return parsed(i)
  if parser.parse_char()? is some(c) then return parsed(c)
  if parser.parse_str()? is some(s) then return parsed(s)
  if parser.parse_make()? is some(s) then return parsed(s)
  if parser.parse_body()? is some(b) then return parsed(AstExpr.body(b))
  if parser.parse_var()? is some(v) then return parsed(AstExpr.var_(v))
  if parser.parse_if()? is some(i) then return parsed(i)
  if parser.parse_switch()? is some(s) then return parsed(s)
  if parser.parse_loop()? is some(l) then return parsed(l)
  if parser.parse_for()? is some(f) then return parsed(f)
  if parser.parse_break()? is some(b) then return parsed(b)
  if parser.parse_continue()? is some(c) then return parsed(c)
  if parser.parse_return()? is some(r) then return parsed(r)
  if parser.parse_lower_name() is some(n) then return parsed(AstExpr.name(n))
  if parser.current().equals(';) then return bad_input[AstExpr](
    "Nice try, Mik!")
  no_match[AstExpr]()
}
fun parse_expr_suffix(parser: &Parser, expr: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  if parser.parse_expr_suffix_member(expr)? is some(m) then return parsed(m)
  if parser.parse_expr_suffix_call(expr)? is some(c) then return parsed(c)
  if parser.parse_expr_suffix_assign(expr)? is some(a) then return parsed(a)
  if parser.parse_expr_suffix_orelse(expr)? is some(o) then return parsed(o)
  if parser.parse_expr_suffix_try(expr)? is some(t) then return parsed(t)
  no_match[AstExpr]()
}

fun parse_digits(parser: &Parser, radix: U64): Result[Maybe[U64], Slice[U8]] {
  var start = parser.cursor
  var num = 0
  if radix.is_greater_than(10.add(26))
  then return bad_input[U64]("The radix is too big.")
  loop {
    var char = parser.current()
    if '0.to('0.add(min(radix, 10).to_U8())).contains(char) then {
      num = num.multiply(radix).add(char.subtract('0).to_U64())
      parser.advance()
      continue
    }
    if radix.is_at_least(10) then
      if 'a.to('a.add(min(radix.subtract(10), 26).to_U8())).contains(char) then {
        num = num.multiply(radix).add(char.subtract('a).add(10_U8).to_U64())
        parser.advance()
        continue
      }
    if char.equals('_) then parser.advance() else break
  }
  if parser.cursor.equals(start) then return no_match[U64]()
  parsed(num)
}

fun parse_int(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_whitespace()
  var value = parser.parse_digits(10)? orelse return no_match[AstExpr]()
  if parser.consume_prefix("#") is some then {
    var radix = value
    value = parser.parse_digits(radix)? orelse return bad_input[AstExpr](
      "Expected the value of the number after the radix pound.")
  }
  parser.consume_prefix(":")
    orelse return parsed(AstExpr.int(Int {
      value,
      config = IntConfig { signedness = Signedness.unsigned, bits = 64 },
    }))
  var signedness =
    if parser.consume_prefix("I") is some then Signedness.signed
    else if parser.consume_prefix("U") is some then Signedness.unsigned
    else return bad_input[AstExpr]("Expected a signedness (U or I).")
  var bits = parser.parse_digits(10)?
    orelse return bad_input[AstExpr]("Expected bit length of the integer.")
  | TODO: check that number fits in range
  parsed(AstExpr.int(Int { value, config = IntConfig { signedness, bits } }))
}

fun parse_char(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("#") orelse return no_match[AstExpr]()
  var char = parser.current()
  parser.advance()
  parsed(AstExpr.make_struct(AstMakeStruct {
    type = type("Char"),
    fields = vec(AstMakeStructField {
      name = "byte",
      value = AstExpr.int(Int {
        value = char.to_U64(),
        config = IntConfig { signedness = Signedness.unsigned, bits = 8 }
      }),
    })
  }))
}

fun parse_str(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var parts = parser.parse_str_parts()? orelse return no_match[AstExpr]()
  if parts.len.equals(1) then {
    var expr = parts.get(0)
    if expr is str then return parsed(expr)
  }
  var body = vec[AstExpr]()
  body.&.push(var_("$str",
    AstExpr.name("vec")
      .call(some(vec(type("U8"))), vec[AstExpr]())
      .member("&")))
  for part in parts do
    body.&.push(AstExpr.name("$str").member("write").call(vec(part)))
  body.&.push(AstExpr.name("$str").member("to_slice").call().member("to_str").call())
  parsed(AstExpr.body(body))
}
| Parses a string literal, potentially with interpolation, into expressions.
| Metaness 0: "Hello" -> ["Hello"]
|             "Hello, {3}!" -> ["Hello", 3]
| Metaness 1: '"foo " bar"' -> ['foo " bar ']
fun parse_str_parts(parser: &Parser): Result[Maybe[Vec[AstExpr]], Slice[U8]] {
  | strings starts with metaness single quotes, then a double quote
  var metaness = 0
  loop
      if parser.rest().get(metaness).not_equals('')
      then break
      else metaness = metaness.inc()
  if parser.rest().get(metaness).not_equals('") | to fix syntax highlighting: "'
  then return
    if metaness.is_at_least(1)
    then bad_input[Vec[AstExpr]]("Expected a double quote.")
    else no_match[Vec[AstExpr]]()
  parser.advance_by(metaness.inc())

  var parts = vec[AstExpr]()
  var part = vec[U8]()
  loop {
    { | (metaness + 1) braces = interpolation
      var num_braces = 0
      loop
        if parser.rest().get(num_braces).equals('{)
        then num_braces = num_braces.inc()
        else break
      if num_braces.is_at_least(metaness.inc()) then {
        for i in 0.to(num_braces.subtract(metaness.inc())) do part.&.push('{)
        if part.is_not_empty() then {
          parts.&.push(AstExpr.str(part.to_slice()))
          part = vec[U8]()
        }
        parser.advance_by(num_braces)
        var expr = parser.parse_expr()?
          orelse return bad_input[Vec[AstExpr]](
            "Expected an expression as string interpolation.")
        parts.&.push(expr)
        for i in 0.until(metaness) do
          parser.consume_prefix("}") orelse return bad_input[Vec[AstExpr]](
            "Expected a closing brace after string interpolation.")
        continue
      }
    }
    | newline doesn't appear in str, parses next line until single quote
    if parser.current().equals(newline()) then {
      parser.advance()
      loop {
        var char = parser.current()
        if char.equals(' ) then { parser.advance() continue }
        if char.equals('') then break
        return bad_input[Vec[AstExpr]](
          "After a newline, a string needs to have a single quote.")
      }
      parser.advance()
      continue
    }
    | double quote + metaness single quotes = string ends
    if parser.current().equals('") then if { | to fix syntax highlighting: "'
      var is_followed_by_enough_single_quotes = true()
      for j in 1.until(metaness) do
        if parser.rest().get(j).not_equals('')
        then is_followed_by_enough_single_quotes = false()
      is_followed_by_enough_single_quotes
    } then {
      if part.is_not_empty() then parts.&.push(AstExpr.str(part.to_slice()))
      parser.advance_by(metaness.inc())
      return parsed(parts)
    }
    | everything else is a literal character
    part.&.push(parser.current())
    parser.advance()
  }
}

fun parse_make(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var type = parser.parse_type()? orelse return no_match[AstExpr]()
  if parser.consume_prefix("{") is some then {
    var fields = vec[AstMakeStructField]()
    loop {
      var name = parser.parse_lower_name() orelse break
      var value =
        if parser.consume_prefix("=") is some
        then parser.parse_expr()?
          orelse return bad_input[AstExpr]("Expected the value of the field.")
        else AstExpr.name(name)
      fields.&.push(AstMakeStructField { name, value })
      parser.consume_prefix(",") orelse break
    }
    parser.consume_prefix("}")
      orelse return bad_input[AstExpr]("Expected a closing brace.")
    parsed(AstExpr.make_struct(AstMakeStruct { type, fields }))
  } else {
    parser.consume_prefix(".")
      orelse return bad_input[AstExpr](
        "Expected struct or enum creation.")
    var variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected the variant.")
    
    var arg = AstExpr.body(vec[AstExpr]())
    if parser.consume_prefix("(") is some then {
      arg = parser.parse_expr()?
        orelse return bad_input[AstExpr](
          "Expected an argument for the variant.")
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
    parsed(AstExpr.make_enum(
      AstMakeEnum { type, variant, arg = arg.put_on_heap() }
    ))
  }
}

fun parse_body(parser: &Parser): Result[Maybe[Vec[AstExpr]], Slice[U8]] {
  parser.consume_prefix("{") orelse return no_match[Vec[AstExpr]]()
  var statements = vec[AstExpr]()
  loop switch parser.parse_expr()?
  case some(e) statements.&.push(e)
  case none break
  parser.consume_prefix("}")
    orelse return bad_input[Vec[AstExpr]](
      "Expected the closing brace of the body.")
  parsed(statements)
}

fun parse_var(parser: &Parser): Result[Maybe[AstVar], Slice[U8]] {
  parser.consume_keyword("var") orelse return no_match[AstVar]()
  var name = parser.parse_lower_name()
    orelse return bad_input[AstVar]("Expected the name of the variable.")
  parser.consume_prefix("=")
    orelse return bad_input[AstVar]("Expected an equals sign.")
  var value = parser.parse_expr()?
    orelse return bad_input[AstVar]("Expected the value of the variable.")
  parsed(AstVar { name, value = value.put_on_heap() })
}

fun parse_if(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("if") orelse return no_match[AstExpr]()
  var condition = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected the condition.")
  var variant = "true"
  var binding = none[Slice[U8]]()
  if parser.consume_keyword("is") is some then {
    variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected a variant.")
    if parser.consume_prefix("(") is some then {
      binding = some(parser.parse_lower_name()
        orelse return bad_input[AstExpr]("Expected the name of the binding."))
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
  }
  parser.consume_keyword("then")
    orelse return bad_input[AstExpr]("Expected then keyword.")
  var then_ = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected a then expression.")
  var else_ = AstExpr.body(vec[AstExpr]())
  if parser.consume_keyword("else") is some
  then else_ = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected an else expression.")
  parsed(AstExpr.switch_(AstSwitch {
    value = condition.put_on_heap(),
    cases = vec(AstCase { variant, binding, then_ = then_.put_on_heap() }),
    default_ = some(else_.put_on_heap()),
  }))
}

fun parse_switch(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("switch") orelse return no_match[AstExpr]()
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected the value that is switched over.")
  var cases = vec[AstCase]()
  loop {
    parser.consume_keyword("case") orelse break
    var variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected a variant.")
    var binding = none[Slice[U8]]()
    if parser.consume_prefix("(") is some then {
      binding = some(parser.parse_lower_name()
        orelse return bad_input[AstExpr]("Expected the name of the binding."))
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
    var then_ = parser.parse_expr()?
        orelse return bad_input[AstExpr]("Expected a case expression.")
    cases.&.push(AstCase { variant, binding, then_ = then_.put_on_heap() })
  }
  var default_ = none[&AstExpr]()
  if parser.consume_keyword("default") is some
  then {
    var default__ = parser.parse_expr()?
      orelse return bad_input[AstExpr]("Expected a default expression.")
    default_ = some(default__.put_on_heap())
  }
  parsed(AstExpr.switch_(AstSwitch {
    value = value.put_on_heap(),
    cases,
    default_
  }))
}

fun parse_loop(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("loop") orelse return no_match[AstExpr]()
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected loop expression.")
  parsed(AstExpr.loop_(expr.put_on_heap()))
}

fun parse_for(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("for") orelse return no_match[AstExpr]()
  var iter_var = parser.parse_lower_name()
    orelse return bad_input[AstExpr](
      "Expected the name of the iteration variable.")
  parser.consume_keyword("in")
    orelse return bad_input[AstExpr]("Expected in keyword.")
  var iter = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected something to iterate over.")
  parser.consume_keyword("do")
    orelse return bad_input[AstExpr]("Expected do keyword.")
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected a loop expression.")
  parsed(AstExpr.body(vec(
    var_("$iter", iter.member("iter").call().member("&")),
    AstExpr.loop_(AstExpr.body(vec(
      var_(iter_var, AstExpr.switch_(AstSwitch {
        value = AstExpr.name("$iter").member("next").call().put_on_heap(),
        cases = vec(
          AstCase {
            variant = "some",
            binding = some("a"),
            then_ = AstExpr.name("a").put_on_heap()
          },
          AstCase {
            variant = "none",
            binding = none[Slice[U8]](),
            then_ = AstExpr.break_(AstExpr.make_struct(AstMakeStruct {
              type = type("Nothing"),
              fields = vec[AstMakeStructField](),
            }).put_on_heap()).put_on_heap(),
          },
        ),
        default_ = none[&AstExpr](),
      })),
      expr,
    )).put_on_heap())
  )))
}

fun parse_break(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("break") orelse return no_match[AstExpr]()
  var expr = if parser.consume_prefix("(") is some
    then {
      var e = parser.parse_expr()?
        orelse return bad_input[AstExpr]("Expected break expression.")
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected closing parenthesis.")
      e
    }
    else AstExpr.make_struct(AstMakeStruct {
      type = type("Nothing"),
      fields = vec[AstMakeStructField](),
    })
  parsed(AstExpr.break_(expr.put_on_heap()))
}

fun parse_continue(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("continue") orelse return no_match[AstExpr]()
  parsed(AstExpr.continue_)
}

fun parse_return(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("return") orelse return no_match[AstExpr]()
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected returned expression.")
  parsed(AstExpr.return_(expr.put_on_heap()))
}

fun parse_expr_suffix_member(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix(".") orelse return no_match[AstExpr]()
  if parser.consume_prefix("*") is some then return parsed(current.member("*"))
  if parser.consume_prefix("&") is some then return parsed(current.member("&"))
  if parser.parse_lower_name() is some(name)
  then return parsed(current.member(name))
  if parser.parse_str_parts()? is some(parts) then return {
    var body = vec[AstExpr]()
    body.&.push(var_("$str", current))
    for part in parts do
      body.&.push(AstExpr.name("$str").member("write").call(vec(part)))
    parsed(AstExpr.body(body))
  }
  return bad_input[AstExpr]("Expected the name of a member.")
}

fun parse_expr_suffix_call(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  var type_args = parser.parse_type_args()?
  parser.consume_prefix("(")
    orelse return
      if type_args is some
      then bad_input[AstExpr]("Expected an opening parenthesis.")
      else no_match[AstExpr]()
  var args = vec[AstExpr]()
  loop {
    args.&.push(parser.parse_expr()? orelse break)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix(")")
    orelse return bad_input[AstExpr](
      "Expected closing parenthesis of the call.")
  parsed(current.call(type_args, args))
}

fun parse_expr_suffix_type_arged(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  var type_args = parser.parse_type_args()? orelse return no_match[AstExpr]()
  parsed(AstExpr.type_arged(AstTypeArged {
    expr = current.put_on_heap(),
    type_args,
  }))
}

fun parse_expr_suffix_assign(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("=") orelse return no_match[AstExpr]()
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected an expression on the right side of the assign.")
  parsed(AstExpr.assign(AstAssign {
    to = current.put_on_heap(),
    value = value.put_on_heap(),
  }))
}

fun parse_expr_suffix_orelse(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("orelse") orelse return no_match[AstExpr]()
  var binding = if parser.consume_prefix("(") is some
    then {
      var name = parser.parse_lower_name()
        orelse return bad_input[AstExpr]("Expected orelse binding.")
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected closing parenthesis.")
      some(name)
    }
    else none[Slice[U8]]()
  var alternative = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected alternative expression after orelse.")
  parsed(AstExpr.switch_(AstSwitch {
    value = current.member("to_orelse").call().put_on_heap(),
    cases = vec(
      AstCase {
        variant = "primary",
        binding = some("$primary"),
        then_ = AstExpr.name("$primary").put_on_heap(),
      },
      AstCase {
        variant = "secondary",
        binding,
        then_ = alternative.put_on_heap(),
      },
    ),
    default_ = none[&AstExpr](),
  }))
}

fun parse_expr_suffix_try(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("?") orelse return no_match[AstExpr]()
  parsed(AstExpr.try(current.put_on_heap()))
}

fun parse_fun(parser: &Parser): Result[Maybe[AstFun], Slice[U8]] {
  parser.consume_keyword("fun") orelse return no_match[AstFun]()
  var fun_name = parser.parse_lower_name()
    orelse return bad_input[AstFun]("Expected the name of the function.")
  var type_args = parser.parse_type_params()? orelse vec[Slice[U8]]()
  var args = vec[AstFunArg]()
  parser.consume_prefix("(")
    orelse return bad_input[AstFun]("Expected an opening parenthesis.")
  loop {
    var name = parser.parse_lower_name() orelse break
    parser.consume_prefix(":")
      orelse return bad_input[AstFun]("Expected a colon.")
    var type = parser.parse_type()?
      orelse return bad_input[AstFun]("Expected the type of the argument.")
    args.&.push(AstFunArg { name, type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix(")")
    orelse return bad_input[AstFun]("Expected a closing parenthesis.")
  var returns = type("Nothing")
  if parser.consume_prefix(":") is some
  then returns = parser.parse_type()?
    orelse return bad_input[AstFun]("Expected the return type.")
  var is_builtin = false()
  var body =
    switch parser.consume_prefix("{ ... }")
    case some { is_builtin = true() vec[AstExpr]() }
    case none parser.parse_body()?
      orelse return bad_input[AstFun]("Expected a function body.")
  parsed(AstFun { name = fun_name, type_args, args, returns, is_builtin, body })
}

fun parse_struct(parser: &Parser): Result[Maybe[AstStruct], Slice[U8]] {
  parser.consume_keyword("struct") orelse return no_match[AstStruct]()
  var name = parser.parse_upper_name()
    orelse return bad_input[AstStruct]("Expected an uppercase name.")
  var type_args = parser.parse_type_params()? orelse vec[Slice[U8]]()
  parser.consume_prefix("{")
    orelse return bad_input[AstStruct]("Expected an opening brace.")
  var fields = vec[AstStructField]()
  loop {
    var field_name = parser.parse_lower_name() orelse break
    parser.consume_prefix(":")
      orelse return bad_input[AstStruct]("Expected a colon.")
    var field_type = parser.parse_type()?
      orelse return bad_input[AstStruct]("Expected the type of the field.")
    fields.&.push(AstStructField { name = field_name, type = field_type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("}")
    orelse return bad_input[AstStruct](
      "Expected a closing brace to end the struct.")
  parsed(AstStruct { name, type_args, fields })
}

fun parse_enum(parser: &Parser): Result[Maybe[AstEnum], Slice[U8]] {
  parser.consume_keyword("enum") orelse {
    return no_match[AstEnum]()
  }
  var name = parser.parse_upper_name()
    orelse return bad_input[AstEnum]("Expected an uppercase name.")
  var type_args = parser.parse_type_params()? orelse vec[Slice[U8]]()
  parser.consume_prefix("{")
    orelse return bad_input[AstEnum]("Expected an opening brace.")
  var variants = vec[AstEnumVariant]()
  loop {
    var variant_name = parser.parse_lower_name() orelse break
    var variant_type = type("Nothing")
    if parser.consume_prefix(":") is some
    then variant_type = parser.parse_type()?
      orelse return bad_input[AstEnum]("Expected the type of the variant.")
    variants.&.push(AstEnumVariant { name = variant_name, type = variant_type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("}")
    orelse return bad_input[AstEnum](
      "Expected a closing brace to end the enum.")
  parsed(AstEnum { name, type_args, variants })
}

fun parse_def(parser: &Parser): Result[Maybe[AstDef], Slice[U8]] {
  if parser.parse_struct()? is some(s) then return parsed(AstDef.struct_(s))
  if parser.parse_enum()? is some(e) then return parsed(AstDef.enum_(e))
  if parser.parse_var()? is some(v) then return parsed(AstDef.var_(v))
  if parser.parse_fun()? is some(f) then return parsed(AstDef.fun_(f))
  no_match[AstDef]()
}

fun parse_defs(parser: &Parser): Result[Vec[AstDef], Slice[U8]] {
  var defs = vec[AstDef]()
  loop switch parser.parse_def()? case some(d) defs.&.push(d) case none break
  if parser.cursor.is_less_than(parser.code.len)
  then return error[Vec[AstDef], Slice[U8]]("Expected a definition.")
  ok[Vec[AstDef], Slice[U8]](defs)
}

fun parse(code: Slice[U8], stdlib_size: U64): Result[Ast, Slice[U8]] {
  var parser = Parser { code, cursor = 0 }
  | TODO: Replace switch with catch/orelse
  switch parser.&.parse_defs()
  case error(error) {
    if parser.cursor.is_at_most(stdlib_size)
    then error[Ast, Slice[U8]](
      format_error_with_context(parser.code, parser.cursor, error))
    else error[Ast, Slice[U8]](format_error_with_context(
      parser.code.subslice(stdlib_size),
      parser.cursor.subtract(stdlib_size),
      error
    ))
  }
  case ok(defs) {
    | Add builtins
    | TODO: Explanation

    | struct &[T] { *: T }
    defs.&.push(AstDef.struct_(AstStruct {
      name = "&",
      type_args = vec("T"),
      fields = vec(AstStructField { name = "*", type = type("T") })
    }))

    | Int stuff
    for config in all_int_configs() do {
      var type = config.to_type()
      defs.&.push(AstDef.builtin_type(type.name))

      var two_args = vec(
        AstFunArg { name = "a", type },
        AstFunArg { name = "b", type },
      )
      defs.&.push_builtin_fun("add", two_args, type)
      defs.&.push_builtin_fun("subtract", two_args, type)
      defs.&.push_builtin_fun("multiply", two_args, type)
      defs.&.push_builtin_fun("divide", two_args, type)
      defs.&.push_builtin_fun("modulo", two_args, type)
      defs.&.push_builtin_fun("compare_to", two_args, type("Ordering"))
      defs.&.push_builtin_fun("shiftLeft", two_args, type)
      defs.&.push_builtin_fun("shiftRight", two_args, type)
      defs.&.push_builtin_fun("bitLength", two_args, type)
      defs.&.push_builtin_fun("and", two_args, type)
      defs.&.push_builtin_fun("or", two_args, type)
      defs.&.push_builtin_fun("xor", two_args, type)

      | Conversion function
      for target_config in all_int_configs() do {
        if config.not_equals(target_config) then {
          var target_type = target_config.to_type()
          var name = vec[U8]()
          name.&.write_str("to_")
          name.&.write(target_type)
          defs.&.push_builtin_fun(name.to_slice(), vec(AstFunArg { name = "i", type }), target_type)
        }
      }
    }

    ok[Ast, Slice[U8]](Ast { defs })
  }
}
fun push_builtin_fun(defs: &Vec[AstDef], name: Slice[U8], args: Vec[AstFunArg], returns: Type) {
  defs.push(AstDef.fun_(AstFun {
    name,
    type_args = vec[Slice[U8]](),
    args,
    returns,
    is_builtin = true(),
    body = vec[AstExpr](),
  }))
}
fun format_error_with_context(code: Slice[U8], offset: U64, error: Slice[U8]): Slice[U8] {
  var lines = vec[Vec[U8]]()
  var current_line = vec[U8]()
  var offset_in_line = 0
  for i in 0.to(code.len) do {
    if i.equals(offset) then offset_in_line = current_line.len
    if code.get(i).equals(newline())
    then {
      lines.&.push(current_line)
      current_line = vec[U8]()
      if i.is_at_least(offset) then break
    }
    else current_line.&.push(code.get(i))
  }
  | Now, lines contains all lines up to the line that contains the
  | error. offset_in_line is the offset into the last complete line.
  var num_lines_to_display = min(lines.len, 4)
  var out = vec[U8]().&
  for line_number in lines.len.subtract(num_lines_to_display).to(lines.len) do {
    out.write_line_number(line_number)
    out.write_str(" | ")
    out.write_str(lines.get(line_number).to_slice())
    out.write_char(newline())
  }
  for i in 0.to(7.add(offset_in_line)) do out.write_char(' )
  out.write_char('^)
  out.write_char(newline())
  for i in 0.to(7.add(offset_in_line)) do out.write_char(' )
  out.write_str(error)
  out.to_slice()
}
fun write_line_number[W](writer: W, n: U64) {
  if n.is_at_least(1000) then writer.write(n)
  else if n.is_at_least(100) then { writer.write_str(" ") writer.write(n) }
  else if n.is_at_least(10) then { writer.write_str("  ") writer.write(n) }
  else { writer.write_str("   ") writer.write(n) }
}

| Mono  
| Generic code such as a function foo[T]() doesn't have any generic
| representation in the final output. Instead, for every place where foo is
| called (every "callsite"), a new version of foo gets compiled. This process
| (called "monomorphization") enables useful programming patterns. For example,
| just by writing a compare_to function for a type, you can automatically use
| all other comparison functions. Generally speaking, monomorphized code also
| tends to be faster than general code.
|
| The Mono is the next stage in the compiler. Here, functions and types are
| monomorphized (aka they are not generic anymore). Only the functions and types
| that are reachable from the main function appear here – everything else is
| ignored. While the AST may contain invalid code (like 3 = 1), the Mono is
| guaranteed to be correct – during the monomorphization, variable scoping, name
| lookups, and type checking take place.
| 
| TODO: explain slots, statements, expressions, globals

struct Mono {
  | Monomorphized type definitions.
  type_defs: Map[Type, MonoTypeDef],

  | Global variables. They map to a function that computes the value.
  globals: Map[Slice[U8], MonoFun],
  globals_init_order: Vec[Slice[U8]],

  | Monomorphized functions. Keys are signatures such as "foo[U8](U8)".
  funs: Map[Slice[U8], MonoFun],
}

enum MonoTypeDef {
  builtin_type,
  struct_: MonoStruct,
  enum_: MonoEnum,
}
struct MonoStruct { fields: Vec[MonoStructField] }
struct MonoStructField { name: Slice[U8], type: Type }
struct MonoEnum { variants: Vec[MonoEnumVariant] }
struct MonoEnumVariant { name: Slice[U8], type: Type }

struct MonoFun {
  type_args: Vec[Type],
  arg_types: Vec[Type],
  return_type: Type,
  is_builtin: Bool,
  slots: Vec[MonoSlot],
  body: Vec[MonoStatement],
}

struct MonoSlot { type: Type, initial_value: MonoSlotValue }
enum MonoSlotValue { uninitialized, arg: U64, int: U64, str: Slice[U8] }
struct MonoSlotRef { index: U64 }

enum MonoStatement {
  label: MonoLabel,
  assign: MonoAssign,
  set_enum: MonoSetEnum,
  call: MonoCall,
  jump: MonoJump,
  jump_if_variant: MonoJumpIfVariant,
  get_enum_value: MonoGetEnumValue,
  return_: MonoExpr,
  ref: MonoRef,
}
struct MonoLabel { id: U64 }
struct MonoAssign { to: MonoExpr, value: MonoExpr }
struct MonoSetEnum { slot: MonoSlotRef, variant: Slice[U8], value: MonoExpr }
struct MonoCall { to: MonoSlotRef, fun_: Slice[U8], args: Vec[MonoExpr] }
struct MonoJump { target: MonoLabel }
struct MonoJumpIfVariant {
  condition: MonoExpr,
  variant: Slice[U8],
  target: MonoLabel
}
struct MonoGetEnumValue { to: MonoSlotRef, of: MonoExpr, variant: Slice[U8] }
struct MonoRef { to: MonoSlotRef, of: MonoExpr }

struct MonoExpr { type: Type, kind: MonoExprKind }
enum MonoExprKind {
  nothing,
  never,
  global: Slice[U8],
  slot: MonoSlotRef,
  member: MonoMember,
}
struct MonoMember { of: &MonoExpr, name: Slice[U8] }

fun write[W](writer: W, mono: Mono) {
  writer.write_str("Types:")
  writer.write_char(newline())
  | TODO: add keys and value iters to stdlib
  for entry in mono.type_defs do {
    writer.write_str("- ")
    writer.write(entry.key)
    writer.write_char(newline())
  }

  writer.write_str("Globals:")
  writer.write_char(newline())
  for entry in mono.globals do {
    writer.write_str("- ")
    writer.write_str(entry.key)
    writer.write_str(": ")
    writer.write(entry.value.return_type)
    writer.write_char(newline())
  }

  writer.write_str("Funs:")
  writer.write_char(newline())
  for entry in mono.funs do {
    writer.write(entry.key, entry.value)
    writer.write_char(newline())
  }
}
fun write[W](writer: W, name: Slice[U8], fun_: MonoFun) {
  writer.write_str(name)
  writer.write_char(newline())
  if fun_.is_builtin then { writer.write_str("  <builtin>") return {} }

  var i = 0
  for slot in fun_.slots do {
    if i.is_greater_than(0) then writer.write_char(newline())
    writer.write_str("  _")
    writer.write(i)
    writer.write_str(": ")
    writer.write(slot.type)
    writer.write_str(" = ")
    switch slot.initial_value
    case uninitialized writer.write_str("uninitialized")
    case arg(j) {
      writer.write_str("arg_")
      writer.write(j)
    }
    case int(int) writer.write(int)
    case str(str) {
      writer.write_char('") | to fix syntax highlighting: "'
      writer.write_str(str)
      writer.write_char('") | to fix syntax highlighting: "'
    }
    i = i.inc()
  }
  for statement in fun_.body do {
    writer.write_char(newline())
    writer.write_str("  ")
    writer.write(statement)
  }
}
fun write[W](writer: W, statement: MonoStatement) {
  switch statement
  case label(label) {
    writer.write(label)
    writer.write_str(":")
  }
  case assign(assign) {
    writer.write(assign.to)
    writer.write_str(" = ")
    writer.write(assign.value)
  }
  case set_enum(set_enum) {
    writer.write(set_enum.slot)
    writer.write_str(" = ")
    writer.write_str(set_enum.variant)
    writer.write_str("(")
    writer.write(set_enum.value)
    writer.write_str(")")
  }
  case call(call) {
    writer.write(call.to)
    writer.write_str(" = ")
    writer.write_str(call.fun_)
    writer.write_str(" called with (")
    var first = true()
    for arg in call.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(arg)
    }
    writer.write_str(")")
  }
  case jump(jump) {
    writer.write_str("jump to ")
    writer.write(jump.target)
  }
  case jump_if_variant(jump) {
    writer.write_str("if ")
    writer.write(jump.condition)
    writer.write_str(" is ")
    writer.write_str(jump.variant)
    writer.write_str(", jump to ")
    writer.write(jump.target)
  }
  case get_enum_value(get_enum_value) {
    writer.write(get_enum_value.to)
    writer.write_str(" = ")
    writer.write_str("get ")
    writer.write_str(get_enum_value.variant)
    writer.write_str(" value of ")
    writer.write(get_enum_value.of)
  }
  case return_(returned) {
    writer.write_str("return ")
    writer.write(returned)
  }
  case ref(expr) {
    writer.write(expr.to)
    writer.write_str(" = ")
    writer.write(expr.of)
    writer.write_str(".&")
  }
}
fun write[W](writer: W, label: MonoLabel) {
  writer.write_str("label_")
  writer.write(label.id)
}
fun write[W](writer: W, slot: MonoSlotRef) {
  writer.write_str("_")
  writer.write(slot.index)
}
fun write[W](writer: W, expr: MonoExpr) {
  switch expr.kind
  case global(name) {
    writer.write_str("global_")
    writer.write_str(name)
  }
  case slot(slot) writer.write(slot)
  case member(member) {
    writer.write(member.of.*)
    writer.write_str(".")
    writer.write_str(member.name)
  }
  case nothing writer.write_str("_nothing")
  case never writer.write_str("_never")
}

| Context  
| When monomorphizing fails, we want to have backtraces – a path from the main
| function over all monomorphized function to the failing location. The Context
| tracks what the compiler is currently doing – it's basically a stack of
| function signatures. Every time a signature is pushed or popped, it also
| prints a one-line message to the console, something like this:
|
| Compiling main > println > print > write > write_with_radix > digit_to_char...

struct Context { signatures: Vec[Slice[U8]] }

fun push(context: &Context, signature: Slice[U8]) {
  context.signatures.&.push(signature)
  context.print_status()
  if context.signatures.len.is_at_least(100) then {
    for signature in context.signatures do {
      printsln(signature)
    }
    panic("overflow")
  }
}
fun pop(context: &Context) {
  context.signatures.&.pop()
  context.print_status()
}

fun print_status(context: Context) {
  var out = vec[U8]().&
  out.write_str("Compiling ")
  var first = true()
  for signature in context.signatures do {
    if first then first = false() else out.write_str(" > ")
    | Because we want many signatures to fit on one line, only write the
    | function name up to the first opening parenthesis or bracket.
    var j = 0
    loop
      if signature.get(j).equals('().or(signature.get(j).equals('[))
      then break
      else j = j.inc()
    out.write_str(signature.subslice(0, j))
  }
  if out.len.is_greater_than(80) then {
    out.len = 77
    out.write_str("...")
  }
  print_on_same_line(out.to_slice())
}
fun write_stack_trace[W](writer: W, context: Context) {
  for signature in context.signatures do {
    writer.write_str(" - ")
    writer.write_str(signature)
    writer.write_char(newline())
  }
}

| Tracking Variables That Are In Scope  
| In Martinaise, variable shadowing is allowed – you can create a new variable
| with the same name as an existing one, whether in the same scope or an inner
| scope.
| Initially, information about which variables are in scope were stored in a
| hash map. Unfortunately, managing nested scopes gets difficult or inefficient
| pretty quickly.
| In Candy, we just dealt with this problem using some fancy new thing (tm). In
| our case, this is an immutable hash map from the "im" Rust crate – a hash map
| where inserting values returns a new hash map instead. The resulting hash maps
| share a lot of the data internally, so memory usage is not too bad. Still,
| we're creating heap-allocated pointer-linked nodes all over the place.
| Martinaise uses a much simpler approach: When new variables are defined, they
| are just appended to a vector. When entering scopes, we remember the length of
| the vector and we truncate it to that length when we exit the scope. For
| variable lookups, we walk the vec in reverse. Here's an example:
|
| var foo = 2
| var bar = 3
| var baz = {
|   var foo = foo.inc()
|   bar = bar.dec()
|   foo.multiply(2)
| }
|
| ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐
| │ foo = 2 │ (1) │ foo = 2 │ (2) │ foo = 2 │ (3) │ foo = 2 │ (4) │ foo = 2 │
| ├─────────┤     ├─────────┤     ├─────────┤     ├─────────┤     ├─────────┤
| │ bar = 3 │     │ bar = 3 │     │ bar = 2 │     │ bar = 3 │     │ bar = 3 │
| └─────────┘     ├─────────┤     ├─────────┤     └─────────┘     ├─────────┤
|                 │ foo = 3 │     │ foo = 3 │                     │ baz = 6 │
|                 └─────────┘     └─────────┘                     └─────────┘
|
| 1. When entering the baz scope, foo and bar are already defined. Because we
|    enter a scope, we remember the length of the variable vector (length 2).
|    The definition of foo inside the baz scope gets appended to the vector.
| 2. When accessing variables, we walk the vector from the end to the beginning.
|    "foo" accesses the foo from the inner scope, "bar" accesses the bar from
|    the outer scope. Here, bar is changed to a new value.
| 3. When exiting a scope, we truncate the vector to the length we remembered
|    (length 2). The newly defined foo goes out of scope.
| 4. New definitions are again just appended to the vector.
|
| You might think that doing a linear search on a vector is horribly
| inefficient. Thankfully, some aspects of this problem make this not-so-bad in
| practice:
|
| - Variable scopes tend to be small. Variables are local to a function, so they
|   are limited by the function length.
| - Martinaise makes it easy to start new scopes to avoid cluttering the
|   surrounding namespace. This makes the number of variables in a scope even
|   smaller.
| - You tend to use recently defined variables more often. As a result, walking
|   the vector is often pretty slow.
| - Computers are super fast. Linearly scanning through memory is one of the
|   fastest memory access patterns you can have, unlike traversing down nodes of
|   a hash map.

struct Vars[T] { visible: Vec[VarInScope[T]] }
struct VarInScope[T] { name: Slice[U8], data: T }
struct VarScope { num_visible: U64 }

fun vars[T](): Vars[T] { Vars { visible = vec[VarInScope[T]]() } }

fun define[T](vars: &Vars[T], name: Slice[U8], data: T) {
  vars.visible.&.push(VarInScope { name, data })
}
fun lookup[T](vars: Vars[T], name: Slice[U8]): Maybe[T] {
  for var_ in vars.visible.to_slice().rev_iter() do
    if var_.name.equals(name) then return some(var_.data)
  none[T]()
}

fun snapshot[T](vars: Vars[T]): VarScope {
  VarScope { num_visible = vars.visible.len }
}
fun restore[T](vars: &Vars[T], scope: VarScope) {
  vars.visible.len = scope.num_visible
}

| Type Sinks  
| At some places in the code, types need to "line up". Because of the Never
| type, this is less strict that type equality. Take this code for example:
|
| var a = if condition then 3 else return 4
|
| Even though both branches of the if have different types (U64 and Never), they
| still line up properly to a final U64 type. Type sinks are a way to ensure
| multiple expressions evaluate to the same type.

struct TypeSink { current: Maybe[Type] }

fun type_sink(): TypeSink { TypeSink { current = none[Type]() } }
fun type_sink(type: Type): TypeSink { TypeSink { current = some(type) } }

fun add(sink: &TypeSink, type: Type): Result[Nothing, Slice[U8]] {
  if type.equals(type("Never")) then return ok[Nothing, Slice[U8]]({})
  switch sink.current
  case none {
    sink.current = some(type)
    ok[Nothing, Slice[U8]]({})
  }
  case some(current) {
    switch merge(current, type)
    case some(merged) {
      sink.current = some(merged)
      ok[Nothing, Slice[U8]]({})
    }
    case none return error[Nothing, Slice[U8]]({
      var out = vec[U8]().&
      out.write_str(" expected: ")
      out.write(current)
      out.write_char(newline())
      out.write_str("   actual: ")
      out.write(type)
      out.to_slice()
    })
  }
}
| Merges potentially incomplete types. For example, Maybe[A, _] and Maybe[_, B]
| would get merged to Maybe[A, B].
fun merge(a: Type, b: Type): Maybe[Type] {
  if a.name.equals("_") then return some(b)
  if b.name.equals("_") then return some(a)
  if a.name.not_equals(b.name) then return none[Type]()
  if a.args.len.not_equals(b.args.len) then return none[Type]()
  var merged_args = vec[Type]()
  for i in 0.to(a.args.len) do
    switch merge(a.args.get(i), b.args.get(i))
    case none return none[Type]()
    case some(type) merged_args.&.push(type)
  some(type(a.name, merged_args))
}
fun finish(sink: TypeSink): Type { sink.current.unwrap() }

| Type Solving  
| When compiling generic code, the free type variables need to be bound to
| concrete types. For example, to compile a function foo[A](), we need to know
| what A is. For each specific A that foo is used with, a new version gets
| compiled. Type parameters such as A can also be inferred:
|
| fun foo[A](a: Foo[A], b: A) { ... }
| fun foo[A](a: A, b: A) { ... }
|
| foo(Foo[U64], U64)
|
| When compiling the call, the Martinaise compiler figures out to use the first
| function with A = U64. It uses the TypeSolver for that. Here's how to use it:
|
| 1. Create a TypeSolver, passing all type variables that need to be bound.
|    In the example above, that would be A.
| 2. Repeatedly call unify with the generic type and the concrete types of the
|    usage site.
|    - For calls, unify all arguments.
|    - For struct creations, unify all fields.
|    - For enum creations, unify the argument.
|    In the example above, we call unify(Foo[A], Foo[U64]) and unify(A, U64).
| 3. Call finish. This ensures that no type variables are unbound and it returns
|    a type environment (a Map[Str, Type]) that maps the generic type parameters
|    to concrete types. It can be used to specialize the generic code to the
|    usage site.
|    In the example above, the resulting type environment would be {A: U64}.

struct TypeSolver {
  vars: Set[Slice[U8]],
  env: Map[Slice[U8], Type],
}

fun create_type_solver[Iter](vars_: Iter): TypeSolver {
  | TODO: make sure each type var only exists once
  var vars = set[Slice[U8]]()
  for var_ in vars_ do vars.&.put(var_)
  TypeSolver { vars, env = map[Slice[U8], Type]() }
}
| Calling this function adds the constraint that `concrete` needs to be
| assignable to `generic`. Returns whether that works.
fun unify(solver: &TypeSolver, generic: Type, concrete: Type): Result[Bool, Slice[U8]] {
  | Under type env {A: Int}, is Str assignable to A? Depends on whether Str is
  | assignable to Int.
  if solver.env.get(generic.name) is some(mapped) then {
    if generic.args.is_not_empty()
    then return error[Bool, Slice[U8]]("Generics can't have type arguments.")
    if solver.vars.contains(mapped.name) then unreachable()
    return solver.unify(mapped, concrete)
  }

  if solver.vars.contains(generic.name) then {
    solver.env.&.put(generic.name, concrete)
    return ok[Bool, Slice[U8]](true())
  }

  if generic.name.not_equals(concrete.name) then return ok[Bool, Slice[U8]](false())
  if generic.args.len.not_equals(concrete.args.len) then return ok[Bool, Slice[U8]](false())
  for i in 0.to(generic.args.len) do
    if not(solver.unify(generic.args.get(i), concrete.args.get(i))?)
    then return ok[Bool, Slice[U8]](false())

  ok[Bool, Slice[U8]](true())
}
fun finish(solver: TypeSolver): Result[Map[Slice[U8], Type], Slice[U8]] {
  for var_ in solver.vars do
    if not(solver.env.contains(var_)) then
      return error[Map[Slice[U8], Type], Slice[U8]]({
        var out = vec[U8]().&
        if solver.env.size.is_greater_than(0) then {
          out.write_str("These type variables are bound:")
          out.write_char(newline())
          for entry in solver.env do {
            out.write_str("- ")
            out.write_str(entry.key)
            out.write_str(" = ")
            out.write(entry.value)
            out.write_char(newline())
          }
        }
        out.write_str("The type variable ")
        out.write_str(var_)
        out.write_str(" is unbound.")
        out.write_char(newline())
        out.to_slice()
      })

  ok[Map[Slice[U8], Type], Slice[U8]](solver.env)
}

| Monomorphization  
| A rough sketch on how this compiler stage works: The AST functions are
| compiled into monomorphized functions, starting from the main function. The
| Mono contains all compiled functions and types, corresponding to code and type
| definitions that actually need to be generated later on.
|
| Generic functions can be compiled multiple times with multiple type arguments.
| For example, take this code:
|
| struct Foo[T] { inner: T }
| fun wrap_in_foo[T](val: T) { Foo { inner = val } }
| fun main(): U8 {
|   var foo = wrap_in_foo(wrap_in_foo(2_U8))
|   0_U8
| }
|
| The following types and functions are monomorphized:
|
| - main[]()
|   - wrap_in_foo[U8]()
|     - Foo[U8]
|   - wrap_in_foo[Foo[U8]]()
|     - Foo[Foo[U8]]
|
| Recursive functions  
| We want to allow recursive functions without the compiler itself getting
| into an infinitely recursing state. That's why even before a function is
| compiled, a mock-version of it is added to the function map. When this
| function is encountered recursively, only its signature is needed to figure
| out how to use it.

fun monomorphize(ast: Ast): Result[Mono, Slice[U8]] {
  | TODO: constructor
  var context = Context { signatures = vec[Slice[U8]]() }
  var mono = Mono {
    type_defs = map[Type, MonoTypeDef](),
    globals = map[Slice[U8], MonoFun](),
    globals_init_order = vec[Slice[U8]](),
    funs = map[Slice[U8], MonoFun](),
  }
  type("Never").monomorphize(map[Slice[U8], Type](), ast, mono.&)
  type("Nothing").monomorphize(map[Slice[U8], Type](), ast, mono.&)
  for config in all_int_configs() do
    mono.type_defs.&.put(config.to_type(), MonoTypeDef.builtin_type)

  var main =
    switch ast.lookup_fun("main",
      none[Vec[Type]](), vec(type("Slice", vec(type("Str")))))
    case ok(main_with_args) main_with_args.fun_
    case error(error) {
      switch ast.lookup_fun("main", none[Vec[Type]](), vec[Type]())
      case error return error[Mono, Slice[U8]](
        "Your project must have one of these functions: main(Slice[Str]) or main()")
      | Generate a main(Slice[Str]) function that just calls main()
      case ok AstFun {
        name = "main",
        type_args = vec[Slice[U8]](),
        args = vec(
          AstFunArg { name = "args", type = type("Slice", vec(type("Str"))) },
        ),
        returns = type("Never"),
        is_builtin = false(),
        body = vec(AstExpr.name("main").call()),
      }
    }

  var main_signature =
    switch main.monomorphize(map[Slice[U8], Type](), context.&, ast, mono.&)
    case ok(signature) signature
    case error(error) return error[Mono, Slice[U8]]({
      var out = vec[U8]().&
      out.write_str("Error when compiling")
      out.write_char(newline())
      out.write_stack_trace(context)
      out.write_char(newline())
      out.write_str(error)
      out.to_slice()
    })

  var return_type = mono.funs.get(main_signature).unwrap().return_type
  if not(return_type.is_never())
  then return error[Mono, Slice[U8]]({
    var out = vec[U8]().&
    out.write_str("The main function should return Never, but it returns ")
    out.write(return_type)
    out.write_str(". You can call exit(U8) if you want the program to stop.")
    out.write_char(newline())
    out.to_slice()
  })

  ok[Mono, Slice[U8]](mono)
}

fun name(def: AstDef): Slice[U8] {
  switch def
  case builtin_type(name) name
  case struct_(struct_) struct_.name
  case enum_(enum_) enum_.name
  case var_(var_) var_.name
  case fun_(fun_) fun_.name
}

| Looks up the type with the given name. Type names have to be unique.
fun lookup_type(ast: Ast, name: Slice[U8]): Result[AstDef, Slice[U8]] {
  var matches = vec[AstDef]()
  for def in ast.defs do
    if name.equals(def.name()) then matches.&.push(def)

  if matches.is_empty() then return error[AstDef, Slice[U8]]({
    var out = vec[U8]().&
    out.write_str("There is no type named ")
    out.write_char('") | to fix syntax highlighting: "'
    out.write_str(name)
    out.write_char('") | to fix syntax highlighting: "'
    out.write_str(".")
    out.to_slice()
  })
  if matches.len.is_greater_than(1) then return error[AstDef, Slice[U8]]({
    var out = vec[U8]().&
    out.write_str("There are multiple types named ")
    out.write_char('") | to fix syntax highlighting: "'
    out.write_str(name)
    out.write_char('") | to fix syntax highlighting: "'
    out.write_str(".")
    out.to_slice()
  })
  ok[AstDef, Slice[U8]](matches.get(0))
}

| Looks up the global variable with the given name. Names of global variables
| have to be unique.
fun lookup_global_var(ast: Ast, name: Slice[U8]): Maybe[AstVar] {
  var matches = vec[AstVar]()
  for def in ast.defs do
    if def is var_(var_) then
      if name.equals(var_.name) then matches.&.push(var_)

  if matches.is_empty() then return none[AstVar]()
  if matches.len.is_greater_than(1) then return none[AstVar]()
  some(matches.get(0))
}

| Looks up the function with the given name, the given number of type args
| (none means they are inferred) and the args of the given types.
struct LookupFunSolution { fun_: AstFun, type_env: Map[Slice[U8], Type] }
fun lookup_fun(
  ast: Ast, name: Slice[U8], type_args: Maybe[Vec[Type]], arg_types: Vec[Type]
): Result[LookupFunSolution, Slice[U8]] {
  var name_matches = vec[AstFun]()
  for def in ast.defs do
    if def is fun_(fun_) then
      if fun_.name.equals(name) then name_matches.&.push(fun_)

  var full_matches = vec[LookupFunSolution]()
  for fun_ in name_matches do {
    var solver = create_type_solver(fun_.type_args)
    if type_args is some(type_args_) then {
      if type_args_.len.not_equals(fun_.type_args.len) then continue
      for i in 0.to(type_args_.len) do
        solver.&.unify(type(fun_.type_args.get(i)), type_args_.get(i))?.assert()
    }
    if arg_types.len.not_equals(fun_.args.len) then continue
    var matches = true()
    for i in 0.to(arg_types.len) do
      if not(solver.&.unify(fun_.args.get(i).type, arg_types.get(i))?)
      then { matches = false() break }
    if not(matches) then continue
    var type_env = switch solver.finish()
      case ok(env) env
      case error(error) {
        var out = vec[U8]().&
        out.write_str("Found a function matching a call:")
        out.write_char(newline())
        out.write_str("   call: ")
        out.write_call_signature(name, type_args, arg_types)
        out.write_char(newline())
        out.write_str("  match: ")
        out.write_signature(AstDef.fun_(fun_))
        out.write_char(newline())
        out.write_char(newline())
        out.write_str("However, resolving the call doesn't work:")
        out.write_char(newline())
        out.write_str(error)
        return error[LookupFunSolution, Slice[U8]](out.to_slice())
      }
    full_matches.&.push(LookupFunSolution { fun_, type_env })
  }

  if full_matches.is_empty() then return error[LookupFunSolution, Slice[U8]]({
    var out = vec[U8]().&
    out.write_str("This call doesn't work:")
    out.write_char(newline())
    out.write_str("> ")
    out.write_call_signature(name, type_args, arg_types)
    out.write_char(newline())
    out.write_char(newline())
    if name_matches.is_empty()
    then {
      out.write_str("There are no definitions named ")
      out.write_char('") | to fix syntax highlighting: "'
      out.write_str(name)
      out.write_char('") | to fix syntax highlighting: "'
      out.write_str(".")
    }
    else {
      out.write_str("These definitions have the same name, but arguments don't match:")
      for match in name_matches do {
        out.write_char(newline())
        out.write_str("- ")
        out.write_signature(AstDef.fun_(match))
      }
    }
    out.to_slice()
  })
  if full_matches.len.is_greater_than(1) then return error[LookupFunSolution, Slice[U8]]({
    var out = vec[U8]().&
    out.write_str("This call doesn't work:")
    out.write_char(newline())
    out.write_str("> ")
    out.write_call_signature(name, type_args, arg_types)
    out.write_char(newline())
    out.write_char(newline())
    out.write_str("Multiple definitions match:")
    for match in full_matches do {
      out.write_char(newline())
      out.write_str("- ")
      var padded_signature = vec[U8]()
      padded_signature.&.write_signature(AstDef.fun_(match.fun_))
      loop {
        if padded_signature.len.is_at_least(30) then break
        padded_signature.&.push(' )
      }
      out.write_str(padded_signature.to_slice())
      if match.type_env.is_not_empty() then {
        out.write_str(" with ")
        for entry in match.type_env do {
          out.write_str(entry.key)
          out.write_str(" = ")
          out.write(entry.value)
        }
      }
    }
    out.to_slice()
  })
  ok[LookupFunSolution, Slice[U8]](full_matches.get(0))
}
fun write_call_signature[W](
  writer: W, name: Slice[U8], type_args: Maybe[Vec[Type]], arg_types: Vec[Type]
) {
  writer.write_str(name)
  if type_args is some(type_args_) then writer.write_type_args(type_args_)
  writer.write_char('()
  var first = true()
  for arg_type in arg_types do {
    if first then first = false() else writer.write_str(", ")
    writer.write(arg_type)
  }
  writer.write_char('))
}

| Monomorphizes a type, outputting all the required type defs into the mono. For
| example, monomorphizing Map[T, Bool] with {T: U64} results in Map[U64, Bool]
| and also creates all the required defs (Map[U64, Bool], MapBucket[U64, Bool],
| Slice[MapBucket[U64, Bool]], etc.)
fun monomorphize(
  type: Type, type_env: Map[Slice[U8], Type], ast: Ast, mono: &Mono
): Result[Type, Slice[U8]] {
  | TODO: Make sure generic types don't have parameters.
  var type = type_env.get(type.name) orelse {
    var args = vec[Type]()
    for arg in type.args do args.&.push(arg.monomorphize(type_env, ast, mono)?)
    Type { name = type.name, args }
  }

  if type.is_incomplete() then return ok[Type, Slice[U8]](type)

  if mono.type_defs.contains(type) then return ok[Type, Slice[U8]](type)
  | TODO: explain
  mono.type_defs.&.put(type, MonoTypeDef.builtin_type)

  switch ast.lookup_type(type.name)?
  case builtin_type {
    mono.type_defs.&.put(type, MonoTypeDef.builtin_type)
  }
  case struct_(struct_) {
    var inner_type_env = map[Slice[U8], Type]()
    if type.args.len.not_equals(struct_.type_args.len)
    then return error[Type, Slice[U8]]({
      var out = vec[U8]().&
      out.write_str("You tried to use a ")
      out.write(type)
      out.write_str(", but ")
      out.write_str(struct_.name)
      out.write_str(" takes ")
      out.write(struct_.type_args.len)
      out.write_str(" type arguments.")
      out.to_slice()
    })
    for i in 0.to(type.args.len) do
      inner_type_env.&.put(struct_.type_args.get(i), type.args.get(i))
    var fields = vec[MonoStructField]()
    for field in struct_.fields do
      fields.&.push(MonoStructField {
        name = field.name,
        type = field.type.monomorphize(inner_type_env, ast, mono)?,
      })
    mono.type_defs.&.put(type, MonoTypeDef.struct_(MonoStruct { fields }))
  }
  case enum_(enum_) {
    var inner_type_env = map[Slice[U8], Type]()
    if type.args.len.not_equals(enum_.type_args.len)
    then return error[Type, Slice[U8]]({
      var out = vec[U8]().&
      out.write_str("You tried to use a ")
      out.write(type)
      out.write_str(", but ")
      out.write_str(enum_.name)
      out.write_str(" takes ")
      out.write(enum_.type_args.len)
      out.write_str(" type arguments.")
      out.to_slice()
    })
    for i in 0.to(type.args.len) do
      inner_type_env.&.put(enum_.type_args.get(i), type.args.get(i))
    var variants = vec[MonoEnumVariant]()
    for variant in enum_.variants do
      variants.&.push(MonoEnumVariant {
        name = variant.name,
        type = variant.type.monomorphize(inner_type_env, ast, mono)?,
      })
    mono.type_defs.&.put(type, MonoTypeDef.enum_(MonoEnum { variants }))
  }
  case var_ unreachable()
  case fun_ unreachable()

  ok[Type, Slice[U8]](type)
}

| Monomorphizes a global variable (well, it can't have type arguments, so
| compiling would be the more appropriate term), outputting all the required
| type defs, other global variables, and functions into the mono.
fun monomorphize(
  global: AstVar, context: &Context, ast: Ast, mono: &Mono
): Result[Nothing, Slice[U8]] {
  if mono.globals.contains(global.name)
  then return ok[Nothing, Slice[U8]]({})

  context.push({
    var out = vec[U8]().&
    out.write_str("var ")
    out.write_str(global.name)
    out.write_str(" ()")
    out.to_slice()
  })

  var mono_fun = MonoFun {
    type_args = vec[Type](),
    arg_types = vec[Type](),
    return_type = type("_"),
    is_builtin = false(),
    slots = vec[MonoSlot](),
    body = vec[MonoStatement](),
  }

  var compile_fun = CompileFun {
    context,
    ast,
    mono,
    fun_ = mono_fun.&,
    type_env = map[Slice[U8], Type](),
    vars = vars[MonoSlotRef](),
    return_type = type_sink(),
    break_scopes = stack[BreakScope](),
    continue_scopes = stack[ContinueScope](),
  }

  var value = compile_fun.&.compile(global.value.*)?
  if compile_fun.return_type.&.add(value.type) is error(error)
    then return error[Nothing, Slice[U8]]({
      var out = vec[U8]().&
      out.write_str(
        "The value of the variable doesn't match its expected type.")
      out.write_char(newline())
      out.write_str(error)
      out.to_slice()
    })

  if not(value.type.is_never()) then
    mono_fun.body.&.push(MonoStatement.return_(value))
  mono_fun.return_type = compile_fun.return_type.finish()

  mono.globals.&.put(global.name, mono_fun)
  mono.globals_init_order.&.push(global.name)

  context.&.pop()
  ok[Nothing, Slice[U8]]({})
}

| Monomorphizes a function, outputting it into the mono. Returns the function
| signature. For example, monomorphizing foo[T](a: T) with {T: U64} would result
| in the function signature foo(U64) and create all required types and functions
| on the mono.
fun monomorphize(
  fun_: AstFun, type_env: Map[Slice[U8], Type],
  context: &Context, ast: Ast, mono: &Mono
): Result[Slice[U8], Slice[U8]] {
  var arg_types = vec[Type]() {
    for arg in fun_.args do
      arg_types.&.push(arg.type.monomorphize(type_env, ast, mono)?)
  }
  var type_args = vec[Type]()
  for arg in fun_.type_args do
    type_args.&.push(type(arg).monomorphize(type_env, ast, mono)?)
  var signature = {
    var out = vec[U8]().&
    out.write_str(fun_.name)
    out.write_type_args(type_args)
    out.write_char('()
    for i in 0.to(fun_.args.len) do {
      if i.is_greater_than(0) then out.write_str(", ")
      out.write(arg_types.get(i))
    }
    out.write_char('))
    out.to_slice()
  }
  if mono.funs.contains(signature)
  then return ok[Slice[U8], Slice[U8]](signature)
  context.&.push(signature)

  var return_type = fun_.returns.monomorphize(type_env, ast, mono)?

  var mono_fun = MonoFun {
    type_args,
    arg_types,
    return_type = return_type,
    is_builtin = fun_.is_builtin,
    slots = vec[MonoSlot](),
    body = vec[MonoStatement](),
  }
  var vars = vars[MonoSlotRef]() {
    for i in 0.to(fun_.args.len) do {
      var slot = MonoSlotRef { index = mono_fun.slots.len }
      mono_fun.slots.&.push(MonoSlot {
        type = arg_types.get(i),
        initial_value = MonoSlotValue.arg(i)
      })
      vars.&.define(fun_.args.get(i).name, slot)
    }
  }

  | TODO: explain
  mono.funs.&.put(signature, mono_fun)

  var compile_fun = CompileFun {
    context,
    ast,
    mono,
    fun_ = mono_fun.&,
    type_env,
    vars,
    return_type = type_sink(return_type),
    break_scopes = stack[BreakScope](),
    continue_scopes = stack[ContinueScope](),
  }
  var body_result = compile_fun.&.compile_body(fun_.body)?

  | For builtin functions, we trust the fully specified return type.
  | For user-written functions, we take the actual return type.
  if not(fun_.is_builtin) then {
    if compile_fun.return_type.&.add(body_result.type) is error(error)
    then return error[Slice[U8], Slice[U8]]({
      var out = vec[U8]().&
      out.write_str(
        "The last expression of the function body doesn't match the return type.")
      out.write_char(newline())
      out.write_str(error)
      out.to_slice()
    })
    if body_result.type.name.not_equals("Never") then
      mono_fun.body.&.push(MonoStatement.return_(body_result))
    mono_fun.return_type = compile_fun.return_type.finish()
  }

  mono.funs.&.put(signature, mono_fun)
  context.pop()

  ok[Slice[U8], Slice[U8]](signature)
}

struct CompileFun {
  context: &Context,
  ast: Ast,
  mono: &Mono,
  fun_: &MonoFun,
  type_env: Map[Slice[U8], Type], | maps fun type args to concrete types
  next_label: U64,
  vars: Vars[MonoSlotRef],
  return_type: TypeSink,
  | When lowering loops, breaks and continues don't know where to jump yet.
  | Instead, they fill these structures with jump addresses that need to be
  | adjusted later.
  break_scopes: Stack[BreakScope],
  continue_scopes: Stack[ContinueScope],
}
struct BreakScope {
  result: MonoSlotRef,
  type: Maybe[Type],
  breaks: Vec[U64],
}
struct ContinueScope { continues: Vec[U64] }

fun add_slot(
  self: &CompileFun, type: Type, initial_value: MonoSlotValue
): MonoSlotRef {
  var ref = MonoSlotRef { index = self.fun_.slots.len }
  self.fun_.slots.&.push(MonoSlot { type, initial_value })
  ref
}
fun add_slot(self: &CompileFun, type: Type): MonoSlotRef {
  self.add_slot(type, MonoSlotValue.uninitialized)
}
fun update_slot_type(self: &CompileFun, slot: MonoSlotRef, type: Type) {
  self.fun_.slots.get_ref(slot.index).type = type
}
fun slot_expr(self: CompileFun, slot: MonoSlotRef): MonoExpr {
  MonoExpr {
    kind = MonoExprKind.slot(slot),
    type = self.fun_.slots.get(slot.index).type,
  }
}
fun nothing_expr(): MonoExpr {
  MonoExpr { kind = MonoExprKind.nothing, type = type("Nothing") }
}
fun never_expr(): MonoExpr {
  MonoExpr { kind = MonoExprKind.never, type = type("Never") }
}
fun put(self: &CompileFun, statement: MonoStatement): U64 {
  var index = self.fun_.body.len
  self.fun_.body.&.push(statement)
  index
}
fun put_label(self: &CompileFun): MonoLabel {
  var label = MonoLabel { id = self.next_label }
  self.next_label = self.next_label.inc()
  self.put(MonoStatement.label(label))
  label
}
fun put_placeholder(self: &CompileFun): U64 {
  self.put(MonoStatement.label(MonoLabel { id = 0 }))
}
fun update(self: &CompileFun, index: U64, statement: MonoStatement) {
  self.fun_.body.get_ref(index).* = statement
}

| Most expressions are compiled in a separate variable scope. For example, this
| shouldn't work:
|
| foo(var a = 3, a)
|
| Only the body expression compiles child expressions in a common scope:
|
| {
|   var a = a
|   var b = a  | works
| }
fun compile(self: &CompileFun, expr: AstExpr): Result[MonoExpr, Slice[U8]] {
  var scope = self.vars.snapshot()
  var mono = self.compile_in_current_scope(expr)
  self.vars.&.restore(scope)
  mono
}
fun compile_body(
  self: &CompileFun, body: Vec[AstExpr]
): Result[MonoExpr, Slice[U8]] {
  var scope = self.vars.snapshot()
  var last = none[MonoExpr]()
  for expr in body do last = some(self.compile_in_current_scope(expr)?)
  self.vars.&.restore(scope)
  ok[MonoExpr, Slice[U8]](last orelse nothing_expr())
}
fun compile_in_current_scope(
  self: &CompileFun, expr: AstExpr
): Result[MonoExpr, Slice[U8]] {
  ok[MonoExpr,Slice[U8]](
    switch expr
    case int(int) self.slot_expr(self.add_slot(
      int.config.to_type(),
      MonoSlotValue.int(int.value),
    ))
    case str(str) {
      type("Str").monomorphize(map[Slice[U8], Type](), self.ast, self.mono)?
      self.slot_expr(self.add_slot(type("Str"), MonoSlotValue.str(str)))
    }
    case name(name) {
      switch self.vars.lookup(name)
      case some(slot) self.slot_expr(slot)
      case none {
        switch self.ast.lookup_global_var(name)
        case some(global) {
          global.monomorphize(self.context, self.ast, self.mono)?
          var type = self.mono.globals.get(name).unwrap().return_type
          MonoExpr {
            kind = MonoExprKind.global(name),
            type,
          }
        }
        case none {
          return error[MonoExpr, Slice[U8]]({
            | TODO: print which variables are in scope
            var out = vec[U8]().&
            out.write_char('") | to fix syntax highlighting: "'
            out.write_str(name)
            out.write_char('") | to fix syntax highlighting: "'
            out.write_str(" is not in scope.")
            out.to_slice()
          })
        }
      }
    }
    case call(call) {
      var callee = none[MonoExpr]()
      var name =
        switch call.callee.*
        | foo(a, b)
        case name(name) name
        | a.foo(b)
        case member(member) {
          callee = some(self.compile(member.of.*)?)
          member.name
        }
        default return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("You tried to call this expression:")
          out.write_char(newline())
          out.write_str("> ")
          out.write(2, call.callee.*)
          out.write_char(newline())
          out.write_str("This expression can't be called.")
          out.to_slice()
        })
      var type_args =
        switch call.type_args
        case some(type_args) {
          var mono_type_args = vec[Type]()
          for arg in type_args do
            mono_type_args.&.push(
              arg.monomorphize(self.type_env, self.ast, self.mono)?)
          some(mono_type_args)
        }
        case none none[Vec[Type]]()
      var args = vec[MonoExpr]() {
        for arg in call.args do args.&.push(self.compile(arg)?)
      }
      self.compile_call(name, callee, type_args, args)?
    }
    case make_struct(make_struct) {
      var struct_ =
        switch self.ast.lookup_type(make_struct.type.name)?
        case struct_(s) s
        default return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("Tried to create a struct, but ")
          out.write_str(make_struct.type.name)
          out.write_str(" is not a struct type.")
          out.to_slice()
        })
      var fields = map[Slice[U8], MonoExpr]() {
        for field in make_struct.fields do
          fields.&.put(field.name, self.compile(field.value)?)
      }
      for field in struct_.fields do
        if not(fields.contains(field.name))
        then return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("You tried to create a ")
          out.write_str(make_struct.type.name)
          out.write_str(", but the ")
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(field.name)
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(" field is missing.")
          out.to_slice()
        })

      var solver = create_type_solver(struct_.type_args)
      | TODO: Foo[] { ... } should not be treated like Foo { ... }
      if make_struct.type.args.is_not_empty() then {
        if make_struct.type.args.len.not_equals(struct_.type_args.len)
        then return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("Tried to create struct ")
          out.write(struct_.name)
          out.write_str(" with ")
          out.write(make_struct.type.args.len)
          out.write_str(" type arguments, but it needs ")
          out.write(struct_.type_args.len)
          out.write_str(".")
          out.to_slice()
        })
        for i in 0.to(struct_.type_args.len) do
          if not(solver.&.unify(
            type(struct_.type_args.get(i)),
            make_struct.type.args.get(i)
              .monomorphize(self.type_env, self.ast, self.mono)?
          )?)
          then unreachable()
      }
      for field in fields do {
        var name = field.key
        var value = field.value
        var type_in_struct = none[Type]()
        for f in struct_.fields do
          if f.name.equals(name) then
            type_in_struct = some(f.type)

        if type_in_struct is none then return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("Tried to initialize field ")
          out.write_str(name)
          out.write_str(" of ")
          out.write_str(struct_.name)
          out.write_str(", but it doesn't have that.")
          out.to_slice()
        })
        var type_in_struct = type_in_struct.unwrap()
        if not(solver.&.unify(type_in_struct, value.type)?)
        then return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("Tried to assign ")
          out.write(value.type)
          out.write_str(" to field ")
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(name)
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(" of type ")
          out.write(type_in_struct)
          out.write_str(".")
          out.to_slice()
        })
      }
      var type_env = solver.finish()?

      var unspecialized_type = make_struct.type
      if make_struct.type.args.is_empty().and(struct_.type_args.is_not_empty())
      then for arg in struct_.type_args do
        unspecialized_type.args.&.push(
          type(arg).monomorphize(type_env, self.ast, self.mono)?)
      var type = unspecialized_type.monomorphize(self.type_env, self.ast, self.mono)?

      var slot = self.slot_expr(self.add_slot(type))
      for field in fields do {
        self.put(MonoStatement.assign(MonoAssign {
          to = MonoExpr {
            kind = MonoExprKind.member(MonoMember {
              of = slot.put_on_heap(),
              name = field.key,
            }),
            type = field.value.type,
          },
          value = field.value,
        }))
      }
      slot
    }
    case make_enum(make_enum) {
      var enum_ =
        switch self.ast.lookup_type(make_enum.type.name)?
        case enum_(e) e
        default return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("Tried to create an enum, but ")
          out.write_str(make_enum.type.name)
          out.write_str(" is not an enum type.")
          out.to_slice()
        })
      var arg = self.compile(make_enum.arg.*)?
      var variant_type = {
        var type = none[Type]()
        for variant in enum_.variants do
          if variant.name.equals(make_enum.variant)
          then type = some(variant.type)
        type orelse return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("Unknown variant ")
          out.write_str(make_enum.type.name)
          out.write_str(".")
          out.write_str(make_enum.variant)
          out.write_str(".")
          out.to_slice()
        })
      }

      var solver = create_type_solver(enum_.type_args)
      | TODO: Maybe[].some(3) should not be treated like Maybe.some(3)
      if make_enum.type.args.is_not_empty() then {
        if make_enum.type.args.len.not_equals(enum_.type_args.len)
        then return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("Tried to create enum ")
          out.write_str(enum_.name)
          out.write_str(" with ")
          out.write(make_enum.type.args.len)
          out.write_str(" type arguments, but it needs ")
          out.write(enum_.type_args.len)
          out.write_str(".")
          out.to_slice()
        })
        for i in 0.to(enum_.type_args.len) do {
          if not(solver.&.unify(
            type(enum_.type_args.get(i)),
            make_enum.type.args.get(i)
              .monomorphize(self.type_env, self.ast, self.mono)?
          )?)
          then unreachable()
        }
      }
      if not(solver.&.unify(variant_type, arg.type)?)
      then return error[MonoExpr, Slice[U8]]({
        var out = vec[U8]().&
        out.write_str("Tried to create ")
        out.write_str(make_enum.type.name)
        out.write_str(".")
        out.write_str(make_enum.variant)
        out.write_str(" with ")
        out.write(arg.type)
        out.write_str(", but it needs a ")
        out.write(variant_type)
        out.write_str(".")
        out.to_slice()
      })
      var type_env = solver.finish()?

      var unspecialized_type = make_enum.type
      if make_enum.type.args.is_empty().and(enum_.type_args.is_not_empty())
      then for a in enum_.type_args do
        unspecialized_type.args.&.push(
          type(a).monomorphize(type_env, self.ast, self.mono)?)
      var type = unspecialized_type.monomorphize(self.type_env, self.ast, self.mono)?

      var slot = self.add_slot(type)
      self.put(MonoStatement.set_enum(MonoSetEnum {
        slot,
        variant = make_enum.variant,
        value = arg,
      }))
      self.slot_expr(slot)
    }
    case member(member) {
      var of = self.compile(member.of.*)?
      | expr.& references the of
      if member.name.equals("&")
      then {
        var ref_type = type("&", vec(of.type))
          .monomorphize(self.type_env, self.ast, self.mono)?
        var slot = self.add_slot(ref_type)
        self.put(MonoStatement.ref(MonoRef { to = slot, of }))
        return ok[MonoExpr,Slice[U8]](self.slot_expr(slot))
      }
      | When accessing a member on a reference, we automatically dereference the
      | receiver as often as necessary. For example, you can access point.x if
      | point is a &&&Point.
      loop
        if of.type.name.equals("&").and(member.name.not_equals("*"))
        then of = MonoExpr {
          kind = MonoExprKind.member(MonoMember {
            of = of.put_on_heap(),
            name = "*",
          }),
          type = of.type.args.get(0),
        }
        else break
      var struct_ =
        switch self.mono.type_defs.get(of.type).unwrap()
        case struct_(s) s
        default return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("You tried to access a field on ")
          out.write(of.type)
          out.write_str(", but it's not a struct.")
          out.write_char(newline())
          out.write_str(
            switch self.mono.type_defs.get(of.type).unwrap()
            case builtin_type "builtin"
            case struct_ "struct"
            case enum_ "enum"
          )
          out.to_slice()
        })
      var type = {
        var field_type = none[Type]()
        for field in struct_.fields do
          if field.name.equals(member.name) then field_type = some(field.type)
        field_type orelse return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(member.name)
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(" is not a field on ")
          out.write(of.type)
          out.write_str(".")
          out.write_char(newline())
          out.write_str("It only contains these fields:")
          for field in struct_.fields do {
            out.write_char(newline())
            out.write_str("- ")
            out.write_str(field.name)
          }
          out.to_slice()
        })
      }
      
      MonoExpr {
        kind = MonoExprKind.member(MonoMember {
          of = of.put_on_heap(),
          name = member.name,
        }),
        type,
      }
    }
    case var_(var_) {
      var value = self.compile(var_.value.*)?
      var slot = self.add_slot(value.type)
      self.put(MonoStatement.assign(MonoAssign {
        to = self.slot_expr(slot),
        value,
      }))
      self.vars.&.define(var_.name, slot)
      nothing_expr()
    }
    case assign(assign) {
      var to = self.compile(assign.to.*)?
      var value = self.compile(assign.value.*)?
      if not(value.type.equals(to.type))
      then return error[MonoExpr, Slice[U8]]({
        var out = vec[U8]().&
        out.write_str("Tried to assign ")
        out.write(value.type)
        out.write_str(" to a variable of type ")
        out.write(to.type)
        out.write_str(".")
        out.to_slice()
      })
      self.put(MonoStatement.assign(MonoAssign { to, value }))
      nothing_expr()
    }
    | Switch  
    | Switches are lowered to a jump table. Here's an example of a switch and
    | how it will be compiled:
    |
    | switch value
    | case foo foo
    | case bar(bar) bar
    | default baz
    |
    | _0: Result <- the result slot
    | _1: Bar <- slot for bar binding
    | ...
    | jump_if_variant value foo label_0 ──┐
    | jump_if_variant value bar label_1 ──┼─┐
    | jump label_2  ──────────────────────┼─┼─┐
    | label_0: <──────────────────────────┘ │ │
    | _0 = foo                              │ │
    | jump label_3 ─────────────────>┐      │ │
    | label_1: <─────────────────────┼──────┘ │
    | _1 = get_enum_value value bar  │        │
    | _0 = bar                       │        │
    | jump label_3 ─────────────────>┤        │
    | label_2: <─────────────────────┼────────┘
    | _0 = baz                       │
    | jump label_3 ─────────────────>┤
    | label_3: <─────────────────────┘
    | ...
    case switch_(switch_) {
      var result = self.add_slot(type(""))
      var type = none[Type]()

      var value = self.compile(switch_.value.*)?
      var enum_ =
        switch self.mono.type_defs.get(value.type).unwrap()
        case enum_(e) e
        default return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("You tried to switch on ")
          out.write(value.type)
          out.write_str(", but you can only switch on enums.")
          out.to_slice()
        })

      | Ensure all cases refer to enum variants and all variants are handled
      | exactly once.
      var handled = set[Slice[U8]]()
      for case_ in switch_.cases do {
        if handled.contains(case_.variant)
        then return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("When switching on ")
          out.write(value.type)
          out.write_str(", you handle the ")
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(case_.variant)
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(" variant multiple times.")
          out.to_slice()
        })
        | TODO: when supporting continue with label, use that
        var handled_this_case = false()
        for variant in enum_.variants do
          if variant.name.equals(case_.variant) then {
            handled.&.put(case_.variant)
            handled_this_case = true()
          }
        if handled_this_case then continue
        return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("You switched on ")
          out.write(value.type)
          out.write_str(", which doesn't have a ")
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(case_.variant)
          out.write_char('") | to fix syntax highlighting: "'
          out.write_str(" variant.")
          out.write_char(newline())
          out.write_str("It only has these variants:")
          for variant in enum_.variants do {
            out.write_char(newline())
            out.write_str("- ")
            out.write_str(variant.name)
          }
          out.to_slice()
        })
      }
      if switch_.default_ is none then
        for variant in enum_.variants do
          if not(handled.contains(variant.name))
          then return error[MonoExpr, Slice[U8]]({
            out.write_str("You switched on ")
            out.write(value.type)
            out.write_str(", but you don't handle the ")
            out.write_char('") | to fix syntax highlighting: "'
            out.write_str(variant.name)
            out.write_char('") | to fix syntax highlighting: "'
            out.write_str(" variant.")
            out.to_slice()
          })

      var jump_table_jumps = map[Slice[U8], U64]()
      for case_ in switch_.cases do
        jump_table_jumps.&.put(case_.variant, self.put_placeholder())
      var default_jump =
        switch switch_.default_
        case some some(self.put_placeholder())
        case none none[U64]()
      | contains indices of statements which will be replaced with unconditional
      | jumps to after the switch
      var after_switch_jumps = vec[U64]()

      | Case bodies
      for case_ in switch_.cases do {
        var label = self.put_label()
        self.update(
          jump_table_jumps.get(case_.variant).unwrap(),
          MonoStatement.jump_if_variant(MonoJumpIfVariant {
            condition = value,
            variant = case_.variant,
            target = label,
          })
        )
        var variant_type = {
          var variant_type = none[Type]()
          for variant in enum_.variants do
            if variant.name.equals(case_.variant) then
              variant_type = some(variant.type)
          variant_type.unwrap()
        }
        var unpacked = self.add_slot(variant_type)
        self.put(MonoStatement.get_enum_value(MonoGetEnumValue {
          to = unpacked,
          of = value,
          variant = case_.variant,
        }))
        var scope = self.vars.snapshot()
        if case_.binding is some(binding) then
          self.vars.&.define(binding, unpacked)
        var then_ = self.compile(case_.then_.*)?
        self.vars.&.restore(scope)

        if not(then_.type.is_never()) then {
          switch type
          case none type = some(then_.type)
          case some(expected)
            if then_.type.not_equals(expected) then
              return error[MonoExpr, Slice[U8]]({
                var out = vec[U8]().&
                out.write_str("When lowering this:")
                out.write_char(newline())
                out.write(0, AstExpr.switch_(switch_))
                out.write_char(newline())
                out.write_str("Previous switch cases return ")
                out.write(expected)
                out.write_str(", but the case for ")
                out.write_char('") | to fix syntax highlighting: "'
                out.write_str(case_.variant)
                out.write_char('") | to fix syntax highlighting: "'
                out.write_str(" returns ")
                out.write(then_.type)
                out.write_str(".")
                out.to_slice()
              })
          self.put(MonoStatement.assign(MonoAssign {
            to = self.slot_expr(result),
            value = then_,
          })).ignore()
        }
        after_switch_jumps.&.push(self.put_placeholder())
      }

      | Default case
      if switch_.default_ is some(default_) then {
        var label = self.put_label()
        self.update(default_jump.unwrap(), MonoStatement.jump(MonoJump {
          target = label
        }))
        var default_result = self.compile(default_.*)?
        if not(default_result.type.is_never()) then {
            type = some(default_result.type)
            self.put(MonoStatement.assign(MonoAssign {
                to = self.slot_expr(result),
                value = default_result,
            })).ignore()
        }
        after_switch_jumps.&.push(self.put_placeholder())
      }

      var after_switch = self.put_label()
      for jump in after_switch_jumps do
        self.update(jump,
          MonoStatement.jump(MonoJump { target = after_switch }))

      self.update_slot_type(result, type orelse type("Never"))
      self.slot_expr(result)
    }
    | Loop  
    | Loops are lowered to two labels – one before and one after the loop.
    | Breaks, continues, and the loop itself each compile to a single jump to
    | one of those labels. Here's an example of a loop and how it will be
    | compiled:
    |
    | loop {
    |   ...
    |   continue
    |   ...
    |   break(5)
    | }
    |
    | _0: Result <- the result slot
    | ...
    | label_0: <────────┐
    | ...               │
    | jump label_0 ────>┤
    | ...               │
    | jump label_1 ──┐  │
    | ...            │  │
    | jump label_0 ──┼─>┘
    | label_1: <─────┘
    | ...
    case loop_(expr) {
      var result = self.add_slot(type(""))
      self.break_scopes.&.push(BreakScope {
        | TODO: turn this into an expr
        result,
        type = none[Type](),
        breaks = vec[U64](),
      })
      | TODO: save the loop start instead
      self.continue_scopes.&.push(ContinueScope { continues = vec[U64]() })

      var loop_start = self.put_label()
      self.compile(expr.*)?
      self.put(MonoStatement.jump(MonoJump { target = loop_start }))

      var after_loop = self.put_label()
      var scope = self.break_scopes.&.pop() {
        for break_ in scope.breaks do
          self.update(
            break_,
            MonoStatement.jump(MonoJump { target = after_loop }),
          )
      }
      self.update_slot_type(result, scope.type orelse type("Never"))
      var scope = self.continue_scopes.&.pop() {
        for continue_ in scope.continues do
          self.update(
            continue_,
            MonoStatement.jump(MonoJump { target = loop_start }),
          )
      }
      self.slot_expr(result)
    }
    case break_(arg) {
      if self.break_scopes.is_empty() then return error[MonoExpr, Slice[U8]](
        "There's a break outside out a loop.")
      var scope = self.break_scopes.top_ref()

      var arg = self.compile(arg.*)?

      if scope.type is some(expected) then
        if arg.type.not_equals(expected) then
          return error[MonoExpr, Slice[U8]]({
            var out = vec[U8]().&
            out.write_str("A previous break returned ")
            out.write(expected)
            out.write_str(", but this break returns ")
            out.write(arg.type)
            out.write_str(".")
            out.to_slice()
          })
      scope.type = some(arg.type)
      self.put(MonoStatement.assign(MonoAssign {
        | TODO: This is not correct. The type of the slot is only updated after
        | the loop body is fully lowered. The created slot expr still has the
        | wrong type.
        to = self.slot_expr(scope.result),
        value = arg,
      }))

      scope.breaks.&.push(self.put_placeholder())
      never_expr()
    }
    case continue_ {
      if self.continue_scopes.is_empty() then return error[MonoExpr, Slice[U8]](
        "There's a continue outside out a loop.")
      var scope = self.continue_scopes.top_ref()
      scope.continues.&.push(var jump = self.put_placeholder())
      never_expr()
    }
    case return_(arg) {
      var arg = self.compile(arg.*)?
      if self.return_type.&.add(arg.type) is error(error)
      then return error[MonoExpr, Slice[U8]]({
        var out = vec[U8]().&
        out.write_str(
          "The type of a return doesn't match the return type up to this point:"
        )
        out.write_char(newline())
        out.write_str(error)
        out.to_slice()
      })
      self.put(MonoStatement.return_(arg))
      never_expr()
    }
    case try(expr) {
      var expr = self.compile(expr.*)?
      if expr.type.name.not_equals("Result")
      then return error[MonoExpr, Slice[U8]](
        "The try operator ? can only be used on Results.")
      var return_type = self.return_type.finish()
      if return_type.name.not_equals("Result")
      then return error[MonoExpr, Slice[U8]](
        "The try operator ? can only be used in functions that return Result.")
      if expr.type.args.get(1).not_equals(return_type.args.get(1)) then
        return error[MonoExpr, Slice[U8]]({
          var out = vec[U8]().&
          out.write_str("You used ? on a Result where the error type doesn't match the error type of the function.")
          out.write_char(newline())
          out.write_char(newline())
          out.write_str("    type of value: Result[..., ")
          out.write(expr.type.args.get(1))
          out.write_str("]")
          out.write_char(newline())
          out.write_str(" type of function: Result[..., ")
          out.write(return_type.args.get(1))
          out.write_str("]")
          out.to_slice()
        })

      var ok_type = expr.type.args.get(0)
      var error_type = expr.type.args.get(1)

      var jump_if_ok = self.put_placeholder()
      var error_payload = self.add_slot(error_type)
      self.put(MonoStatement.get_enum_value(MonoGetEnumValue {
        to = error_payload,
        of = expr,
        variant = "error",
      }))
      var error_to_return = self.add_slot(return_type)
      self.put(MonoStatement.set_enum(MonoSetEnum {
        slot = error_to_return,
        variant = "error",
        value = self.slot_expr(error_payload),
      }))
      self.put(MonoStatement.return_(self.slot_expr(error_to_return)))

      var after_error_handling = self.put_label()
      self.update(jump_if_ok, MonoStatement.jump_if_variant(MonoJumpIfVariant {
        condition = expr,
        variant = "ok",
        target = after_error_handling,
      }))

      var ok_payload = self.add_slot(ok_type)
      self.put(MonoStatement.get_enum_value(MonoGetEnumValue {
        to = ok_payload,
        of = expr,
        variant = "ok",
      }))
      self.slot_expr(ok_payload)
    }
    case body(body) self.compile_body(body)?
  )
}

fun compile_call(
  self: &CompileFun,
  name: Slice[U8],
  callee: Maybe[MonoExpr],
  type_args: Maybe[Vec[Type]],
  explicit_args: Vec[MonoExpr],
): Result[MonoExpr, Slice[U8]] {
  | Martinaise supports auto-dereferencing: If you call value.foo() on a value
  | of type &T, we first look for functions matching foo(&T). If none match, we
  | try dereferencing the value and look for functions matching foo(T). If we
  | find one, your code acts as if it was value.*.foo().
  var first_error = none[Slice[U8]]()
  loop {
    var args = vec[MonoExpr]()
    var arg_types = vec[Type]()
    if callee is some(c) then {
      args.&.push(c)
      arg_types.&.push(c.type)
    }
    for arg in explicit_args do {
      args.&.push(arg)
      arg_types.&.push(arg.type)
    }

    switch self.ast.lookup_fun(name, type_args, arg_types)
    case error(error) {
      if first_error is none then first_error = some(error)
      if callee is some(c) then if c.type.name.equals("&") then {
        | Dereference the callee
        callee = some(MonoExpr {
          kind = MonoExprKind.member(MonoMember {
            of = c.put_on_heap(),
            name = "*"
          }),
          type = c.type.args.get(0),
        })
        continue
      }
      return error[MonoExpr, Slice[U8]](first_error.unwrap())
    }
    case ok(solution) {
      var fun_ = solution.fun_.monomorphize(
        solution.type_env,
        self.context, self.ast, self.mono
      )?
      var result = self.add_slot(self.mono.funs.get(fun_).unwrap().return_type)
      self.put(MonoStatement.call(MonoCall { to = result, fun_, args }))
      return ok[MonoExpr, Slice[U8]](self.slot_expr(result))
    }
  }
}

| C Backend  
| Martinaise lowers the code to (unreadable) C code.
| TODO: why C?
| TODO: what standard?

fun mangle(name: Slice[U8]): Slice[U8] {
    var mangled = vec[U8]().&
    mangled.write_str("mar_")
    for c in name do {
      if c.equals('_) then { mangled.write_str("__") continue }
      if c.equals('[) then { mangled.write_str("_of_") continue }
      if c.equals(']) then { mangled.write_str("_end_") continue }
      if c.equals('() then { mangled.write_str("_withargs_") continue }
      if c.equals(')) then { mangled.write_str("_end_") continue }
      if c.equals(',) then { mangled.write_str("_and_") continue }
      if c.equals('&) then { mangled.write_str("_refto_") continue }
      if c.equals('*) then { mangled.write_str("_star_") continue }
      if c.equals(' ) then continue
      mangled.write_char(c)
    }
    mangled.to_slice()
}

fun mangle(type: Type): Slice[U8] {
  | TODO: add to_string to stdlib
  var formatted = vec[U8]()
  formatted.&.write(type)
  formatted.to_slice().mangle()
}

fun sort_types_for_c(types: Map[Type, MonoTypeDef]): Vec[Type] {
  var sorted = vec[Type]()
  var reached = set[Type]()
  for def in types do
    def.key.sort_types_for_c(types, sorted.&, reached.&)
  sorted
}
fun sort_types_for_c(
  type: Type, defs: Map[Type, MonoTypeDef],
  out: &Vec[Type], reached: &Set[Type]
) {
  if reached.contains(type) then return {}
  if type.name.equals("&") then {
    out.push(type)
    reached.put(type)
    return {}
  }
  switch defs.get(type).unwrap()
  case builtin_type {
    out.push(type)
    reached.put(type)
  }
  case struct_(struct_) {
    for field in struct_.fields do
      field.type.sort_types_for_c(defs, out, reached)
    out.push(type)
    reached.put(type)
  }
  case enum_(enum_) {
    for variant in enum_.variants do
      variant.type.sort_types_for_c(defs, out, reached)
    out.push(type)
    reached.put(type)
  }
}

fun write_expr_as_c[W](writer: W, expr: MonoExpr) {
  switch expr.kind
  case nothing writer.write_str("_nothing")
  case never writer.write_str("_never")
  case global(name) {
    writer.write_str("global_")
    writer.write_str(name)
  }
  case slot(slot) writer.write(slot)
  case member(member)
    if member.name.equals("*") then {
      writer.write_str("(*")
      writer.write_expr_as_c(member.of.*)
      writer.write_str(".pointer)")
    } else {
      writer.write_expr_as_c(member.of.*)
      writer.write_str(".")
      writer.write_str(member.name.mangle())
    }
}

fun compile_to_c(mono: Mono): Slice[U8] {
  var out = vec[U8]().&

  out.write_str("// This file is a compiler target.")
  out.write_char(newline())
  out.write_str("#include <unistd.h>")
  out.write_char(newline())
  out.write_str("#include <stdint.h>")
  out.write_char(newline())
  out.write_str("#include <stdlib.h>")
  out.write_char(newline())
  out.write_str("#include <fcntl.h>")
  out.write_char(newline())
  out.write_char(newline())

  var builtin_types = map[Type, Slice[U8]]()
  var builtin_funs = map[Slice[U8], Slice[U8]]()
  { | libc_malloc(size: U64): U64
    var code = vec[U8]().&
    code.write_str("  mar_U64 address;")
    code.write_str("  address.value = (uint64_t) malloc(arg0.value);")
    code.write_str("  return address;")
    builtin_funs.&.put("libc_malloc(U64)", code.to_slice())
  }
  { | libc_exit(status: U8): Never
    var code = vec[U8]().&
    code.write_str("  exit(arg0.value);")
    code.write_str("  mar_Nothing nothing;")
    code.write_str("  return nothing;")
    builtin_funs.&.put("libc_exit(U8)", code.to_slice())
  }
  { | libc_open(filename: U64, flags: U64, mode: U64): U64
    var code = vec[U8]().&
    code.write_str("  mar_U64 fd;")
    code.write_str("  fd.value = (uint64_t) open((char*) arg0.value, arg1.value, arg2.value);")
    code.write_str("  return fd;")
    builtin_funs.&.put("libc_open(U64, U64, U64)", code.to_slice())
  }
  { | libc_read(file: U64, buf: U64, len: U64): U8
    var code = vec[U8]().&
    code.write_str("  mar_U64 result;")
    code.write_str("  result.value = read(arg0.value, (void*) arg1.value, arg2.value);")
    code.write_str("  return result;")
    builtin_funs.&.put("libc_read(U64, U64, U64)", code.to_slice())
  }
  { | libc_write(file: U64, buf: U64, len: U64): U8
    var code = vec[U8]().&
    code.write_str("  mar_U64 result;")
    code.write_str("  result.value = write(arg0.value, (void*) arg1.value, arg2.value);")
    code.write_str("  return result;")
    builtin_funs.&.put("libc_write(U64, U64, U64)", code.to_slice())
  }
  { | libc_close(file: U64): U8
    var code = vec[U8]().&
    code.write_str("  mar_U8 result;")
    code.write_str("  result.value = close(arg0.value);")
    code.write_str("  return result;")
    builtin_funs.&.put("libc_close(U64)", code.to_slice())
  }
  for config in all_int_configs() do {
    var type = config.to_type()

    { | Type
      var code = vec[U8]().&
      code.write_str("struct ")
      code.write_str(type.mangle())
      code.write_str(" { ")
      code.write_str(switch config.signedness case signed "" case unsigned "u")
      code.write_str("int")
      code.write(config.bits)
      code.write_str("_t value; };")
      builtin_types.&.put(type, code.to_slice())
    }

    for operation in vec(
      tuple("add", "+"),
      tuple("subtract", "-"),
      tuple("multiply", "*"),
      tuple("divide", "/"),
      tuple("modulo", "%"),
      tuple("and", "&"),
      tuple("or", "|"),
      tuple("xor", "^"),
    )
    do {
      var name = vec[U8]().&
      name.write_str(operation.a)
      name.write_str("(")
      name.write(type)
      name.write_str(", ")
      name.write(type)
      name.write_str(")")
      var code = vec[U8]().&
      code.write_str("  ")
      code.write_str(type.mangle())
      code.write_str(" i;")
      code.write_char(newline())
      code.write_str("  i.value = arg0.value ")
      code.write_str(operation.b)
      code.write_str(" arg1.value;")
      code.write_char(newline())
      code.write_str("  return i;")
      builtin_funs.&.put(name.to_slice(), code.to_slice())
    }

    { | compare_to(Int, Int): Ordering
      var name = vec[U8]().&
      name.write_str("compare_to(")
      name.write(type)
      name.write_str(", ")
      name.write(type)
      name.write_str(")")
      var code = vec[U8]().&
      code.write_str("  mar_Ordering ordering;")
      code.write_char(newline())
      code.write_str("  if (arg0.value == arg1.value) ordering.variant = mar_Ordering_dot_equal;")
      code.write_char(newline())
      code.write_str("  if (arg0.value < arg1.value) ordering.variant = mar_Ordering_dot_less;")
      code.write_char(newline())
      code.write_str("  if (arg0.value > arg1.value) ordering.variant = mar_Ordering_dot_greater;")
      code.write_char(newline())
      code.write_str("  return ordering;")
      builtin_funs.&.put(name.to_slice(), code.to_slice())
    }

    | Conversion functions
    for target_config in all_int_configs() do {
      if config.equals(target_config) then continue
      var target_type = target_config.to_type()

      var name = vec[U8]().&
      name.write_str("to_")
      name.write(target_type)
      name.write_str("(")
      name.write(type)
      name.write_str(")")
      var code = vec[U8]().&
      code.write_str("  ")
      code.write_str(target_type.mangle())
      code.write_str("  i;")
      code.write_str("  i.value = arg0.value;")
      code.write_str("  return i;")
      builtin_funs.&.put(name.to_slice(), code.to_slice())
    }
  }

  { | Types
    out.write_str("/// Types")
    out.write_char(newline())

    var sorted = sort_types_for_c(mono.type_defs)

    for type in sorted do {
      out.write_str("typedef struct ")
      out.write_str(type.mangle())
      out.write_str(" ")
      out.write_str(type.mangle())
      out.write_str(";")
      out.write_char(newline())
    }

    for type in sorted do {
      var def = mono.type_defs.get(type).unwrap()
      out.write_char(newline())
      out.write_str("// ")
      out.write(type)
      out.write_char(newline())
      switch def
      case builtin_type {
        out.write_str(
          builtin_types.get(type) orelse panic("Unknown builtin type"))
        out.write_char(newline())
      }
      case struct_(struct_) {
        out.write_str("struct ")
        out.write_str(type.mangle())
        out.write_str(" {")
        out.write_char(newline())
        for field in struct_.fields do
          if field.name.equals("*") then {
            out.write_str("  ")
            out.write_str(field.type.mangle())
            out.write_str("* pointer;")
            out.write_char(newline())
          } else {
            out.write_str("  ")
            out.write_str(field.type.mangle())
            out.write_str(" ")
            out.write_str(field.name.mangle())
            out.write_str(";")
            out.write_char(newline())
          }
        out.write_str("};")
      }
      case enum_(enum_) {
        out.write_str("struct ")
        out.write_str(type.mangle())
        out.write_str(" {")
        out.write_char(newline())
        if enum_.variants.is_not_empty() then {
          out.write_str("  enum {")
          out.write_char(newline())
          for variant in enum_.variants do {
            out.write_str("    ")
            out.write_str(type.mangle())
            out.write_str("_dot_")
            out.write_str(variant.name)
            out.write_str(",")
            out.write_char(newline())
          }
          out.write_str("  } variant;")
          out.write_char(newline())
          out.write_str("  union {")
          out.write_char(newline())
          for variant in enum_.variants do {
            out.write_str("    ")
            out.write_str(variant.type.mangle())
            out.write_str(" ")
            out.write_str(variant.name.mangle())
            out.write_str(";")
            out.write_char(newline())
          }
          out.write_str("  } as;")
          out.write_char(newline())
        }
        out.write_str("};")
        out.write_char(newline())
      }
    }
  }

  { | Functions
    var ordered_funs = vec[Slice[U8]]()
    for fun_ in mono.funs do ordered_funs.&.push(fun_.key)
    ordered_funs.to_slice().&.sort()

    | Declarations
    out.write_char(newline())
    out.write_str("/// Function declarations")
    out.write_char(newline())
    for fun_name in ordered_funs do {
      var fun_ = mono.funs.get(fun_name).unwrap()
      out.write_str("/* ")
      out.write_str(fun_name)
      out.write_str(" */ ")
      out.write_str(fun_.return_type.mangle())
      out.write_str(" ")
      out.write_str(fun_name.mangle())
      out.write_str("(")
      for i in 0.to(fun_.arg_types.len) do {
        if i.is_greater_than(0) then out.write_str(", ")
        out.write_str(fun_.arg_types.get(i).mangle())
        out.write_str(" arg")
        out.write(i)
      }
      out.write_str(");")
      out.write_char(newline())
    }

    { | Globals declarations
      out.write_char(newline())
      out.write_str("/// Global declarations")
      out.write_char(newline())
      for global in mono.globals do {
        var name = global.key
        var type = global.value.return_type

        out.write_str(type.mangle())
        out.write_str(" global_")
        out.write_str(name)
        out.write_str(";")
        out.write_char(newline())
      }
      out.write_str(type("Nothing").mangle())
      out.write_str(" _nothing;")
      out.write_char(newline())
      out.write_str(type("Never").mangle())
      out.write_str(" _never;")
      out.write_char(newline())
      out.write_char(newline())
    }

    | Globals initializers
    out.write_str("/// Global initializers")
    out.write_char(newline())
    for global in mono.globals do {
      var name = global.key
      var type = global.value.return_type

      out.write_str(global.value.return_type.mangle())
      out.write_str(" _compute_global_")
      out.write_str(global.key)
      out.write_str("() ")
      out.write_str(global.value.fun_body_to_c())
      out.write_char(newline())
    }
    out.write_char(newline())

    | Definitions
    out.write_str("/// Function definitions")
    out.write_char(newline())
    for signature in ordered_funs do {
      var fun_ = mono.funs.get(signature).unwrap()
      out.write_char(newline())
      out.write_str("// ")
      out.write_str(signature)
      out.write_char(newline())
      out.write_str(fun_.return_type.mangle())
      out.write_str(" ")
      out.write_str(signature.mangle())
      out.write_str("(")
      for i in 0.to(fun_.arg_types.len) do {
        if i.is_greater_than(0) then out.write_str(", ")
        out.write_str(fun_.arg_types.get(i).mangle())
        out.write_str(" arg")
        out.write(i)
      }
      out.write_str(") ")

      if fun_.is_builtin then {
        out.write_str("{") | to fix syntax highlighting: "}"
        out.write_char(newline())

        if builtin_funs.get(signature) is some(body)
        then out.write_str(body)
        else if signature.starts_with("to_address")
        then {
          out.write_str("  mar_U64 address;")
          out.write_char(newline())
          out.write_str("  address.value = (uint64_t) arg0.pointer;")
          out.write_char(newline())
          out.write_str("  return address;")
        }
        else if signature.starts_with("to_reference")
        then {
          out.write_str("  ")
          out.write_str(fun_.return_type.mangle())
          out.write_str(" ref;")
          out.write_char(newline())
          out.write_str("  ref.pointer = (")
          out.write_str(fun_.type_args.get(0).mangle())
          out.write_str("*) arg0.value;")
          out.write_char(newline())
          out.write_str("  return ref;")
        }
        else if signature.starts_with("size_of_type")
        then {
          out.write_str("  mar_U64 size;")
          out.write_char(newline())
          out.write_str("  size.value = (uint64_t) sizeof(")
          out.write_str(fun_.type_args.get(0).mangle())
          out.write_str(");")
          out.write_str("  return size;")
        }
        else {
          var error = &vec[U8]()
          error.write_str("Unknown builtin fun ")
          error.write_str(signature)
          panic(error.to_slice())
        }
        out.write_char(newline())
        out.write_str("}")
        continue
      } else {
        out.write_str(fun_.fun_body_to_c())
        out.write_char(newline())
      }
    }
    out.write_str("// actual main function")
    out.write_char(newline())
    out.write_str("int main(int argc, char** argv) ")
    out.write_char('{)
    out.write_char(newline())

    for global in mono.globals_init_order do {
      out.write_str("  global_")
      out.write_str(global)
      out.write_str(" = _compute_global_")
      out.write_str(global)
      out.write_str("();")
      out.write_char(newline())
    }

    out.write_str("  mar_Str args_data[argc];")
    out.write_char(newline())
    out.write_str("  for (int i = 0; i < argc; i++) ")
    out.write_char('{)
    out.write_char(newline())
    out.write_str("    args_data[i].mar_chars.mar_data.pointer = (mar_Char*) argv[i];")
    out.write_char(newline())
    out.write_str("    int len = 0;")
    out.write_char(newline())
    out.write_str("    while (argv[i][len] != '\0') len++;")
    out.write_char(newline())
    out.write_str("    args_data[i].mar_chars.mar_len.value = len;")
    out.write_char(newline())
    out.write_str("  }")
    out.write_char(newline())
    out.write_str("  mar_Slice_of_Str_end_ args;")
    out.write_char(newline())
    out.write_str("  args.mar_data.pointer = args_data;")
    out.write_char(newline())
    out.write_str("  args.mar_len.value = argc;")
    out.write_char(newline())
    out.write_str("  ")
    out.write_str("main(Slice[Str])".mangle())
    out.write_str("(args);")
    out.write_char(newline())
    out.write_str("}")
  }
  out.to_slice()
}
fun fun_body_to_c(fun_: MonoFun): Slice[U8] {
  var out = vec[U8]().&

  out.write_char('{)
  out.write_char(newline())

  for i in 0.to(fun_.slots.len) do {
    var slot = fun_.slots.get(i)
    var slot_ref = MonoSlotRef { index = i }
    out.write_str("  ")
    out.write_str(slot.type.mangle())
    out.write_str(" ")
    out.write(slot_ref)
    out.write_str(";")
    switch slot.initial_value
    case uninitialized {}
    case arg(j) {
      out.write_str(" ")
      out.write(slot_ref)
      out.write_str(" = arg")
      out.write(j)
      out.write_str(";")
    }
    case int(int) {
      out.write_str(" ")
      out.write(slot_ref)
      out.write_str(".value = ")
      out.write(int)
      out.write_str("ULL;")
    }
    case str(str) {
      out.write_str(" ")
      out.write(slot_ref)
      out.write_str(".")
      out.write_str("chars".mangle())
      out.write_str(".")
      out.write_str("data".mangle())
      out.write_str(".pointer = (")
      out.write_str(type("Char").mangle())
      out.write_str("*) ")
      out.write_char('") | to fix syntax highlighting: "'
      for char in str do {
        out.write_str("\x")
        out.write_with_radix(16, char.to_U64())
      }
      out.write_char('") | to fix syntax highlighting: "'
      out.write_str("; ")
      out.write(slot_ref)
      out.write_str(".")
      out.write_str("chars".mangle())
      out.write_str(".")
      out.write_str("len".mangle())
      out.write_str(".value = ")
      out.write(str.len)
      out.write_str(";")
    }
    out.write_char(newline())
  }

  for statement in fun_.body do {
    switch statement
    case label(label) {
      out.write(label)
      out.write_str(":")
      out.write_char(newline())
    }
    case assign(assign) {
      out.write_str("  ")
      out.write_expr_as_c(assign.to)
      out.write_str(" = ")
      out.write_expr_as_c(assign.value)
      out.write_str(";")
      out.write_char(newline())
    }
    case set_enum(set_enum) {
      out.write_str("  ")
      out.write(set_enum.slot)
      out.write_str(".variant = ")
      out.write_str(fun_.slots.get(set_enum.slot.index).type.mangle())
      out.write_str("_dot_")
      out.write_str(set_enum.variant)
      out.write_str(";")
      out.write_char(newline())
      out.write_str("  ")
      out.write(set_enum.slot)
      out.write_str(".as.")
      out.write_str(set_enum.variant.mangle())
      out.write_str(" = ")
      out.write_expr_as_c(set_enum.value)
      out.write_str(";")
      out.write_char(newline())
    }
    case call(call) {
      out.write_str("  ")
      out.write(call.to)
      out.write_str(" = ")
      out.write_str(call.fun_.mangle())
      out.write_str("(")
      var first = true()
      for arg in call.args do {
        if first then first = false() else out.write_str(", ")
        out.write_expr_as_c(arg)
      }
      out.write_str(");")
      out.write_char(newline())
    }
    case jump(jump) {
      out.write_str("  ")
      out.write_str("goto ")
      out.write(jump.target)
      out.write_str(";")
      out.write_char(newline())
    }
    case jump_if_variant(jump) {
      out.write_str("  ")
      out.write_str("if (")
      out.write_expr_as_c(jump.condition)
      out.write_str(".variant == ")
      out.write_str(jump.condition.type.mangle())
      out.write_str("_dot_")
      out.write_str(jump.variant)
      out.write_str(") goto ")
      out.write(jump.target)
      out.write_str(";")
      out.write_char(newline())
    }
    case get_enum_value(get_enum_value) {
      out.write_str("  ")
      out.write(get_enum_value.to)
      out.write_str(" = ")
      out.write_expr_as_c(get_enum_value.of)
      out.write_str(".as.")
      out.write_str(get_enum_value.variant.mangle())
      out.write_str(";")
      out.write_char(newline())
    }
    case return_(expr) {
      | If a Never is returned, the return is not reached anyway. If we emit
      | it, C complains that Never doesn't match the function's return type.
      if not(expr.type.is_never()) then {
        out.write_str("  ")
        out.write_str("return ")
        out.write_expr_as_c(expr)
        out.write_str("; ")
        out.write_char(newline())
      }
    }
    case ref(ref) {
      out.write_str("  ")
      out.write(ref.to)
      out.write_str(".pointer = &")
      out.write_expr_as_c(ref.of)
      out.write_str(";")
      out.write_char(newline())
    }
    default {}
  }

  out.write_str("}")

  out.to_slice()
}

| File Watching  
| TODO: implement

| Command Line Interface  
| The command line interface which you use to interact with the Martinaise
| compiler.

enum Command { help, ast, mono, c, compile, run, watch }
fun parse_command(command: Slice[U8]): Maybe[Command] {
  if command.equals("help") then return some(Command.help)
  if command.equals("ast") then return some(Command.ast)
  if command.equals("mono") then return some(Command.mono)
  if command.equals("c") then return some(Command.c)
  if command.equals("compile") then return some(Command.compile)
  if command.equals("run") then return some(Command.run)
  if command.equals("watch") then return some(Command.watch)
  none[Command]()
}

fun print_usage_info(out: File) {
  out.write_str("Usage: martinaise <command> <file>")
  out.write_char(newline())
  out.write_str("")
  out.write_char(newline())
  out.write_str("Commands:")
  out.write_char(newline())
  out.write_str("  help     prints this help")
  out.write_char(newline())
  out.write_str("  ast      shows the abstract syntax tree")
  out.write_char(newline())
  out.write_str("  mono     shows the monomorphized code")
  out.write_char(newline())
  out.write_str("  c        compiles to C")
  out.write_char(newline())
  out.write_str("  compile  compiles to an executable")
  out.write_char(newline())
  out.write_str("  run      compiles and runs")
  out.write_char(newline())
  out.write_str("  watch    watches, compiles, and runs")
  out.write_char(newline())
}

| Runs the pipeline that matches the command. Errors are handled internally
| (stuff is printed to stdout). Returns whether it ran through successfully.
fun run_pipeline(command: Command, file_path: Slice[U8]): Bool {
  var stdlib_size = 0
  var input = {
    print_on_same_line({
      var out = vec[U8]().&
      out.write_str("Reading ")
      out.write_str(file_path)
      out.to_slice()
    })

    var stdlib = read_file("stdlib.mar")
    var file = read_file(file_path)
    stdlib_size = stdlib.len

    var input = vec[U8]()
    input.&.write_str(stdlib)
    input.&.write_char(newline())
    input.&.write_str(file)
    input.&.write_char(newline())
    input.to_slice()
  }

  var ast = {
    print_on_same_line({
      var out = vec[U8]().&
      out.write_str("Parsing ")
      out.write_str(file_path)
      out.to_slice()
    })
    switch parse(input, stdlib_size)
    case ok(ast) ast
    case error(err) { eprintsln(err) return false() }
  }
  if command is ast then { println(ast) return true() }

  var mono = {
    print_on_same_line({
      var out = vec[U8]().&
      out.write_str("Compiling ")
      out.write_str(file_path)
      out.to_slice()
    })
    switch monomorphize(ast)
    case ok(mono) mono
    case error(err) { print_on_same_line(err) return false() }
  }
  if command is mono then { println(mono) return true() }

  var c = {
    print_on_same_line({
      var out = vec[U8]().&
      out.write_str("Compiling ")
      out.write_str(file_path)
      out.write_str(" to C")
      out.to_slice()
    })
    mono.compile_to_c()
  }
  if command is c then { printsln(c) return true() }

  todo()
  write_file("output.c", c)
  if command is compile then {
    return true()
  }

  | { // Compile to C
  |       print_on_same_line("Compiling {s} to C\n", .{file_path});
  |       const c_code = try compile_to_c(alloc, the_mono);
  |       var output_file = try std.fs.cwd().createFile("output.c", .{});
  |       defer output_file.close();
  |       try std.fmt.format(output_file.writer(), "{s}\n", .{c_code.items});
  |   }
  |   if (command == .compile) {
  |       std.debug.print("Compiled to output.c. Enjoy!\n", .{});
  |       return true;
  |   }

  |   { // Compile C
  |       print_on_same_line("Compiling C using GCC\n", .{});
  |       var gcc = std.ChildProcess.init(&[_]Str{ "gcc", "output.c" }, alloc);
  |       gcc.stdout = std.io.getStdOut();
  |       gcc.stderr = std.io.getStdErr();
  |       const worked = switch (try gcc.spawnAndWait()) {
  |           .Exited => |code| code == 0,
  |           else => false,
  |       };
  |       if (!worked) {
  |           std.debug.print("Compiling C using GCC failed.\n", .{});
  |           return false;
  |       }
  |   }

  |   { // Run it
  |       print_on_same_line("Running {s}\n", .{file_path});
  |       var program = std.ChildProcess.init(&[_]Str{"./a.out"}, alloc);
  |       program.stdout = std.io.getStdOut();
  |       program.stderr = std.io.getStdErr();
  |       const start = std.time.nanoTimestamp();
  |       const wait_result = try program.spawnAndWait();
  |       const end = std.time.nanoTimestamp();
  |       const runtime: usize = @intCast(end - start);
  |       std.debug.print("\n", .{});
  |       switch (wait_result) {
  |           .Exited => |code| {
  |               std.debug.print("Program exited with {d} after {d} ms.\n", .{
  |                   code,
  |                   @divTrunc(runtime, 1000000),
  |               });
  |           },
  |           .Signal => |signal| {
  |               std.debug.print("Program was signalled {d}.\n", .{signal});
  |               return error.ProgramSignaled;
  |           },
  |           .Stopped => |val| {
  |               std.debug.print("Program stopped because of {d}.\n", .{val});
  |               return error.Todo;
  |           },
  |           .Unknown => |val| {
  |               std.debug.print("Waiting for program completed with unknown wait result {d}.\n", .{val});
  |               return error.Todo;
  |           },
  |       }
  |   }

  true()
}

fun wrong_usage(): Never { print_usage_info(stderr()) exit(1_U8) }

fun main(args: Slice[Slice[U8]]) {
  eprintsln("Welcome to Martinaise in Martinaise.")

  | Ways to use this program:
  | - martinaise help
  | - martinaise ast <file>
  | - martinaise mono <file>
  | - martinaise c <file>
  | - martinaise compile <file>
  | - martinaise run <file> [-- <additonal args>]
  | Note the program name itself is also an additional argument at the front.
  if args.len.is_less_than(2) then wrong_usage()
  var command = parse_command(args.get(1)) orelse wrong_usage()
  if command is help then {
    print_usage_info(stdout())
    exit(0_U8)
  }
  if args.len.is_less_than(3) then wrong_usage()
  var file_path = args.get(2)

  | TODO: support -O <output>
  | TODO: throw if additional args are given
  | TODO: support -- and additional args for the run command

  | TODO: support the watch command
  var was_successful = run_pipeline(command, file_path)

  exit(if was_successful then 0_U8 else 1_U8)
}
