| The Martinaise Compiler  
| This is the compiler for Martinaise, written in Martinaise.
| TODO: This is far from finished.
| 
| Glossary  
| arg  = argument
| args = arguments
| def  = definition
| env  = environment
| expr = expression
| fun  = function
| init = initialize
| str  = string

| Terminal utilities  

fun clear_terminal() {
  todo()
  | var clear = std.ChildProcess.init(&[_]Str{"clear"}, alloc);
  | clear.stdout = std.io.getStdOut();
  | clear.stderr = std.io.getStdErr();
  | _ = try clear.spawnAndWait();
}

fun print_on_same_line(message: Slice[U8]) {
  | \x1b[1A\x1b[K
  print_char(27)
  prints("[1A")
  print_char(27)
  prints("[K")
  printsln(message)
}

| Types  
| Types such as Int or Slice[&U8] are fundamental to Martinaise. In the
| compiler, they are represented as a tree. For example, the Slice[&U8] type is
| represented like this:
|
| Type { name = "Slice", args = [
|   Type { name = "&", args = [
|     Type { name = "U8", args = [] }
|   ] }
| ] }
|
| This representation of types is used throughout the AST and Mono stage of the
| compiler.
struct Type { name: Slice[U8], args: Vec[Type] }
fun named_type(name: Slice[U8]): Type { Type { name, args = vec[Type]() } }
fun write[W](writer: W, type: Type) {
  writer.write_str(type.name);
  if type.name.equals("&")
  then writer.write(type.args.get(0))
  else writer.write_type_args(type.args)
}
fun write_type_args[W](writer: W, args: Vec[Type]) {
  writer.write_char('[);
  var first = true()
  for arg in args do {
    if first then first = false() else writer.write_str(", ")
    writer.write(arg)
  }
  writer.write_char(']);
}
fun specialize(type: Type, type_env: Map[Slice[U8], Type]): Type {
  | TODO: Make sure generic types don't have parameters.
  type_env.get(type.name) orelse {
    var args = vec[Ty]()
    for arg in type.args do args.&.push(arg.specialize(type_env))
    Type { name = type.name, args }
  }
}

| Numbers  
| Numbers such as U8 or I32 are special in Candy. These numbers and mathematical
| functions for them are magically in scope. Because multiple stages of the
| compiler work with numbers, here are some shared concepts.
enum Signedness { signed, unsigned }
struct IntConfig { signedness: Signedness, bits: U64 }
fun to_char(s: Signedness): U8 { switch s case signed 'I case unsigned 'U }
fun all_signednesses(): Vec[Signdness] {
  vec(Signdness.signed, Signedness.unsigned)
}
fun all_bits(): Vec[U64] { vec(8, 16, 32, 64) }
fun all_int_configs(): Vec[IntConfig] {
  var configs = vec[IntConfig]()
  for signedness in all_signednesses() do
    for bits in all_bits() do
      configs.&.push(IntConfig { signedness, bits })
  configs
}
fun to_type(config: IntConfig) Type {
  var name = vec[U8]()
  name.&.write_char(config.signedness.to_char())
  name.&.write(config.bits)
  named_type(name.to_slice())
}

| The Abstract Syntax Tree  
| The compiler input is parsed into an abstract syntax tree. This tree is a
| representation of the program that roughly corresponds to the structure of the
| source code.
struct AstProgram { defs: Vec[AstDef] }
enum AstDef {
  struct_: AstStruct,
  enum_: AstEnum,
  fun_: AstFun,
}
struct AstStruct {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  fields: Vec[AstStructField],
}
struct AstStructField { name: Slice[U8], type: Type }
struct AstEnum {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  variants: Vec[AstEnumVariant],
}
struct AstEnumVariant { name: Slice[U8], type: Type }
struct AstFun {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  args: Vec[AstFunArg],
  returns: Type,
  is_builtin: Bool,
  body: Vec[AstExpr],
}
struct AstFunArg { name: Slice[U8], type: Type }
enum AstExpr {
  int: AstInt, | 0_U64
  str: Slice[U8], | "foo"
  name: Slice[U8], | foo
  type_arged: AstTypeArged, | ...[T] | TODO: remove
  call: AstCall, | ...(arg)
  init_struct: AstInitStruct, | Foo { a = ... }
  init_enum: AstInitEnum, | Maybe.some(5)
  member: AstMember, | foo.bar
  var_: AstVar, | var foo = ...
  assign: AstAssign, | foo = ...
  switch_: AstSwitch, | switch foo case a ... case b(bar) ...
  loop_: &AstExpr, | loop ...
  return_: &AstExpr, | return ...
  body: Vec[AstExpr], | { ... }
}
struct AstInt { value: U64, signedness: Signedness, bits: U64 }
struct AstTypeArged { expr: &AstExpr, type_args: Vec[Type] }
struct AstCall { callee: &AstExpr, args: Vec[AstExpr] }
struct AstInitStruct { type: Type, fields: Vec[AstInitStructField] }
struct AstInitStructField { name: Slice[U8], value: Expr }
struct AstInitEnum { type: Type, variant: Slice[U8], arg: &AstExpr }
struct AstMember { of: &AstExpr, name: Slice[U8] }
struct AstVar { name: Slice[U8], value: &AstExpr }
struct AstAssign { to: &AstExpr, value: &AstExpr }
struct AstSwitch { value: &AstExpr, cases: Vec[AstCase], default_: Maybe[&AstExpr] }
struct AstCase { variant: Slice[U8], binding: Maybe[Slice[U8]], then_: &AstExpr }

fun call(expr: AstExpr, args: Vec[AstExpr]): AstExpr {
  AstExpr.call(AstCall { callee = expr.put_on_heap(), args })
}
fun member(expr: AstExpr, name: Slice[U8]): AstExpr {
  AstExpr.member(AstMember { of = expr.put_on_heap(), name })
}
fun var_(name: Slice[U8], value: AstExpr): AstExpr {
  AstExpr.var_(AstVar { name, value })
}

fun write[W](writer: W, program: AstProgram) {
  for def in program.defs do { writer.write(def) writer.write_char(newline()) }
}
fun write[W](writer: W, def: AstDef) {
  switch def
  case struct_(s) writer.write(s)
  case enum_(e) writer.write(e)
  case fun_(f) writer.write(f)
}
fun write_signature[W](writer: W, def: Def) {
  switch def
  case struct_(s) {
    writer.write_str("struct ")
    writer.write_str(s.name)
    writer.write_type_args(s.type_args)
  }
  case enum_(e) {
    writer.write_str("enum ")
    writer.write_str(e.name)
    writer.write_type_args(e.type_args)
  }
  case fun_(f) {
    writer.write_str(f.name)
    writer.write_type_args(f.type_args)
    writer.write_char('()
    var first = true()
    for arg in f.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(arg.type)
    }
    writer.write_char('))
  }
}
fun write[W](writer: W, s: AstStruct) {
  writer.write_str("struct ")
  writer.write_str(s.name)
  writer.write_type_args(s.type_args)
  if s.fields.is_empty() then writer.write_str(" {}") else {
    writer.write_str(" {")
    writer.write_char(newline())
    for field in s.fields do {
      writer.write_str("  ")
      writer.write_str(field.name)
      writer.write_str(": ")
      writer.write(field.type)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_char('})
  }
}
fun write[W](writer: W, e: AstEnum) {
  writer.write_str("enum ")
  writer.write_str(e.name)
  writer.write_type_args(e.type_args)
  if e.variants.is_empty() then writer.write_str(" {}") else {
    writer.write_str(" {")
    writer.write_char(newline())
    for variant in e.variants do {
      writer.write_str("  ")
      writer.write_str(variant.name)
      writer.write_str(": ")
      writer.write(variant.type)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_char('})
  }
}
fun write[W](writer: W, f: AstFun) {
  writer.write_str("fun ")
  writer.write_str(f.name)
  writer.write_type_args(f.type_args)
  writer.write_char('()
  var first = true()
  for arg in f.args do {
    if first then first = false() else writer.write_str(", ")
    writer.write_str(arg.name)
    writer.write_str(": ")
    writer.write_str(arg.type)
  }
  writer.write_char("): ")
  writer.write(f.returns)
  if f.is_builtin
  then writer.write_str("{ ... }")
  else writer.write_body(0, f.body)
}
fun write_indent[W](writer: W, indent: U64) {
  for i in 0.to(indent) do writer.write_char(' )
}
fun write_body[W](writer: W, indent: U64, body: Vec[AstExpr]) {
  writer.write_char('{)
  for expr in body do {
    writer.write_indent(indent.inc())
    writer.write(indent.inc(), expr)
    writer.write_char(newline())
  }
  writer.write_indent(indent)
  writer.write_char('})
}
fun write[W](writer: W, indent: U64, expr: AstExpr) {
  switch expr
  case int(i) {
    writer.write(i.value)
    writer.write_char('_)
    writer.write_char(i.signedness.to_char())
    writer.write(i.bits)
  }
  case str(s) {
    writer.write_char('")
    writer.write_str(s)
    writer.write_char('")
  }
  case name(n) writer.write_str(n)
  case type_arged(t) {
    writer.write(indent, t.arged.*)
    writer.write_type_args(t.type_args)
  }
  case call(c) {
    writer.write(indent, c.callee.*)
    writer.write_char('()
    var first = true()
    for arg in c.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(indent, arg)
    }
    writer.write_char('))
  }
  case init_struct(s) {
    writer.write(s.type)
    writer.write_str(" {")
    writer.write_char(newline())
    for field in s.fields do {
      writer.write_indent(indent.inc())
      writer.write(field.name)
      writer.write_str(" = ")
      writer.write(indent.inc(), field.value)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_indent(indent)
    writer.write_str("}")
  }
  case init_enum(e) {
    writer.write(s.type)
    writer.write_str(".")
    writer.write_str(e.variant)
    writer.write_str("(")
    writer.write(indent, e.arg)
    writer.write_str(")")
  }
  case member(m) {
    writer.write(indent, m.of.*)
    writer.write_char('.)
    writer.write_str(m.name)
  }
  case var_(v) {
    writer.write_str("var ")
    writer.write_str(v.name)
    writer.write_str(" = ")
    writer.write(indent, v.value.*)
  }
  case assign(a) {
    writer.write(indent, a.to.*)
    writer.write_str(" = ")
    writer.write(indent, a.value.*)
  }
  case switch_(s) {
    writer.write_str("switch ")
    writer.write(indent, s.value.*)
    writer.write_str(" {")
    writer.write_char(newline())
    for c in s.cases do {
      writer.write_indent(indent)
      writer.write_str("case ")
      writer.write_str(c.variant.*)
      if c.binding is some(b) then {
        writer.write_char('()
        writer.write(indent, b)
        writer.write_char('))
      }
      writer.write_str(" ")
      writer.write(indent.inc(), c.then_.*)
      writer.write_char(newline())
    }
    if c.default_ is some(d) then {
      writer.write_indent(indent)
      writer.write_str("default ")
      writer.write(indent, d.*)
      writer.write_char(newline())
    }
    writer.write_indent(indent)
    writer.write_str("}")
  }
  case orelse_(o) {
    writer.write(indent, o.primary.*)
    writer.write_str(" orelse ")
    writer.write(indent, o.alternative.*)
  }
  case loop_(l) {
    writer.write_str("loop ")
    writer.write(indent, l.body.*)
  }
  case for_(f) {
    writer.write_str("for ")
    writer.write(indent, f.iter_var)
    writer.write_str(" in ")
    writer.write(indent, f.iter.*)
    writer.write_str(" do ")
    writer.write(indent, f.body.*)
  }
  case return_(r) {
    writer.write_str("return ")
    writer.write(indent, r.*)
  }
  case body(b) writer.write_body(indent, b)
}

| Parsing  
| Unlike the parser in Candy (github.com/candy-lang/candy), the Martinaise
| parser favors simplicity over robustness. The first time it encounters an
| error, it simply gives up. This also means that for invalid code, you'll only
| get the first syntax error reported.
| 
| The parser is structured as a recursive descent parser: Lots of little
| functions call each other, each parsing a specific syntax, and all operate
| with a common cursor. Almost all parser functions return
| Result[Maybe[...], Str], where the return value has this meaning:
|
| - ok(none): The parser function doesn't match what comes next in the input.
|   The cursor remains unchanged.
| - ok(some(...)): The parsing was successful. The result is in the return
|   value.
| - error(...): The input is invalid. The entire parser should give up. The
|   cursor is at the position where the error in the input is.
|
| For example, here are possible results of the parse_number function:
|
| input         | "abc"    | "42 foo"     | "42foo"
| cursor before |  ^       |  ^           |  ^
| cursor after  |  ^       |    ^         |    ^
| result        | ok(none) | ok(some(42)) | error("Expected another digit.")
|
| - In the first case, the parser didn't match because the input doesn't start
|   with a digit.
| - In the second case, the parser does match, and it successfully parses the
|   number, moving the cursor after the number.
| - In the third case, the input starts with a digit â€“ unmistakably a number!
|   However, because it has a lowercase letter in it, it's invalid and results
|   in an error. This is an invalid program.
|
| Whitespace is automatically consumed by the fundamental parsers. This is done
| because Martinaise generally doesn't care about whitespace and it makes the
| code of the higher-level parsers (structs, enums, etc.) much more concise.

struct Parser { code: Slice[U8], cursor: U64 }

fun current(parser: Parser): U8 { parser.code.get(parser.cursor) }
fun rest(parser: Parser): Slice[U8] { parser.code.subslice(parser.cursor) }
fun advance(parser: &Parser) { parser.advance_by(1) }
fun advance_by(parser: &Parser, n: U64) { parser.cursor = parser.cursor.add(n) }
| TODO: move into stdlib
fun is_whitespace(char: U8): Bool {
  char.equals(' ).or(char.equals(tab())).or(char.equals(newline()))
}

fun consume_whitespace(parser: &Parser) {
  loop {
    if parser.cursor.is_at_least(parser.code.len) then break
    var char = parser.current()
    if char.is_whitespace() then {
      parser.cursor = parser.cursor.inc()
      continue
    }
    if char.equals('|') then {
      loop {
        if parser.cursor.is_at_least(parser.code.len) then break
        if parser.current().equals(newline()) then break
        parser.cursor = parser.cursor.inc()
      }
      continue
    }
    break | not a whitespace nor comment
  }
}

fun consume_prefix(parser: &Parser, prefix: Slice[U8]): Maybe[Nothing] {
  parser.consume_whitespace()
  if not(parser.rest().starts_with(prefix)) then return none[Nothing]()
  parser.advance_by(prefix.len)
  some({})
}

| Also makes sure there's a whitespace following, so consume_keyword("fun")
| doesn't match the code "funny".
fun consume_keyword(parser: &Parser, keyword: Slice[U8]): Maybe[Nothing] {
  parser.consume_whitespace()
  if not(parser.rest().starts_with(keyword)) then return none[Nothing]()
  if parser.rest().len.is_greater_than(keyword.len) then {
    var char_after = if parser.rest().get(keyword.len)
    if not(char_after.is_whitespace().or(char_after.equals('|))) then
      return none[Nothing]()
  }
  parser.advance_by(keyword.len)
  some({})
}

fun parse_name(parser: &Parser): Maybe[Slice[U8]] {
  var start = parser.cursor
  loop {
    var char = parser.current()
    if 'A.until('Z).contains(char).or('a.until('z).contains(char))
    then { parser.advance() continue }
    if '0.until('9).contains(char) then
      if parser.cursor.equals(start)
      then break
      else { parser.advance() continue }
    break
  }
  if parser.cursor.equals(start) then return none[Slice[U8]]()
  some(parser.code.subslice(start, parser.cursor))
}

fun parser_lower_name(parser: &Parser): Maybe[Slice[U8]] {
  parser.consume_whitespace()
  if not('a.until('z).contains(parser.current())) then return none[Slice[U8]]()
  some(parser.parse_name())
}

fun parser_upper_name(parser: &Parser): Maybe[Slice[U8]] {
  parser.consume_whitespace()
  if not('A.until('Z).contains(parser.current())) then return none[Slice[U8]]()
  some(parser.parse_name())
}

| Convenience methods for the three possible results of parsers returning a
| Result[Maybe[T]].
| alias ParseResult[T] = Result[Maybe[T], Slice[U8]]
fun bad_input[T](error: Slice[U8]): Result[Maybe[T], Slice[U8]] {
  error[Maybe[T], Slice[U8]](error)
}
fun no_match[T](): Result[Maybe[T], Slice[U8]] {
  ok[Maybe[T], Slice[U8]](none[T]())
}
fun parsed[T](val: T): Result[Maybe[T], Slice[U8]] {
  ok[Maybe[T], Slice[U8]](some(val))
}

fun parse_type(parser: &Parser): Result[Maybe[Type], Slice[U8]] {
  if parser.consume_prefix("&") is some then {
    var arg = parser.parse_type_args()?
      orelse return bad_input[Type]("After &, there must come a type.")
    return parsed(Type { name = "&", args = vec(arg) })
  }

  var name = parser.parse_upper_name() orelse return no_match[Type]()
  var args = parser.parse_type_args()? orelse vec[Type]()
  parsed(Type { name, args })
}

fun parse_type_args(parser: &Parser): Result[Maybe[Vec[Type]], Slice[U8]] {
  var args = vec[Ty]()
  parser.consume_prefix("[") orelse return no_match[Vec[Type]]()
  loop {
    var arg = parser.parse_type()? orelse break
    args.push(arg)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("]") orelse return bad_input[Vec[Type]](
    "Expected a closing bracket to end the type arguments.")
  parsed(args)
}

fun parse_type_params(parser: &Parser): Result[Maybe[Vec[Type]], Slice[U8]] {
  var args = vec[Ty]()
  parser.consume_prefix("[") orelse return no_match[Vec[Type]]()
  loop {
    var arg = parser.parse_upper_name() orelse break
    args.push(arg)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("]") orelse return bad_input[Vec[Type]](
    "Expected a closing bracket to end the type arguments.")
  parsed(args)
}

| TODO: explanation
fun parse_expr(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var expr = parser.parse_expr_without_suffix()?
    orelse return no_match[AstExpr]()
  loop
    switch parser.parse_expr_suffix(expr)? case some(e) expr = e case none break
  expr
}
fun parse_expr_without_suffix(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  | if parser.parse_var()? is some(v) then return parsed(AstExpr.var_(v))

  if parser.parse_int()? is some(i) then return parsed(AstExpr.int(i))
  if parser.parse_char()? is some(c) then return parsed(AstExpr.char(c))
  if parser.parse_str()? is some(s) then return parsed(AstExpr.str(s))
  if parser.parse_init()? is some(s) then return parsed(s)
  if parser.parse_body()? is some(b) then return parsed(AstExpr.body(b))
  if parser.parse_var()? is some(v) then return parsed(AstExpr.var_(v))
  if parser.parse_if()? is some(i) then return parsed(AstExpr.if_(i))
  if parser.parse_switch()? is some(s) then return parsed(AstExpr.switch_(s))
  if parser.parse_loop()? is some(l) then return parsed(AstExpr.loop_(l))
  if parser.parse_for()? is some(f) then return parsed(AstExpr.for_(f))
  if parser.parse_return()? is some(r) then return parsed(AstExpr.return_(r))
  if parser.parse_lower_name()? is some(n) then return parsed(AstExpr.name(n))
}
fun parse_expr_suffix(parser: &Parser, expr: Expr): Result[Maybe[AstExpr], Slice[U8]] {
  if parser.parse_suffix_member(expr)? is some(m) then return parsed(m)
  if parser.parse_suffix_call(expr)? is some(c) then return parsed(c)
  if parser.parse_suffix_type_arged(expr)? is some(t) then return parsed(t)
  if parser.parse_suffix_assign(expr)? is some(a) then return parsed(a)
  if parser.parse_suffix_orelse(expr)? is some(o) then return parsed(o)
}

fun parse_digits(parser: &Parser): Result[Maybe[U64], Slice[U8]] {
  var start = parser.cursor
  var num = 0
  loop {
    var char = parser.current()
    if '0.until('9).contains(char) then {
      num = num.multiply(10).add(char).subtract('0) | TODO: put in stdlib
      parser.advance()
    }
    else if char.equals('_) then parser.advance()
    else break
  }
  if parser.cursor.equals(start) then return no_match[U64]()
  if parser.code.get(parser.cursor.dec()).equals('_)
  then parser.cursor = parser.cursor.dec()
  parsed(num)
}

fun parse_int(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var value = parser.parse_digits()? orelse return no_match[AstExpr]()
  parser.consume_prefix("_")
    orelse return parsed(AstExpr.int(
      AstInt { value, signedness = Signedness.unsigned, bits = 64 }))
  var signedness =
    if parser.consume_prefix("I") is some then Signdness.signed
    else if parser.consume_prefix("U") is some then Signdness.unsigned
    else return bad_input[AstExpr]("Expected a signedness (U or I).")
  var bits = parser.parse_digits()?
    orelse return bad_input[AstExpr]("Expected bit length of the integer.")
  | TODO: check that number fits in range
  parsed(AstExpr.int(AstInt { value, signedness, bits }))
}

fun parse_char(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix('') orelse return no_match[AstExpr]()
  var char = parser.current()
  parser.advance()
  parsed(AstExpr.int(
    AstInt { char, signedness = Signedness.unsigned, bits = 8 }))
}

fun parse_str(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix('") orelse return no_match[AstExpr]()
  var start = parser.cursor
  loop if parser.current().equals('") then break else parser.advance()
  parser.advance()
  parsed(AstExpr.str(parser.code.subslice(start, parser.cursor.dec())))
}

fun parse_init(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var type = parser.parse_type()? orelse return no_match[AstExpr]()
  if parser.consume_prefix("{") is some then {
    var fields = vec[AstInitStructField]()
    loop {
      var name = parser.parse_lower_name() orelse break
      var value =
        if parser.consume_prefix("=") is some
        then parser.parse_expr()?
          orelse return bad_input[AstExpr]("Expected the value of the field.")
        else AstExpr.name(name)
      fields.push(AstInitStructField { name, value })
      parser.consume_prefix(",") orelse break
    }
    parser.consume_prefix("}")
      orelse return bad_input[AstExpr]("Expected a closing brace.")
    parsed(AstExpr.init_struct(AstInitStruct { type, fields }))
  } else {
    parser.consume_prefix(".")
      orelse return bad_input[AstExpr](
        "Expected struct or enum initialization.")
    var variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected the variant.")
    
    var arg = AstExpr.body(vec[AstExpr]())
    if parser.consume_prefix("(") is some then {
      arg = parser.parse_expr()
        orelse return bad_input[AstExpr](
          "Expected an argument for the variant.")
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
    parsed(AstExpr.init_enum(AstInitEnum { type, variant, arg }))
  }
}

fun parse_body(parser: &Parser): Result[Maybe[Vec[AstExpr]], Slice[U8]] {
  parser.consume_prefix("{") orelse return no_match[Vec[AstExpr]]()
  var statements = vec[AstExpr]()
  loop switch self.parse_expr()? case some(e) statements.push(e) case none break
  parser.consume_prefix("}")
    orelse return bad_input[Vec[AstExpr]](
      "Expected the closing brace of the body.")
  parsed(statements)
}

fun parse_var(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("var") orelse return no_match[AstExpr]()
  var name = parser.parse_lower_name()
    orelse return bad_input[AstExpr]("Expected the name of the variable.")
  parser.consume_prefix("=")
    orelse return bad_input[AstExpr]("Expected an equals sign.")
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected the value of the variable.")
  parsed(AstExpr.var_(AstVar { name, value = value.put_on_heap() }))
}

fun parse_if(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("if") orelse return no_match[AstExpr]()
  var condition = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected the condition.")
  var variant = "true"
  var binding = none[Slice[U8]]()
  if parser.consume_keyword("is") is some then {
    variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected a variant.")
    if parser.consume_prefix("(") is some then {
      binding = some(parser.parser_lower_name()
        orelse return bad_input[AstExpr]("Expected the name of the binding."))
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
  }
  parser.consume_keyword("then")
    orelse return bad_input[AstExpr]("Expected then keyword.")
  var then_ = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected a then expression.")
  var else_ = AstExpr.body(vec[AstExpr]())
  if parser.consume_keyword("else") is some
  then else_ = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected an else expression.")
  parsed(AstExpr.switch_(AstSwitch {
    value = condition,
    cases = vec(AstCase { variant, binding, then_ }),
    default_ = else_,
  }))
}

fun parse_switch(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("switch") orelse return no_match[AstExpr]()
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected the value that is switched over.")
  var cases = vec[AstCase]()
  loop {
    parser.consume_keyword("case") orelse break
    var variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected a variant.")
    var binding = none[Slice[U8]]()
    if parser.consume_prefix("(") is some then {
      binding = some(parser.parser_lower_name()
        orelse return bad_input[AstExpr]("Expected the name of the binding."))
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
    var then_ = parser.parse_expr()?
        orelse return bad_input[AstExpr]("Expected a case expression.")
    cases.push(AstCase { variant, binding, then_ })
  }
  var default_ = none[&AstExpr]()
  if parser.consume_keyword("default") is some
  then default_ = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected a default expression.")
  parsed(AstExpr.switch_(AstSwitch { value, cases, default_ }))
}

fun parse_loop(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("loop") orelse return no_match[AstExpr]()
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected loop expression.")
  parsed(AstExpr.loop_(expr.put_on_heap()))
}

fun parse_for(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("for") orelse return no_match[AstExpr]()
  var iter_var = parser.parse_lower_name()
    orelse return bad_input[AstExpr](
      "Expected the name of the iteration variable.")
  parser.consume_keyword("in")
    orelse return bad_input[AstExpr]("Expected in keyword.")
  var iter = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected something to iterate over.")
  parser.consume_keyword("do")
    orelse return bad_input[AstExpr]("Expected do keyword.")
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected a loop expression.")
  parsed(AstExpr.body(vec(
    var_("$iter", iter.member("iter").call(vec[AstExpr]()).member("&")),
    AstExpr.loop_(AstExpr.body(vec(
      var_(iter_var, AstExpr.switch_(AstSwitch {
        value = AstExpr.name("$iter").member("next").call(vec[AstExpr]())
          .put_on_heap(),
        cases: vec(
          AstCase {
            variant: "some",
            binding: some("a"),
            then_: AstExpr.name("a").put_on_heap()
          },
          AstCase {
            variant: "none",
            binding: none[Slice[U8]](),
            then_: AstExpr.break_.put_on_heap(),
          },
        ),
        default_: none[&AstExpr](),
      }),
      expr,
    )))
  )))
}

fun parse_return(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("return") orelse return no_match[AstExpr]()
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected returned expression.")
  parsed(AstExpr.return_(expr.put_on_heap()))
}

fun parse_expr_suffix_member(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix(".") orelse return no_match[AstExpr]()
  if parser.consume_prefix("*") is some then return parsed(current.member("*"))
  if parser.consume_prefix("&") is some then return parsed(current.member("&"))
  if parser.parse_lower_name() is some(name)
  then return parsed(current.member(name))
  return bad_input[AstExpr]("Expected the name of a member.")
}

fun parse_expr_suffix_call(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("(") orelse return no_match[AstExpr]()
  var args = vec[AstExpr]()
  loop {
    args.push(parser.parse_expr()? orelse break)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix(")")
    orelse return bad_input[AstExpr](
      "Expected closing parenthesis of the call.")
  parsed(current.call(args))
}

fun parse_expr_suffix_type_arged(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  var type_args = parser.parse_type_args()? orelse return no_match[AstExpr]()
  parsed(AstExpr.type_arged(AstTypeArged {
    expr = current.put_on_heap(),
    type_args,
  }))
}

fun parse_expr_suffix_assign(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("=") orelse return no_match[AstExpr]()
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected an expression on the right side of the assign.")
  parsed(AstExpr.assign(AstAssign {
    to = current.put_on_heap(),
    value = value.put_on_heap(),
  }))
}

fun parse_expr_suffix_orelse(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("orelse") orelse return no_match[AstExpr]()
  var alternative = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected alternative expression after orelse.")
  parsed(AstExpr.switch_(AstSwitch {
    value = current, | TODO: call some function
    cases = vec(
      AstCase {
        variant = "some",
        binding = some("a"),
        then_: AstExpr.name("a").put_on_heap(),
      },
      AstCase {
        variant = "none",
        binding = none[Slice[U8]](),
        then_: alternative.put_on_heap(),
      },
    ),
    default_ = none[AstExpr](),
  }))
}

fun parse_fun(parser: &Parser): Result[Maybe[AstFun], Slice[U8]] {
  parser.consume_keyword("fun") orelse return no_match[AstFun]()
  var name = parser.parse_lower_name()
    orelse return bad_input[AstFun]("Expected the name of the function.")
  var type_args = parser.parse_type_params() orelse vec[Slice[U8]]()
  var args = vec[AstFunArg]()
  parser.consume_prefix("(")
    orelse return bad_input[AstFun]("Expected an opening parenthesis.")
  loop {
    var name = parser.parse_lower_name() orelse break
    parser.consume_prefix(":")
      orelse return bad_input[AstFun]("Expected a colon.")
    var type = parser.parse_type()?
      orelse return bad_input[AstFun]("Expected the type of the argument.")
    args.push(AstFunArg { name, type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix(")")
    orelse return bad_input[AstFun]("Expected a closing parenthesis.")
  var returns = named_type("Nothing")
  if parser.consume_prefix(":") is some
  then returns = parser.parse_type()?
    orelse return bad_input[AstFun]("Expected the return type.")
  var is_builtin = false()
  var body =
    switch parser.consume_prefix("{ ... }")
    case some {
      is_builtin = true()
      vec[AstExpr]()
    }
    case none parser.parse_body()?
      orelse return bad_input[AstFun]("Expected a function body.")
  AstFun { name, type_args, args, returns, is_builtin, body }
}

fun parse_struct(parser: &Parser): Result[Maybe[AstStruct], Slice[U8]] {
  parser.consume_keyword("struct") orelse return no_match[AstStruct]()
  var name = parser.parse_upper_name()
    orelse return bad_input[AstStruct]("Expected an uppercase name.")
  var type_params = parser.parse_type_params()? orelse vec[Slice[U8]]()
  parser.consume_prefix("{")
    orelse return bad_input[AstStruct]("Expected an opening brace.")
  var fields = vec[AstStructField]()
  loop {
    var field_name = parser.parse_lower_name() orelse break
    parser.consume_prefix(":")
      orelse return bad_input[AstStruct]("Expected a colon.")
    var field_type = parser.parse_type()?
      orelse return bad_input[AstStruct]("Expected the type of the field.")
    fields.push(AstStructField { name = field_name, type = field_type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("}")
    orelse return bad_input[AstStruct](
      "Expected a closing brace to end the struct.")
  parsed((AstStruct { name, type_params, fields })
}

fun parse_enum(parser: &Parser): Result[Maybe[AstEnum], Slice[U8]] {
  parser.consume_keyword("enum") orelse return no_match[AstEnum]()
  var name = parser.parse_upper_name()
    orelse return bad_input[AstEnum]("Expected an uppercase name.")
  var type_params = parser.parse_type_params()? orelse vec[Slice[U8]]()
  parser.consume_prefix("{")
    orelse return bad_input[AstEnum]("Expected an opening brace.")
  var variants = vec[AstEnumVariant]()
  loop {
    var variant_name = parser.parse_lower_name() orelse break
    var variant_type = named_type("Nothing")
    if parser.consume_prefix(":") is some
    then variant_type = parser.parse_type()?
      orelse return bad_input[AstEnum]("Expected the type of the variant.")
    variants.push(AstEnumVariant { name = variant_name, type = variant_type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("}")
    orelse return bad_input[AstEnum](
      "Expected a closing brace to end the enum.")
  AstEnum { name, type_params, variants }
}

fun parse_def(parser: &Parser): Result[Maybe[AstDef], Slice[U8]] {
  if parser.parse_struct()? is some(s) then return AstDef.struct_(s)
  if parser.parse_enum()? is some(e) then return AstDef.enum_(e)
  if parser.parse_fun()? is some(f) then return AstDef.fun_(f)
}

fun parse_defs(parser: &Parser): Result[Maybe[Vec[AstDef]], Slice[U8]] {
  var defs = vec[AstDef]()
  loop switch parser.parse_def()? case some(d) defs.push(d) case none break
  if parser.cursor.is_less_than(parser.code.len)
  then return bad_input[Vec[AstDef]]("Expected a definition.")
  defs
}

fun parse(code: Slice[U8], stdlib_size: U64): Result[AstProgram, Slice[U8]] {
  var parser = Parser { code }
  | TODO: Replace switch with catch/orelse
  switch parser.parse_defs()
  case error(error)
    if parser.cursor.is_at_most(stdlib_size)
    then error[AstProgram, Slice[U8]](
      format_error_with_context(parser.code, parser.cursor, error))
    else error[AstProgram, Slice[U8]](format_error_with_context(
      parser.code.subslice(stdlib_size),
      parser.cursor.subtract(stdlib_size),
      error
    ))
  case ok(defs) {
    | Add builtins
    | TODO: Explanation

    | struct &[T] { *: T }
    defs.push(AstDef.struct_(AstStruct {
      name = "&",
      type_args = vec("T"),
      fields = vec(AstStructField { name = "*", type = named_type("T") })
    }))

    | Int stuff
    for config in all_int_configs() do {
      var type = config.int_type()
      defs.push(AstDef.builtin_type(type))

      var two_args = vec(
        AstFunArg { name = "a", type },
        AstFunArg { name = "b", type },
      )
      defs.push_builtin_fun("add", two_args, type)
      defs.push_builtin_fun("subtract", two_args, type)
      defs.push_builtin_fun("multiply", two_args, type)
      defs.push_builtin_fun("divide", two_args, type)
      defs.push_builtin_fun("modulo", two_args, type)
      defs.push_builtin_fun("compare_to", two_args, named_type("Ordering"))
      defs.push_builtin_fun("shiftLeft", two_args, type)
      defs.push_builtin_fun("shiftRight", two_args, type)
      defs.push_builtin_fun("bitLength", two_args, type)
      defs.push_builtin_fun("and", two_args, type)
      defs.push_builtin_fun("or", two_args, type)
      defs.push_builtin_fun("xor", two_args, type)

      | Conversion function
      for target_config in all_int_configs() do {
        if config.equals(target_config) then continue
        var target_type = target_config.int_type()
        var name = vec[U8]()
        name.write("to_")
        name.write(target_type)
        defs.push_builtin_fun(name, vec(AstFunArg { name = "i", type }), target_type)
      }
    }

    ok[AstProgram, Slice[U8]](defs)
  }
}
fun push_builtin_fun(defs: Vec[AstDef], name: Slice[U8], args: Vec[AstFunArg], returns: Type) {
  defs.push(AstFun {
    name,
    type_args = vec[Slice[U8]](),
    args,
    returns,
    is_builtin = true(),
    body = vec[AstExpr](),
  })
}
fun format_error_with_context(code: Slice[U8], offset: U64, error: Slice[U8]): Slice[U8] {
  var lines = vec[Vec[U8]]()
  var current_line = vec[U8]()
  var offset_in_line = 0
  for i in 0.to(code.len) do {
    if i.equals(offset) then offset_in_line = current_line.len
    if code.get(i).equals(newline())
    then {
      lines.append(current_line)
      current_line = vec[U8]()
      if i.is_at_least(offset) then break
    }
    else current_line.push(code.get(i))
  }
  | Now, lines contains all lines up to the line that contains the
  | error. offset_in_line is the offset into the last complete line.
  var num_lines_to_display = min(lines.len, 4)
  var out = vec[U8]()
  for line_number in lines.len.subtract(num_lines_to_display).to(lines.len) do {
    out.write(line_number.inc())
    out.write_str(" | ")
    out.write_str(lines.get(line_number))
    out.write_char(newline())
  }
  for i in 0.to(7 + offset_in_line) out.write_char(' )
  out.write_char('^)
  out.write_char(newline())
  for i in 0.to(7 + offset_in_line) out.write_char(' )
  out.write_str(error)
  error.to_slice()
}

| Command Line Interface  
| The command line interface which you use to interact with the Martinaise
| compiler.

enum Command { ast, mono, compile, run, watch }
fun parse_command(command: Slice[U8]): Command {
  if command.equals("ast") then return Command.ast
  if command.equals("mono") then return Command.mono
  if command.equals("compile") then return Command.compile
  if command.equals("run") then return Command.run
  if command.equals("watch") then return Command.watch
}

| Runs the pipeline that matches the command. Errors are handled internally
| (stuff is printed to stdout). Returns whether it ran through successfully.
fun run_pipeline(): Bool {
  var stdlib_size = 0
  var input = {
    print_on_same_line({
      var out = vec[U8]()
      out.write_str("Reading ")
      out.write_str(file_path)
      out
    })

    var stdlib = read_file("stdlib.mar")
    var file = read_file(file_path)
    stdlib_size = stdlib.len

    var input = vec[U8]()
    input.write(stdlib)
    input.write(newline())
    input.write(file)
    input.write(newline())
  }

  var ast = {
    print_on_same_line({
      var out = vec[U8]()
      out.write_str("Parsing ")
      out.write_str(file_path)
      out
    })
    switch parse(input, stdlib_size)?
    case ok(ast) ast
    case err(err) { printsln(err) return false() }
  }
  if command is ast then { println(ast) return true() }

  true()
}

fun main() {
  printsln("Welcome to Martinaise.")

  | TODO: Add CLI parsing
  var command = Command.ast
  var file_path = "advent/day1.mar"

  exit(if run_pipeline(command, file_path) then 0 else 1)
}
