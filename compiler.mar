| The Martinaise Compiler  
| This is the compiler for Martinaise, written in Martinaise.
| TODO: This is far from finished.
| 
| Glossary  
| arg  = argument
| args = arguments
| def  = definition
| env  = environment
| expr = expression
| fun  = function
| init = initialize
| str  = string

| Terminal utilities  

fun clear_terminal() {
  todo()
  | var clear = std.ChildProcess.init(&[_]Str{"clear"}, alloc)
  | clear.stdout = std.io.getStdOut()
  | clear.stderr = std.io.getStdErr()
  | _ = try clear.spawnAndWait()
}

fun print_on_same_line(message: Slice[U8]) {
  | \x1b[1A\x1b[K
  stdout().write_byte(27_U8)
  prints("[1A")
  stdout().write_byte(27_U8)
  prints("[K")
  printsln(message)
}

| Types  
| Types such as Int or Slice[&U8] are fundamental to Martinaise. In the
| compiler, they are represented as a tree. For example, the Slice[&U8] type is
| represented like this:
|
| Type { name = "Slice", args = [
|   Type { name = "&", args = [
|     Type { name = "U8", args = [] }
|   ] }
| ] }
|
| This representation of types is used throughout the AST and Mono stage of the
| compiler.
struct Type { name: Slice[U8], args: Vec[Type] }
fun type(name: Slice[U8]): Type { Type { name, args = vec[Type]() } }
fun write[W](writer: W, type: Type) {
  writer.write_str(type.name)
  if type.name.equals("&")
  then writer.write(type.args.get(0))
  else writer.write_type_args(type.args)
}
fun write_type_args[W](writer: W, args: Vec[Type]) {
  if args.is_empty() then return {}
  writer.write_char('[)
  var first = true()
  for arg in args do {
    if first then first = false() else writer.write_str(", ")
    writer.write(arg)
  }
  writer.write_char('])
}
fun write_type_args[W](writer: W, args: Vec[Slice[U8]]) {
  if args.is_empty() then return {}
  writer.write_char('[)
  var first = true()
  for arg in args do {
    if first then first = false() else writer.write_str(", ")
    writer.write_str(arg)
  }
  writer.write_char('])
}

| Numbers  
| Numbers such as U8 or I32 are special in Candy. These numbers and mathematical
| functions for them are magically in scope. Because multiple stages of the
| compiler work with numbers, here are some shared concepts.
enum Signedness { signed, unsigned }
struct IntConfig { signedness: Signedness, bits: U64 }
fun to_char(s: Signedness): U8 { switch s case signed 'I case unsigned 'U }
fun all_signednesses(): Vec[Signedness] {
  vec(Signedness.signed, Signedness.unsigned)
}
fun all_bits(): Vec[U64] { vec(8, 16, 32, 64) }
fun all_int_configs(): Vec[IntConfig] {
  var configs = vec[IntConfig]()
  for signedness in all_signednesses() do
    for bits in all_bits() do
      configs.&.push(IntConfig { signedness, bits })
  configs
}
fun equals(a: Signedness, b: Signedness): Bool {
  a.to_char().equals(b.to_char())
}
fun equals(a: IntConfig, b: IntConfig): Bool {
  a.signedness.equals(b.signedness).and(a.bits.equals(b.bits))
}
fun to_type(config: IntConfig): Type {
  var name = vec[U8]()
  name.&.write_char(config.signedness.to_char())
  name.&.write(config.bits)
  type(name.to_slice())
}

| The Abstract Syntax Tree  
| The compiler input is parsed into an abstract syntax tree. This tree is a
| representation of the program that roughly corresponds to the structure of the
| source code.
struct Ast { defs: Vec[AstDef] }
enum AstDef {
  builtin_type: Type, | not parsed from code
  struct_: AstStruct,
  enum_: AstEnum,
  fun_: AstFun,
}
struct AstStruct {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  fields: Vec[AstStructField],
}
struct AstStructField { name: Slice[U8], type: Type }
struct AstEnum {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  variants: Vec[AstEnumVariant],
}
struct AstEnumVariant { name: Slice[U8], type: Type }
struct AstFun {
  name: Slice[U8],
  type_args: Vec[Slice[U8]],
  args: Vec[AstFunArg],
  returns: Type,
  is_builtin: Bool,
  body: Vec[AstExpr],
}
struct AstFunArg { name: Slice[U8], type: Type }
enum AstExpr {
  int: AstInt, | 0_U64
  str: Slice[U8], | "foo"
  name: Slice[U8], | foo
  type_arged: AstTypeArged, | ...[T] | TODO: remove
  call: AstCall, | ...(arg)
  make_struct: AstInitStruct, | Foo { a = ... }
  make_enum: AstInitEnum, | Maybe.some(5)
  member: AstMember, | foo.bar
  var_: AstVar, | var foo = ...
  assign: AstAssign, | foo = ...
  switch_: AstSwitch, | switch foo case a ... case b(bar) ...
  loop_: &AstExpr, | loop ...
  break_,
  continue_,
  return_: &AstExpr, | return ...
  body: Vec[AstExpr], | { ... }
}
struct AstInt { value: U64, signedness: Signedness, bits: U64 }
struct AstTypeArged { expr: &AstExpr, type_args: Vec[Type] }
struct AstCall { callee: &AstExpr, args: Vec[AstExpr] }
struct AstInitStruct { type: Type, fields: Vec[AstInitStructField] }
struct AstInitStructField { name: Slice[U8], value: AstExpr }
struct AstInitEnum { type: Type, variant: Slice[U8], arg: &AstExpr }
struct AstMember { of: &AstExpr, name: Slice[U8] }
struct AstVar { name: Slice[U8], value: &AstExpr }
struct AstAssign { to: &AstExpr, value: &AstExpr }
struct AstSwitch { value: &AstExpr, cases: Vec[AstCase], default_: Maybe[&AstExpr] }
struct AstCase { variant: Slice[U8], binding: Maybe[Slice[U8]], then_: &AstExpr }

fun call(expr: AstExpr, args: Vec[AstExpr]): AstExpr {
  AstExpr.call(AstCall { callee = expr.put_on_heap(), args })
}
fun member(expr: AstExpr, name: Slice[U8]): AstExpr {
  AstExpr.member(AstMember { of = expr.put_on_heap(), name })
}
fun var_(name: Slice[U8], value: AstExpr): AstExpr {
  AstExpr.var_(AstVar { name, value = value.put_on_heap() })
}

fun write[W](writer: W, program: Ast) {
  for def in program.defs do { writer.write(def) writer.write_char(newline()) }
}
fun write[W](writer: W, def: AstDef) {
  switch def
  case builtin_type(type) {
    writer.write_str("builtin ")
    writer.write(type)
  }
  case struct_(s) writer.write(s)
  case enum_(e) writer.write(e)
  case fun_(f) writer.write(f)
}
fun write_signature[W](writer: W, def: Def) {
  switch def
  case struct_(s) {
    writer.write_str("struct ")
    writer.write_str(s.name)
    writer.write_type_args(s.type_args)
  }
  case enum_(e) {
    writer.write_str("enum ")
    writer.write_str(e.name)
    writer.write_type_args(e.type_args)
  }
  case fun_(f) {
    writer.write_str(f.name)
    writer.write_type_args(f.type_args)
    writer.write_char('()
    var first = true()
    for arg in f.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(arg.type)
    }
    writer.write_char('))
  }
}
fun write[W](writer: W, s: AstStruct) {
  writer.write_str("struct ")
  writer.write_str(s.name)
  writer.write_type_args(s.type_args)
  if s.fields.is_empty() then writer.write_str(" {}") else {
    writer.write_str(" {")
    writer.write_char(newline())
    for field in s.fields do {
      writer.write_str("  ")
      writer.write_str(field.name)
      writer.write_str(": ")
      writer.write(field.type)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_char('})
  }
}
fun write[W](writer: W, e: AstEnum) {
  writer.write_str("enum ")
  writer.write_str(e.name)
  writer.write_type_args(e.type_args)
  if e.variants.is_empty() then writer.write_str(" {}") else {
    writer.write_str(" {")
    writer.write_char(newline())
    for variant in e.variants do {
      writer.write_str("  ")
      writer.write_str(variant.name)
      writer.write_str(": ")
      writer.write(variant.type)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_char('})
  }
}
fun write[W](writer: W, f: AstFun) {
  writer.write_str("fun ")
  writer.write_str(f.name)
  writer.write_type_args(f.type_args)
  writer.write_char('()
  var first = true()
  for arg in f.args do {
    if first then first = false() else writer.write_str(", ")
    writer.write_str(arg.name)
    writer.write_str(": ")
    writer.write(arg.type)
  }
  writer.write_str("): ")
  writer.write(f.returns)
  writer.write_str(" ")
  if f.is_builtin
  then writer.write_str("{ ... }")
  else writer.write_body(0, f.body)
}
fun write_indent[W](writer: W, indent: U64) {
  for i in 0.to(indent.multiply(2)) do writer.write_char(' )
}
fun write_body[W](writer: W, indent: U64, body: Vec[AstExpr]) {
  if body.is_empty() then {
    writer.write_str("{}")
    return {}
  }
  writer.write_char('{)
  writer.write_char(newline())
  for expr in body do {
    writer.write_indent(indent.inc())
    writer.write(indent.inc(), expr)
    writer.write_char(newline())
  }
  writer.write_indent(indent)
  writer.write_char('})
}
fun write[W](writer: W, indent: U64, expr: AstExpr) {
  switch expr
  case int(int) {
    writer.write(int.value)
    writer.write_char('_)
    writer.write_char(int.signedness.to_char())
    writer.write(int.bits)
  }
  case str(str) {
    writer.write_char('")
    writer.write_str(str)
    writer.write_char('")
  }
  case name(name) writer.write_str(name)
  case type_arged(type_arged) {
    writer.write(indent, type_arged.expr.*)
    writer.write_type_args(type_arged.type_args)
  }
  case call(call) {
    writer.write(indent, call.callee.*)
    writer.write_char('()
    var first = true()
    for arg in call.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(indent, arg)
    }
    writer.write_char('))
  }
  case make_struct(struct_) {
    writer.write(struct_.type)
    writer.write_str(" {")
    writer.write_char(newline())
    for field in struct_.fields do {
      writer.write_indent(indent.inc())
      writer.write_str(field.name)
      writer.write_str(" = ")
      writer.write(indent.inc(), field.value)
      writer.write_char(',)
      writer.write_char(newline())
    }
    writer.write_indent(indent)
    writer.write_str("}")
  }
  case make_enum(enum_) {
    writer.write(enum_.type)
    writer.write_str(".")
    writer.write_str(enum_.variant)
    writer.write_str("(")
    writer.write(indent, enum_.arg.*)
    writer.write_str(")")
  }
  case member(member) {
    writer.write(indent, member.of.*)
    writer.write_char('.)
    writer.write_str(member.name)
  }
  case var_(var_) {
    writer.write_str("var ")
    writer.write_str(var_.name)
    writer.write_str(" = ")
    writer.write(indent, var_.value.*)
  }
  case assign(assign) {
    writer.write(indent, assign.to.*)
    writer.write_str(" = ")
    writer.write(indent, assign.value.*)
  }
  case switch_(switch_) {
    writer.write_str("switch ")
    writer.write(indent, switch_.value.*)
    for case_ in switch_.cases do {
      writer.write_char(newline())
      writer.write_indent(indent)
      writer.write_str("case ")
      writer.write_str(case_.variant)
      if case_.binding is some(binding) then {
        writer.write_char('()
        writer.write_str(binding)
        writer.write_char('))
      }
      writer.write_str(" ")
      writer.write(indent, case_.then_.*)
    }
    if switch_.default_ is some(default_) then {
      writer.write_char(newline())
      writer.write_indent(indent)
      writer.write_str("default ")
      writer.write(indent, default_.*)
    }
  }
  case loop_(expr) {
    writer.write_str("loop ")
    writer.write(indent, expr.*)
  }
  case break_ writer.write_str("break")
  case continue_ writer.write_str("continue")
  case return_(return_) {
    writer.write_str("return ")
    writer.write(indent, return_.*)
  }
  case body(body) writer.write_body(indent, body)
}

| Parsing  
| Unlike the parser in Candy (github.com/candy-lang/candy), the Martinaise
| parser favors simplicity over robustness. The first time it encounters an
| error, it simply gives up. This also means that for invalid code, you'll only
| get the first syntax error reported.
| 
| The parser is structured as a recursive descent parser: Lots of little
| functions call each other, each parsing a specific syntax, and all operate
| with a common cursor. Almost all parser functions return
| Result[Maybe[...], Str], where the return value has this meaning:
|
| - ok(none): The parser function doesn't match what comes next in the input.
|   The cursor remains unchanged.
| - ok(some(...)): The parsing was successful. The result is in the return
|   value.
| - error(...): The input is invalid. The entire parser should give up. The
|   cursor is at the position where the error in the input is.
|
| For example, here are possible results of the parse_number function:
|
| input         | "abc"    | "42 foo"     | "42foo"
| cursor before |  ^       |  ^           |  ^
| cursor after  |  ^       |    ^         |    ^
| result        | ok(none) | ok(some(42)) | error("Expected another digit.")
|
| - In the first case, the parser didn't match because the input doesn't start
|   with a digit.
| - In the second case, the parser does match, and it successfully parses the
|   number, moving the cursor after the number.
| - In the third case, the input starts with a digit – unmistakably a number!
|   However, because it has a lowercase letter in it, it's invalid and results
|   in an error. This is an invalid program.
|
| Whitespace is automatically consumed by the fundamental parsers. This is done
| because Martinaise generally doesn't care about whitespace and it makes the
| code of the higher-level parsers (structs, enums, etc.) much more concise.

struct Parser { code: Slice[U8], cursor: U64 }

fun current(parser: Parser): U8 { parser.code.get(parser.cursor) }
fun rest(parser: Parser): Slice[U8] { parser.code.subslice(parser.cursor) }
fun advance(parser: &Parser) { parser.advance_by(1) }
fun advance_by(parser: &Parser, n: U64) { parser.cursor = parser.cursor.add(n) }
| TODO: move into stdlib
fun is_whitespace(char: U8): Bool {
  char.equals(' ).or(char.equals(tab())).or(char.equals(newline()))
}

fun consume_whitespace(parser: &Parser) {
  loop {
    if parser.cursor.is_at_least(parser.code.len) then break
    var char = parser.current()
    if char.is_whitespace() then {
      parser.cursor = parser.cursor.inc()
      continue
    }
    if char.equals('|) then {
      loop {
        if parser.cursor.is_at_least(parser.code.len) then break
        if parser.current().equals(newline()) then break
        parser.cursor = parser.cursor.inc()
      }
      continue
    }
    break | not a whitespace nor comment
  }
}

fun consume_prefix(parser: &Parser, prefix: Slice[U8]): Maybe[Nothing] {
  parser.consume_whitespace()
  if not(parser.rest().starts_with(prefix)) then return none[Nothing]()
  parser.advance_by(prefix.len)
  some({})
}

| Also makes sure there's a whitespace following, so consume_keyword("fun")
| doesn't match the code "funny".
fun consume_keyword(parser: &Parser, keyword: Slice[U8]): Maybe[Nothing] {
  parser.consume_whitespace()
  if not(parser.rest().starts_with(keyword)) then return none[Nothing]()
  if parser.rest().len.is_greater_than(keyword.len) then {
    var char_after = parser.rest().get(keyword.len)
    if not(char_after.is_whitespace().or(char_after.equals('|))) then
      return none[Nothing]()
  }
  parser.advance_by(keyword.len)
  some({})
}

fun parse_name(parser: &Parser): Maybe[Slice[U8]] {
  var start = parser.cursor
  loop {
    var char = parser.current()
    if 'A.until('Z).contains(char).or('a.until('z).contains(char)).or(char.equals('_))
    then { parser.advance() continue }
    if '0.until('9).contains(char) then
      if parser.cursor.equals(start)
      then break
      else { parser.advance() continue }
    break
  }
  if parser.cursor.equals(start) then return none[Slice[U8]]()
  some(parser.code.subslice(start, parser.cursor))
}

fun parse_lower_name(parser: &Parser): Maybe[Slice[U8]] {
  parser.consume_whitespace()
  if not('a.until('z).contains(parser.current())) then return none[Slice[U8]]()
  parser.parse_name()
}

fun parse_upper_name(parser: &Parser): Maybe[Slice[U8]] {
  parser.consume_whitespace()
  if not('A.until('Z).contains(parser.current())) then return none[Slice[U8]]()
  parser.parse_name()
}

| Convenience methods for the three possible results of parsers returning a
| Result[Maybe[T]].
| alias ParseResult[T] = Result[Maybe[T], Slice[U8]]
fun bad_input[T](error: Slice[U8]): Result[Maybe[T], Slice[U8]] {
  error[Maybe[T], Slice[U8]](error)
}
fun no_match[T](): Result[Maybe[T], Slice[U8]] {
  ok[Maybe[T], Slice[U8]](none[T]())
}
fun parsed[T](val: T): Result[Maybe[T], Slice[U8]] {
  ok[Maybe[T], Slice[U8]](some(val))
}

fun parse_type(parser: &Parser): Result[Maybe[Type], Slice[U8]] {
  if parser.consume_prefix("&") is some then {
    var arg = parser.parse_type()?
      orelse return bad_input[Type]("After &, there must come a type.")
    return parsed(Type { name = "&", args = vec(arg) })
  }

  var name = parser.parse_upper_name() orelse return no_match[Type]()
  var args = parser.parse_type_args()? orelse vec[Type]()
  parsed(Type { name, args })
}

fun parse_type_args(parser: &Parser): Result[Maybe[Vec[Type]], Slice[U8]] {
  var args = vec[Type]()
  parser.consume_prefix("[") orelse return no_match[Vec[Type]]()
  loop {
    var arg = parser.parse_type()? orelse break
    args.&.push(arg)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("]") orelse return bad_input[Vec[Type]](
    "Expected a closing bracket to end the type arguments.")
  parsed(args)
}

fun parse_type_params(parser: &Parser): Result[Maybe[Vec[Slice[U8]]], Slice[U8]] {
  var args = vec[Slice[U8]]()
  parser.consume_prefix("[") orelse return no_match[Vec[Slice[U8]]]()
  loop {
    var arg = parser.parse_upper_name() orelse break
    args.&.push(arg)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("]") orelse return bad_input[Vec[Slice[U8]]](
    "Expected a closing bracket to end the type arguments.")
  parsed(args)
}

| TODO: explanation
fun parse_expr(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var expr = parser.parse_expr_without_suffix()?
    orelse return no_match[AstExpr]()
  loop
    switch parser.parse_expr_suffix(expr)? case some(e) expr = e case none break
  parsed(expr)
}
fun parse_expr_without_suffix(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  if parser.parse_int()? is some(i) then return parsed(i)
  if parser.parse_char()? is some(c) then return parsed(c)
  if parser.parse_str()? is some(s) then return parsed(s)
  if parser.parse_make()? is some(s) then return parsed(s)
  if parser.parse_body()? is some(b) then return parsed(AstExpr.body(b))
  if parser.parse_var()? is some(v) then return parsed(v)
  if parser.parse_if()? is some(i) then return parsed(i)
  if parser.parse_switch()? is some(s) then return parsed(s)
  if parser.parse_loop()? is some(l) then return parsed(l)
  if parser.parse_for()? is some(f) then return parsed(f)
  if parser.parse_return()? is some(r) then return parsed(r)
  if parser.parse_lower_name() is some(n) then return parsed(AstExpr.name(n))
  no_match[AstExpr]()
}
fun parse_expr_suffix(parser: &Parser, expr: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  if parser.parse_expr_suffix_member(expr)? is some(m) then return parsed(m)
  if parser.parse_expr_suffix_call(expr)? is some(c) then return parsed(c)
  if parser.parse_expr_suffix_type_arged(expr)? is some(t) then return parsed(t)
  if parser.parse_expr_suffix_assign(expr)? is some(a) then return parsed(a)
  if parser.parse_expr_suffix_orelse(expr)? is some(o) then return parsed(o)
  no_match[AstExpr]()
}

fun parse_digits(parser: &Parser): Result[Maybe[U64], Slice[U8]] {
  parser.consume_whitespace()
  var start = parser.cursor
  var num = 0
  loop {
    var char = parser.current()
    if '0.until('9).contains(char) then {
      num = num.multiply(10).add(char.subtract('0).to_U64()) | TODO: put in stdlib
      parser.advance()
    }
    else if char.equals('_) then parser.advance()
    else break
  }
  if parser.cursor.equals(start) then return no_match[U64]()
  if parser.code.get(parser.cursor.dec()).equals('_)
  then parser.cursor = parser.cursor.dec()
  parsed(num)
}

fun parse_int(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var value = parser.parse_digits()? orelse return no_match[AstExpr]()
  parser.consume_prefix("_")
    orelse return parsed(AstExpr.int(
      AstInt { value, signedness = Signedness.unsigned, bits = 64 }))
  var signedness =
    if parser.consume_prefix("I") is some then Signedness.signed
    else if parser.consume_prefix("U") is some then Signedness.unsigned
    else return bad_input[AstExpr]("Expected a signedness (U or I).")
  var bits = parser.parse_digits()?
    orelse return bad_input[AstExpr]("Expected bit length of the integer.")
  | TODO: check that number fits in range
  parsed(AstExpr.int(AstInt { value, signedness, bits }))
}

fun parse_char(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("'") orelse return no_match[AstExpr]()
  var char = parser.current()
  parser.advance()
  parsed(AstExpr.int(AstInt {
    value = char.to_U64(),
    signedness = Signedness.unsigned,
    bits = 8,
  }))
}

fun parse_str(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  if parser.current().not_equals('") then return no_match[AstExpr]()
  parser.advance()
  var start = parser.cursor
  loop if parser.current().equals('") then break else parser.advance()
  parser.advance()
  parsed(AstExpr.str(parser.code.subslice(start, parser.cursor.dec())))
}

fun parse_make(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  var type = parser.parse_type()? orelse return no_match[AstExpr]()
  if parser.consume_prefix("{") is some then {
    var fields = vec[AstInitStructField]()
    loop {
      var name = parser.parse_lower_name() orelse break
      var value =
        if parser.consume_prefix("=") is some
        then parser.parse_expr()?
          orelse return bad_input[AstExpr]("Expected the value of the field.")
        else AstExpr.name(name)
      fields.&.push(AstInitStructField { name, value })
      parser.consume_prefix(",") orelse break
    }
    parser.consume_prefix("}")
      orelse return bad_input[AstExpr]("Expected a closing brace.")
    parsed(AstExpr.make_struct(AstInitStruct { type, fields }))
  } else {
    parser.consume_prefix(".")
      orelse return bad_input[AstExpr](
        "Expected struct or enum creation.")
    var variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected the variant.")
    
    var arg = AstExpr.body(vec[AstExpr]())
    if parser.consume_prefix("(") is some then {
      arg = parser.parse_expr()?
        orelse return bad_input[AstExpr](
          "Expected an argument for the variant.")
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
    parsed(AstExpr.make_enum(
      AstInitEnum { type, variant, arg = arg.put_on_heap() }))
  }
}

fun parse_body(parser: &Parser): Result[Maybe[Vec[AstExpr]], Slice[U8]] {
  parser.consume_prefix("{") orelse return no_match[Vec[AstExpr]]()
  var statements = vec[AstExpr]()
  loop switch parser.parse_expr()?
  case some(e) statements.&.push(e)
  case none break
  parser.consume_prefix("}")
    orelse return bad_input[Vec[AstExpr]](
      "Expected the closing brace of the body.")
  parsed(statements)
}

fun parse_var(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("var") orelse return no_match[AstExpr]()
  var name = parser.parse_lower_name()
    orelse return bad_input[AstExpr]("Expected the name of the variable.")
  parser.consume_prefix("=")
    orelse return bad_input[AstExpr]("Expected an equals sign.")
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected the value of the variable.")
  parsed(AstExpr.var_(AstVar { name, value = value.put_on_heap() }))
}

fun parse_if(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("if") orelse return no_match[AstExpr]()
  var condition = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected the condition.")
  var variant = "true"
  var binding = none[Slice[U8]]()
  if parser.consume_keyword("is") is some then {
    variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected a variant.")
    if parser.consume_prefix("(") is some then {
      binding = some(parser.parse_lower_name()
        orelse return bad_input[AstExpr]("Expected the name of the binding."))
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
  }
  parser.consume_keyword("then")
    orelse return bad_input[AstExpr]("Expected then keyword.")
  var then_ = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected a then expression.")
  var else_ = AstExpr.body(vec[AstExpr]())
  if parser.consume_keyword("else") is some
  then else_ = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected an else expression.")
  parsed(AstExpr.switch_(AstSwitch {
    value = condition.put_on_heap(),
    cases = vec(AstCase { variant, binding, then_ = then_.put_on_heap() }),
    default_ = some(else_.put_on_heap()),
  }))
}

fun parse_switch(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("switch") orelse return no_match[AstExpr]()
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected the value that is switched over.")
  var cases = vec[AstCase]()
  loop {
    parser.consume_keyword("case") orelse break
    var variant = parser.parse_lower_name()
      orelse return bad_input[AstExpr]("Expected a variant.")
    var binding = none[Slice[U8]]()
    if parser.consume_prefix("(") is some then {
      binding = some(parser.parse_lower_name()
        orelse return bad_input[AstExpr]("Expected the name of the binding."))
      parser.consume_prefix(")")
        orelse return bad_input[AstExpr]("Expected a closing parenthesis.")
    }
    var then_ = parser.parse_expr()?
        orelse return bad_input[AstExpr]("Expected a case expression.")
    cases.&.push(AstCase { variant, binding, then_ = then_.put_on_heap() })
  }
  var default_ = none[&AstExpr]()
  if parser.consume_keyword("default") is some
  then {
    var default__ = parser.parse_expr()?
      orelse return bad_input[AstExpr]("Expected a default expression.")
    default_ = some(default__.put_on_heap())
  }
  parsed(AstExpr.switch_(AstSwitch {
    value = value.put_on_heap(),
    cases,
    default_
  }))
}

fun parse_loop(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("loop") orelse return no_match[AstExpr]()
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected loop expression.")
  parsed(AstExpr.loop_(expr.put_on_heap()))
}

fun parse_for(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("for") orelse return no_match[AstExpr]()
  var iter_var = parser.parse_lower_name()
    orelse return bad_input[AstExpr](
      "Expected the name of the iteration variable.")
  parser.consume_keyword("in")
    orelse return bad_input[AstExpr]("Expected in keyword.")
  var iter = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected something to iterate over.")
  parser.consume_keyword("do")
    orelse return bad_input[AstExpr]("Expected do keyword.")
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected a loop expression.")
  parsed(AstExpr.body(vec(
    var_("$iter", iter.member("iter").call(vec[AstExpr]()).member("&")),
    AstExpr.loop_(AstExpr.body(vec(
      var_(iter_var, AstExpr.switch_(AstSwitch {
        value = AstExpr.name("$iter").member("next").call(vec[AstExpr]())
          .put_on_heap(),
        cases = vec(
          AstCase {
            variant = "some",
            binding = some("a"),
            then_ = AstExpr.name("a").put_on_heap()
          },
          AstCase {
            variant = "none",
            binding = none[Slice[U8]](),
            then_ = AstExpr.break_.put_on_heap(),
          },
        ),
        default_ = none[&AstExpr](),
      })),
      expr,
    )).put_on_heap())
  )))
}

fun parse_return(parser: &Parser): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("return") orelse return no_match[AstExpr]()
  var expr = parser.parse_expr()?
    orelse return bad_input[AstExpr]("Expected returned expression.")
  parsed(AstExpr.return_(expr.put_on_heap()))
}

fun parse_expr_suffix_member(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix(".") orelse return no_match[AstExpr]()
  if parser.consume_prefix("*") is some then return parsed(current.member("*"))
  if parser.consume_prefix("&") is some then return parsed(current.member("&"))
  if parser.parse_lower_name() is some(name)
  then return parsed(current.member(name))
  return bad_input[AstExpr]("Expected the name of a member.")
}

fun parse_expr_suffix_call(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("(") orelse return no_match[AstExpr]()
  var args = vec[AstExpr]()
  loop {
    args.&.push(parser.parse_expr()? orelse break)
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix(")")
    orelse return bad_input[AstExpr](
      "Expected closing parenthesis of the call.")
  parsed(current.call(args))
}

fun parse_expr_suffix_type_arged(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  var type_args = parser.parse_type_args()? orelse return no_match[AstExpr]()
  parsed(AstExpr.type_arged(AstTypeArged {
    expr = current.put_on_heap(),
    type_args,
  }))
}

fun parse_expr_suffix_assign(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_prefix("=") orelse return no_match[AstExpr]()
  var value = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected an expression on the right side of the assign.")
  parsed(AstExpr.assign(AstAssign {
    to = current.put_on_heap(),
    value = value.put_on_heap(),
  }))
}

fun parse_expr_suffix_orelse(parser: &Parser, current: AstExpr): Result[Maybe[AstExpr], Slice[U8]] {
  parser.consume_keyword("orelse") orelse return no_match[AstExpr]()
  var alternative = parser.parse_expr()?
    orelse return bad_input[AstExpr](
      "Expected alternative expression after orelse.")
  parsed(AstExpr.switch_(AstSwitch {
    value = current.put_on_heap(), | TODO: call some function
    cases = vec(
      AstCase {
        variant = "some",
        binding = some("a"),
        then_ = AstExpr.name("a").put_on_heap(),
      },
      AstCase {
        variant = "none",
        binding = none[Slice[U8]](),
        then_ = alternative.put_on_heap(),
      },
    ),
    default_ = none[&AstExpr](),
  }))
}

fun parse_fun(parser: &Parser): Result[Maybe[AstFun], Slice[U8]] {
  parser.consume_keyword("fun") orelse return no_match[AstFun]()
  var fun_name = parser.parse_lower_name()
    orelse return bad_input[AstFun]("Expected the name of the function.")
  var type_args = parser.parse_type_params()? orelse vec[Slice[U8]]()
  var args = vec[AstFunArg]()
  parser.consume_prefix("(")
    orelse return bad_input[AstFun]("Expected an opening parenthesis.")
  loop {
    var name = parser.parse_lower_name() orelse break
    parser.consume_prefix(":")
      orelse return bad_input[AstFun]("Expected a colon.")
    var type = parser.parse_type()?
      orelse return bad_input[AstFun]("Expected the type of the argument.")
    args.&.push(AstFunArg { name, type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix(")")
    orelse return bad_input[AstFun]("Expected a closing parenthesis.")
  var returns = type("Nothing")
  if parser.consume_prefix(":") is some
  then returns = parser.parse_type()?
    orelse return bad_input[AstFun]("Expected the return type.")
  var is_builtin = false()
  var body =
    switch parser.consume_prefix("{ ... }")
    case some { is_builtin = true() vec[AstExpr]() }
    case none parser.parse_body()?
      orelse return bad_input[AstFun]("Expected a function body.")
  parsed(AstFun { name = fun_name, type_args, args, returns, is_builtin, body })
}

fun parse_struct(parser: &Parser): Result[Maybe[AstStruct], Slice[U8]] {
  parser.consume_keyword("struct") orelse return no_match[AstStruct]()
  var name = parser.parse_upper_name()
    orelse return bad_input[AstStruct]("Expected an uppercase name.")
  var type_args = parser.parse_type_params()? orelse vec[Slice[U8]]()
  parser.consume_prefix("{")
    orelse return bad_input[AstStruct]("Expected an opening brace.")
  var fields = vec[AstStructField]()
  loop {
    var field_name = parser.parse_lower_name() orelse break
    parser.consume_prefix(":")
      orelse return bad_input[AstStruct]("Expected a colon.")
    var field_type = parser.parse_type()?
      orelse return bad_input[AstStruct]("Expected the type of the field.")
    fields.&.push(AstStructField { name = field_name, type = field_type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("}")
    orelse return bad_input[AstStruct](
      "Expected a closing brace to end the struct.")
  parsed(AstStruct { name, type_args, fields })
}

fun parse_enum(parser: &Parser): Result[Maybe[AstEnum], Slice[U8]] {
  parser.consume_keyword("enum") orelse {
    return no_match[AstEnum]()
  }
  var name = parser.parse_upper_name()
    orelse return bad_input[AstEnum]("Expected an uppercase name.")
  var type_args = parser.parse_type_params()? orelse vec[Slice[U8]]()
  parser.consume_prefix("{")
    orelse return bad_input[AstEnum]("Expected an opening brace.")
  var variants = vec[AstEnumVariant]()
  loop {
    var variant_name = parser.parse_lower_name() orelse break
    var variant_type = type("Nothing")
    if parser.consume_prefix(":") is some
    then variant_type = parser.parse_type()?
      orelse return bad_input[AstEnum]("Expected the type of the variant.")
    variants.&.push(AstEnumVariant { name = variant_name, type = variant_type })
    parser.consume_prefix(",") orelse break
  }
  parser.consume_prefix("}")
    orelse return bad_input[AstEnum](
      "Expected a closing brace to end the enum.")
  parsed(AstEnum { name, type_args, variants })
}

fun parse_def(parser: &Parser): Result[Maybe[AstDef], Slice[U8]] {
  if parser.parse_struct()? is some(s) then return parsed(AstDef.struct_(s))
  if parser.parse_enum()? is some(e) then return parsed(AstDef.enum_(e))
  if parser.parse_fun()? is some(f) then return parsed(AstDef.fun_(f))
  no_match[AstDef]()
}

fun parse_defs(parser: &Parser): Result[Vec[AstDef], Slice[U8]] {
  var defs = vec[AstDef]()
  loop switch parser.parse_def()? case some(d) defs.&.push(d) case none break
  if parser.cursor.is_less_than(parser.code.len)
  then return error[Vec[AstDef], Slice[U8]]("Expected a definition.")
  ok[Vec[AstDef], Slice[U8]](defs)
}

fun parse(code: Slice[U8], stdlib_size: U64): Result[Ast, Slice[U8]] {
  var parser = Parser { code, cursor = 0 }
  | TODO: Replace switch with catch/orelse
  switch parser.&.parse_defs()
  case error(error) {
    if parser.cursor.is_at_most(stdlib_size)
    then error[Ast, Slice[U8]](
      format_error_with_context(parser.code, parser.cursor, error))
    else error[Ast, Slice[U8]](format_error_with_context(
      parser.code.subslice(stdlib_size),
      parser.cursor.subtract(stdlib_size),
      error
    ))
  }
  case ok(defs) {
    | Add builtins
    | TODO: Explanation

    | struct &[T] { *: T }
    defs.&.push(AstDef.struct_(AstStruct {
      name = "&",
      type_args = vec("T"),
      fields = vec(AstStructField { name = "*", type = type("T") })
    }))

    | Int stuff
    for config in all_int_configs() do {
      var type = config.to_type()
      defs.&.push(AstDef.builtin_type(type))

      var two_args = vec(
        AstFunArg { name = "a", type },
        AstFunArg { name = "b", type },
      )
      defs.&.push_builtin_fun("add", two_args, type)
      defs.&.push_builtin_fun("subtract", two_args, type)
      defs.&.push_builtin_fun("multiply", two_args, type)
      defs.&.push_builtin_fun("divide", two_args, type)
      defs.&.push_builtin_fun("modulo", two_args, type)
      defs.&.push_builtin_fun("compare_to", two_args, type("Ordering"))
      defs.&.push_builtin_fun("shiftLeft", two_args, type)
      defs.&.push_builtin_fun("shiftRight", two_args, type)
      defs.&.push_builtin_fun("bitLength", two_args, type)
      defs.&.push_builtin_fun("and", two_args, type)
      defs.&.push_builtin_fun("or", two_args, type)
      defs.&.push_builtin_fun("xor", two_args, type)

      | Conversion function
      for target_config in all_int_configs() do {
        if config.not_equals(target_config) then {
          var target_type = target_config.to_type()
          var name = vec[U8]()
          name.&.write_str("to_")
          name.&.write(target_type)
          defs.&.push_builtin_fun(name.to_slice(), vec(AstFunArg { name = "i", type }), target_type)
        }
      }
    }

    ok[Ast, Slice[U8]](Ast { defs })
  }
}
fun push_builtin_fun(defs: &Vec[AstDef], name: Slice[U8], args: Vec[AstFunArg], returns: Type) {
  defs.push(AstDef.fun_(AstFun {
    name,
    type_args = vec[Slice[U8]](),
    args,
    returns,
    is_builtin = true(),
    body = vec[AstExpr](),
  }))
}
fun format_error_with_context(code: Slice[U8], offset: U64, error: Slice[U8]): Slice[U8] {
  var lines = vec[Vec[U8]]()
  var current_line = vec[U8]()
  var offset_in_line = 0
  for i in 0.to(code.len) do {
    if i.equals(offset) then offset_in_line = current_line.len
    if code.get(i).equals(newline())
    then {
      lines.&.push(current_line)
      current_line = vec[U8]()
      if i.is_at_least(offset) then break
    }
    else current_line.&.push(code.get(i))
  }
  | Now, lines contains all lines up to the line that contains the
  | error. offset_in_line is the offset into the last complete line.
  var num_lines_to_display = min(lines.len, 4)
  var out = vec[U8]()
  for line_number in lines.len.subtract(num_lines_to_display).to(lines.len) do {
    out.&.write_line_number(line_number.inc())
    out.&.write_str(" | ")
    out.&.write_str(lines.get(line_number).to_slice())
    out.&.write_char(newline())
  }
  for i in 0.to(7.add(offset_in_line)) do out.&.write_char(' )
  out.&.write_char('^)
  out.&.write_char(newline())
  for i in 0.to(7.add(offset_in_line)) do out.&.write_char(' )
  out.&.write_str(error)
  out.to_slice()
}
fun write_line_number[W](writer: W, n: U64) {
  if n.is_at_least(1000) then writer.write(n)
  else if n.is_at_least(100) then { writer.write_str(" ") writer.write(n) }
  else if n.is_at_least(10) then { writer.write_str("  ") writer.write(n) }
  else { writer.write_str("   ") writer.write(n) }
}

| Mono  
| Generic code such as a function foo[T]() doesn't have any generic
| representation in the final output. Instead, for every place where foo is
| called (every "callsite"), a new version of foo gets compiled. This process
| (called "monomorphization") enables useful programming patterns. For example,
| just by writing a compare_to function for a type, you can automatically use
| all other comparison functions. Generally speaking, monomorphized code also
| tends to be faster than general code.
|
| The Mono is the next stage in the compiler. Here, functions and types are
| monomorphized (aka they are not generic anymore). Only the functions and types
| that are reachable from the main function appear here – everything else is
| ignored. While the AST may contain invalid code (like 3 = 1), the Mono is
| guaranteed to be correct – during the monomorphization, variable scoping, name
| lookups, and type checking take place.

struct Mono { type_defs: Map[Type, MonoTypeDef], funs: Map[Slice[U8], MonoFun] }
enum MonoTypeDef {
  builtin_type,
  struct_: MonoStruct,
  enum_: MonoEnum,
}
struct MonoStruct { fields: Vec[MonoStructField] }
struct MonoStructField { name: Slice[U8], type: Type }
struct MonoEnum { variants: Vec[MonoEnumVariant] }
struct MonoEnumVariant { name: Slice[U8], type: Type }
struct MonoFun {
  type_args: Vec[Type],
  arg_types: Vec[Type],
  return_type: Type,
  is_builtin: Bool,
  body: Vec[MonoStatement],
}

enum MonoStatement {
  arg,
  expr: MonoExpr,
  uninitialized,
  assign: MonoAssign,
  int: MonoInt,
  string: MonoStr,
  make_struct: MonoMakeStruct,
  make_enum: MonoMakeEnum,
  call: MonoCall,
  jump: MonoJump,
  jump_if_variant: MonoJumpIfVariant,
  get_enum_value: MonoGetEnumValue,
  return_: MonoExpr,
  ref: MonoExpr,
}
struct MonoAssign { to: MonoExpr, value: MonoExpr }
struct MonoInt { value: U64, signedness: Signedness, bits: U64 }
struct MonoMakeEnum { type: Type, variant: Slice[U8], value: MonoExpr }
struct MonoMakeStruct { type: Type, fields: Map[Slice[U8], Expr] }
struct MonoCall { fun_: Slice[U8], args: Vec[MonoExpr] }
struct MonoJump { target: U64 }
struct MonoJumpIfVariant { condition: Expr, variant: Slice[U8], target: U64 }
struct MonoGetEnumValue { of: MonoExpr, variant: Slice[U8], type: Type }

struct MonoExpr { type: Type, kind: MonoExprKind }
enum MonoExprKind { statement: U64, member: MonoMember }
struct MonoMember { of: &MonoExpr, name: Slice[U8] }

fun write[W](writer: W, mono: Mono) {
  writer.write_str("Types:")
  writer.write_char(newline())
  | TODO: add keys and value iters to stdlib
  for entry in mono.type_defs do {
    writer.write_str("- ")
    writer.write_str(entry.key)
    writer.write_char(newline())
  }

  writer.write_str("Funs:")
  writer.write_char(newline())
  for entry in mono.funs do {
    writer.write(entry.key, entry.value)
    writer.write_char(newline())
  }
}
fun write[W](writer: W, name: Slice[U8], fun_: MonoFun) {
  writer.write_str(name)
  writer.write_char(newline())
  if fun_.is_builtin then { writer.write_str("  <builtin>") return {} }
  
  var first = true()
  var i = 0
  for statement in fun_.body do {
    if first then first = false() else writer.write_char(newline())
    writer.write_str("  _")
    writer.write(i)
    writer.write_str(" = ")
    writer.write(statement)
    i = i.inc()
  }
}
fun write[W](writer: W, statement: MonoStatement) {
  switch statement
  case arg writer.write_str("arg")
  case expr(expr) writer.write(expr)
  case uninitialized writer.write_str("uninitialized")
  case int(int) {
    writer.write(int.value)
    writer.write_char(int.signedness.to_char())
    writer.write(int.bits)
  }
  case str(str) {
    writer.write_char('")
    writer.write_str(str)
    writer.write_char('")
  }
  case call(call) {
    writer.write_str(call.fun_)
    writer.write_str(" called with (")
    var first = true()
    for arg in call.args do {
      if first then first = false() else writer.write_str(", ")
      writer.write(arg)
    }
    writer.write_str(")")
  }
  case make_struct(make_struct) {
    writer.write_str(make_struct.type)
    writer.write_str(" {")
    for field in make_struct.fields do {
      writer.write_str(" ")
      writer.write_str(field.name)
      writer.write_str(" = ")
      writer.write(field.value)
      writer.write_str(",")
    }
    writer.write_str(" }")
  }
  case make_enum(make_enum) {
    writer.write_str(make_enum.type)
    writer.write_str(".")
    writer.write_str(make_enum.variant)
    writer.write_str("(")
    writer.write(make_enum.arg)
    writer.write_str(")")
  }
  case assign(assign) {
    writer.write(assign.to)
    writer.write_str(" set to ")
    writer.write(assign.value)
  }
  case jump(jump) {
    writer.write_str("jump to _")
    writer.write(jump.target)
  }
  case jump_if_variant(jump) {
    writer.write_str("if _")
    writer.write(jump.condition)
    writer.write_str(" is ")
    writer.write(jump.variant)
    writer.write_str(", jump to _")
    writer.write(jump.target)
  }
  case get_enum_value(get_enum_value) {
    writer.write_str("get ")
    writer.write_str(get_enum_value.variant)
    writer.write_str(" value of ")
    writer.write(get_enum_value.of)
  }
  case return_(returned) {
    writer.write_str("return ")
    writer.write(returned)
  }
  case ref(expr) {
    writer.write(expr)
    writer.write_str(".&")
  }
}
fun write[W](writer: W, expr: MonoExpr) {
  switch expr.kind
  case statement(statement) {
    writer.write_str("_")
    writer.write(statement)
  }
  case member(member) {
    writer.write(member.of)
    writer.write_str(".")
    writer.write(member.name)
  }
}

| Monomorphization  

| pub const Fun = struct {
|     pub fn next_index(self: Self) StatementIndex {
|         return self.body.items.len;
|     }
|     pub fn put(self: *Self, statement: Statement, ty: Ty) !StatementIndex {
|         const index = self.body.items.len;
|         try self.body.append(statement);
|         try self.tys.append(ty);
|         return index;
|     }
|     pub fn put_and_get_expr(self: *Self, statement: Statement, ty: Ty) !Expr {
|         return .{ .kind = .{ .statement = try self.put(statement, ty) }, .ty = ty };
|     }
| };

fun specialize(type: Type, type_env: Map[Slice[U8], Type]): Type {
  | TODO: Make sure generic types don't have parameters.
  type_env.get(type.name) orelse {
    var args = vec[Ty]()
    for arg in type.args do args.&.push(arg.specialize(type_env))
    Type { name = type.name, args }
  }
}

| Command Line Interface  
| The command line interface which you use to interact with the Martinaise
| compiler.

enum Command { ast, mono, compile, run, watch }
fun parse_command(command: Slice[U8]): Command {
  if command.equals("ast") then return Command.ast
  if command.equals("mono") then return Command.mono
  if command.equals("compile") then return Command.compile
  if command.equals("run") then return Command.run
  if command.equals("watch") then return Command.watch
}

| Runs the pipeline that matches the command. Errors are handled internally
| (stuff is printed to stdout). Returns whether it ran through successfully.
fun run_pipeline(command: Command, file_path: Slice[U8]): Bool {
  var stdlib_size = 0
  var input = {
    print_on_same_line({
      var out = vec[U8]()
      out.&.write_str("Reading ")
      out.&.write_str(file_path)
      out.to_slice()
    })

    var stdlib = read_file("stdlib.mar")
    var file = read_file(file_path)
    stdlib_size = stdlib.len

    var input = vec[U8]()
    input.&.write_str(stdlib)
    input.&.write_char(newline())
    input.&.write_str(file)
    input.&.write_char(newline())
    input.to_slice()
  }

  var ast = {
    print_on_same_line({
      var out = vec[U8]()
      out.&.write_str("Parsing ")
      out.&.write_str(file_path)
      out.to_slice()
    })
    switch parse(input, stdlib_size)
    case ok(ast) ast
    case error(err) { printsln(err) return false() }
  }
  if command is ast then { println(ast) return true() }

  true()
}

fun main() {
  printsln("Welcome to Martinaise in Martinaise.")

  | TODO: Add CLI parsing
  var command = Command.ast
  var file_path = "advent/day1.mar"

  exit(if run_pipeline(command, file_path) then 0_U8 else 1_U8)
}
