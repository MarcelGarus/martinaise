| Welcome to Martinaise!
| This is the standard library. Be careful when deleting code here because this
| may crash the compiler.

| Nothing
| A type with only one instance. Functions that don't explicitly return a value
| return Nothing instead.
struct Nothing {}

| Never
| Some expressions always abort control flow, for example `return 3`. These
| evaluate to the Never type.
struct Never {} | TODO: Make this an enum

fun identity[T](value: T): T { value }

| Printing
| Values with a dump(writer) function can be printed. Writers are anything with
| a write(U8) function. The print function writes the dumped values to stdout
| using the builtin function print_to_stdout(U8).
struct StdoutWriter {}
fun write(sow: StdoutWriter, c: U8) { print_to_stdout(c) }
fun print[T](value: T) { value.dump(StdoutWriter.{}) }
fun println[T](value: T) { print(value) StdoutWriter.{}.write(10_u8) }

| Bool
enum Bool { true, false }
fun not(a: Bool): Bool { if a { Bool.false } else { Bool.true } }
fun and(a: Bool, b: Bool): Bool { if a { b } else { a } }
fun or(a: Bool, b: Bool): Bool { if a { Bool.true } else { b } }
fun xor(a: Bool, b: Bool): Bool { if a { not(b) } else { b } }
fun implies(a: Bool, b: Bool): Bool { if a { b } else { Bool.true } }
fun dump[W](b: Bool, writer: W) {
  if b {
    't.dump(writer)
    'r.dump(writer)
    'u.dump(writer)
    'e.dump(writer)
  } else {
    'f.dump(writer)
    'a.dump(writer)
    'l.dump(writer)
    's.dump(writer)
    'e.dump(writer)
  }
}

| Maybe
| Like Option in Rust, but with the cooler Haskell name.
enum Maybe[T] { some: T, none }
fun flatten[T](maybe: Maybe[Maybe[T]]): Maybe[T] {
  switch maybe {
    some(inner) { inner }
    none { Maybe[T].none() }
  }
}
fun dump[T, W](maybe: Maybe[T], writer: W) {
  switch maybe {
    some(val) {
      's.dump(writer)
      'o.dump(writer)
      'm.dump(writer)
      'e.dump(writer)
      '(.dump(writer)
      val.dump(writer)
      ').dump(writer)
    }
    none {
      'n.dump(writer)
      'o.dump(writer)
      'n.dump(writer)
      'e.dump(writer)
    }
  }
}

| Ordering
enum Ordering { less, equal, greater }
fun is_less(ord: Ordering): Bool {
  switch ord { less { Bool.true } equal { Bool.false } greater { Bool.false } }
}
fun is_equal(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.true } greater { Bool.false } }
}
fun is_greater(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.false } greater { Bool.true } }
}
fun is_less_or_equal(ord: Ordering): Bool {
  switch ord { less { Bool.true } equal { Bool.true } greater { Bool.false } }
}
fun is_greater_or_equal(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.true } greater { Bool.true } }
}
fun dump[W](ord: Ordering, writer: W) {
  switch ord {
    less {
      'l.dump(writer)
      'e.dump(writer)
      's.dump(writer)
      's.dump(writer)
    }
    equal {
      'e.dump(writer)
      'q.dump(writer)
      'u.dump(writer)
      'a.dump(writer)
      'l.dump(writer)
      's.dump(writer)
    }
    greater {
      'g.dump(writer)
      'r.dump(writer)
      'e.dump(writer)
      'a.dump(writer)
      't.dump(writer)
      'e.dump(writer)
      'r.dump(writer)
    }
  }
}

| Int
| Integers are built into the language. There are several types with different
| signedness and bit amount available as {U, I} x {8, 16, 32, 64}. For example,
| U64 is an unsigned integer of 64 bits.
| All integers also support the following mathematical operations:
| - add(Int, Int): Int
| - subtract(Int, Int): Int
| - multiply(Int, Int): Int
| - divide(Int, Int): Int
| - modulo(Int, Int): Int
| - compare_to(Int, Int): Ordering
| - to_<OtherInt>(Int): OtherInt, e.g. to_U8() for non-U8 ints
fun is_less_than(a: U8, b: U8): Bool { a.compare_to(b).is_less() }
fun equals(a: U8, b: U8): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U8, b: U8): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U8, b: U8): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U8, b: U8): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U16, b: U16): Bool { a.compare_to(b).is_less() }
fun equals(a: U16, b: U16): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U16, b: U16): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U16, b: U16): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U16, b: U16): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U32, b: U32): Bool { a.compare_to(b).is_less() }
fun equals(a: U32, b: U32): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U32, b: U32): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U32, b: U32): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U32, b: U32): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U64, b: U64): Bool { a.compare_to(b).is_less() }
fun equals(a: U64, b: U64): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U64, b: U64): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U64, b: U64): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U64, b: U64): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I8, b: I8): Bool { a.compare_to(b).is_less() }
fun equals(a: I8, b: I8): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I8, b: I8): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I8, b: I8): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I8, b: I8): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I16, b: I16): Bool { a.compare_to(b).is_less() }
fun equals(a: I16, b: I16): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I16, b: I16): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I16, b: I16): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I16, b: I16): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I32, b: I32): Bool { a.compare_to(b).is_less() }
fun equals(a: I32, b: I32): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I32, b: I32): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I32, b: I32): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I32, b: I32): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I64, b: I64): Bool { a.compare_to(b).is_less() }
fun equals(a: I64, b: I64): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I64, b: I64): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I64, b: I64): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I64, b: I64): Bool { a.compare_to(b).is_less_or_equal() }
fun dump[W](int: U8, writer: W) {
  if int.is_at_least(100_u8) { writer.write(int.divide(100_u8).modulo(10_u8).add('0.value)) }
  if int.is_at_least(10_u8) { writer.write(int.divide(10_u8).modulo(10_u8).add('0.value)) }
  writer.write(int.modulo(10_u8).add('0.value))
}
fun dump[W](int: U64, writer: W) {
  | note: max u64 is 18446744073709551615
  if int.is_at_least(10000000000000000000_u64) { writer.write(int.divide(10000000000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(1000000000000000000_u64) { writer.write(int.divide(1000000000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(100000000000000000_u64) { writer.write(int.divide(100000000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(10000000000000000_u64) { writer.write(int.divide(10000000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(1000000000000000_u64) { writer.write(int.divide(1000000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(100000000000000_u64) { writer.write(int.divide(100000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(10000000000000_u64) { writer.write(int.divide(10000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(1000000000000_u64) { writer.write(int.divide(1000000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(100000000000_u64) { writer.write(int.divide(100000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(10000000000_u64) { writer.write(int.divide(10000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(1000000000_u64) { writer.write(int.divide(1000000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(100000000_u64) { writer.write(int.divide(100000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(10000000_u64) { writer.write(int.divide(10000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(1000000_u64) { writer.write(int.divide(1000000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(100000_u64) { writer.write(int.divide(100000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(10000_u64) { writer.write(int.divide(10000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(1000_u64) { writer.write(int.divide(1000_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(100_u64) { writer.write(int.divide(100_u64).modulo(10_u64).to_U8().add('0.value)) }
  if int.is_at_least(10_u64) { writer.write(int.divide(10_u64).modulo(10_u64).to_U8().add('0.value)) }
  writer.write(int.modulo(10_u64).to_U8().add('0.value))
}

| References
| References (pointers to memory locations) are built into the compiler. &T is a
| reference to a T. You can get a reference to a value using the & operator on
| an expression. You can follow a reference using the expr.* syntax. References
| can also be converted to and from the address they are pointing at these
| builtin functions:
| - to_address(&T): U64
| - to_reference[T](U64): &T
| The builtin memory allocation functions don't have anything to do with
| references â€“ they just deal with untyped memory. The following builtin
| functions are used to build type-safe abstractions on top:
| - size_of_type[T](): U64
| - malloc(U64): U64
| fun cast[T, U](value: Ref[T]): Ref[U] { Ref[U].{ address = value.address } }
fun new[T](value: T): &T {
  var ref = malloc(size_of_type[T]()).to_reference[T]()
  ref = value
  ref
}
fun add[T](ref: &T, offset: U64): &T {
  ref.to_address().add(offset.multiply(size_of_type[T]())).to_reference[T]()
}
| TODO: new should take a value
fun dump[T, W](ref: Ref[T], writer: W) {
  | note: max u64 is 18446744073709551615
  '0.dump(writer)
  'x.dump(writer)
  ref.address.divide(1152921504606846976_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(72057594037927936_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(4503599627370496_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(281474976710656_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(17592186044416_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(1099511627776_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(68719476736_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(4294967296_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(268435456_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(16777216_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(1048576_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(65536_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(4096_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(256_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.divide(16_u64).modulo(16_u64).to_U8().dumpHexDigit(writer)
  ref.address.modulo(16_u64).to_U8().dumpHexDigit(writer)
}
fun dumpHexDigit[W](val: U8, writer: W) {
  writer.write(if val.is_greater_than(9_u8) {
    val.subtract(10_u8).add('a.value)
  } else {
    val.add('0.value)
  })
}

struct Point[T] { x: T, y: T }
fun add[T](a: Point[T], b: Point[T]): Point[T] {
  return Point[T].{ x = a.x.add(b.x), y = a.y.add(b.y) }
}
fun dump[T, W](point: Point[T], writer: W) {
  '(.dump(writer)
  point.x.dump(writer)
  ',.dump(writer)
  ' .dump(writer)
  point.y.dump(writer)
  ').dump(writer)
}

| Vec
struct Vec[T] {
  data: &T,
  len: U64,
  capacity: U64,
}
fun vec[T](): Vec[T] {
  Vec[T].{ data = 0_u64.to_reference[T](), capacity = 0_u64, len = 0_u64 }
}
fun push[T](vec: &Vec[T], item: T) {
  if vec.*.capacity.equals(0_u64) {
    vec.*.data = malloc(8_u64.multiply(size_of_type[T]())).to_reference[T]()
    vec.*.capacity = 8_u64
  }
  if vec.*.capacity.equals(vec.*.len) {
    | TODO: copying data needs loops
  }
  var new_item = vec.*.data.add(vec.*.len)
  new_item.* = item
  vec.*.len = vec.*.len.add(1_u64)
}
fun get[T](vec: Vec[T], index: U64): T {
  | TODO: enable check when panic exists
  |if index.is_less_than(vec.len) {
    vec.data.add(index).*
  |}
}

| Char
| Essentially just a U8, but it's formatted differently.
struct Char { value: U8 }
fun dump[W](c: Char, writer: W) { writer.write(c.value) }

| TODO: string, result, hash map, segment tree, treap

|struct Slice[T] { data: Box[T], len: U64 }
|fun get[T](slice: Slice[T], index: U64): T {
|  (data)
|}


| ##########

struct Foo {}
struct Bar[T] {}
fun foo[A](foo: Foo, a: A) {}
fun foo[A, B](foo: A, b: Bar[B]) {}

struct Box[T] { val: T }
fun dump[T, W](box: Box[T], writer: W) { box.val.dump(writer) }

fun foo(b: Ref[Box[U8]]) {
  b.val = 200_u8
}

fun main(): I64 {
  |Foo.{}.foo(Bar[Foo].{}) | fails when uncommented (two matching functions)

  |println(Maybe[U8].some(2_u8))
  |println(fib(10_u64))

  |var box = new(Box[U8].{ val = 3_u8 })
  |box.foo()
  |println(box.deref())

  var v = vec[U8]()
  identity(&v).push(1_u8)
  identity(&v).push(2_u8)
  identity(&v).push(3_u8)
  println(v.get(1_u64))

  |var point_ref = new(Point[U8].{ x = 3_u8, y = 2_u8 })
  |println(point_ref)
  |println(point_ref.deref())
  |point_ref.x = 5_u8

  |println(Bool.true.implies(Bool.true.or(Bool.false)))

  |return 0_i64

  |var vec = Vec[I64].{ len = 0.to_U64() }
  |vec.ref().push(3)
  |print(vec.len_u8.add(48_u8))

  |print('H)
  |print('e)
  |print('l)
  |print('l)
  |print('o)
  |print(',)
  |print(' )
  |print('w)
  |print('o)
  |print('r)
  |print('l)
  |print('d)
  |print('!)
  |print('
  |)

  |return multiply(add(3_i64, 4_i64), divide(4_i64, 2_i64)).modulo(10_i64)
  return 0_i64
}

fun fib(n: U64): U64 {
  if n.is_at_most(1_u64) { n } else { fib(n.subtract(1_u64)).add(fib(n.subtract(2_u64))) }
}

|fun main() {
|  print(fib(10))
|}
|
|fun map[T, X](maybe: Maybe[T], mapper: T -> X): Maybe[X] {
|  return match maybe {
|    case Some t -> Some mapper(t),
|    case None -> None,
|  };
|}
|
|struct String {
|  len: U8,
|}
