# Welcome to Martinaise!
# This is the standard library. Be careful when deleting code here because this
# may crash the compiler.

# Nothing
# A type with only one instance. Functions that don't explicitly return a value
# return Nothing instead.
struct Nothing {}

# Never
# Some expressions always abort control flow, for example `return 3`. These
# evaluate to the Never type.
struct Never {} # TODO: Make this an enum

# Printing
# Only the function `printToStdout(U8)` is builtin. Here, we define the concept
# of writers (types that have a `write` function). The `print` function expects
# a value with a dump function, which is used to serialize the value.
struct StdoutWriter {}
fun write(sow: StdoutWriter, c: U8) { printToStdout(c) }
fun print[T](value: T) { value.dump(StdoutWriter.{}) }
fun println[T](value: T) { print(value) StdoutWriter.{}.write(10.toU8()) }

# Int
# Integers are built into the language. There are several types with different
# signedness and bit amount available as `{'U', 'I'} x {8, 16, 32, 64}`. For
# example, U64 is an unsigned integer of 64 bits.
# All integers also support the following mathematical operations:
# - add(Int, Int): Int
# - subtract(Int, Int): Int
# - multiply(Int, Int): Int
# - divide(Int, Int): Int
# - modulo(Int, Int): Int
# - to<OtherInt>(Int): OtherInt, e.g. toU8() for non-U8 ints
fun dump[W](i: U8, writer: W) {
  writer.write(i.divide(100.toU8()).modulo(10.toU8()).add(48.toU8()))
  writer.write(i.divide(10.toU8()).modulo(10.toU8()).add(48.toU8()))
  writer.write(i.modulo(10.toU8()).add(48.toU8()))
}
fun dump[W](i: i16, writer: W) {
  # TODO: implement
  writer.write(i.divide(10).toU8().add(48.toU8()))
  writer.write(i.modulo(10).toU8().add(48.toU8()))
}

# Order
# An ordering between numbers.
enum Order { less, equal, greater }

# Bool
enum Bool { true, false }
fun not(a: Bool): Bool { if a { return Bool.false() } return Bool.true() }
fun and(a: Bool, b: Bool): Bool { if a { return b } return a }
fun or(a: Bool, b: Bool): Bool { if a { return Bool.true() } return b }
fun xor(a: Bool, b: Bool): Bool { if a { return not(b) } return b }
fun implies(a: Bool, b: Bool): Bool { if a { return b } return Bool.true() }
fun dump[W](b: Bool, writer: W) {
  if b { 
    writer.write(116.toU8()) # t
    writer.write(114.toU8()) # r
    writer.write(117.toU8()) # u
    writer.write(101.toU8()) # e
  } else {
    writer.write(102.toU8()) # f
    writer.write(97.toU8())  # a
    writer.write(108.toU8()) # l
    writer.write(115.toU8()) # s
    writer.write(101.toU8()) # e
  }
}

# Ref
# Martinaise has no typed pointers, but these two builtin functions exist:
# - addressOf[T](T): U64
# - followAddress[T](U64): T
# Here, we build some type-safe abstractions on top.
struct Ref[T] { address: U64 }
fun ref[T](value: T): Ref[T] { Ref[T].{ address = addressOf(value) } }
fun deref[T](ptr: Ref[T]): T { followAddress[T](ptr.address) }
fun cast[T, U](value: Ref[T]): Ref[U] { Ref[U].{ address = value.address } }
# fun malloc[T](): T { malloc[T]() }
# fun size[T](): U64 {}

struct Point[T] { x: T, y: T }
fun add[T](a: Point[T], b: Point[T]): Point[T] {
  return Point[T].{ x = a.x.add(b.x), y = a.y.add(b.y) }
}

struct Vec[T] {
  len: U64,
}
fun push[T](vec: Ref[Vec[T]], item: T) {
  #vec.len = vec.len.deref().add(1.toU64())
  Nothing.{}
}

enum Maybe[T] { some: T, none }
fun flatten[T](maybe: Maybe[Maybe[T]]): Maybe[T] {
  #if maybe is some inner {
  #  return inner
  #}
  return Maybe[T].none()
}

# TODO: string, result, vec, hash map, segment tree, treap

#struct Slice[T] { data: Box[T], len: U64 }
#fun get[T](slice: Slice[T], index: U64): T {
#  (data)
#}

##########

fun main(): I64 {
  #var vec = Vec[I64].{ len = 0.toU64() }
  #vec.ref().push(3)
  #print(vec.len.toU8().add(48.toU8()))

  #if Bool.true() {
  #  print(108.toU8())
  #}
  println(Bool.false().or(Bool.true()))

  print(72.toU8())  # H
  #print(101.toU8()) # e
  #print(108.toU8()) # l
  #print(108.toU8()) # l
  #print(111.toU8()) # o
  #print(44.toU8())  # ,
  #print(32.toU8())  # <space>
  #print(119.toU8()) # w
  #print(111.toU8()) # o
  #print(114.toU8()) # r
  #print(108.toU8()) # l
  #print(100.toU8()) # d
  #print(33.toU8())  # !
  #print(10.toU8())  # <newline>
  return multiply(add(3, 4), divide(4, 2)).modulo(10)
}

############################

#fun fib(n: U8) {
#  if (less_than(n, 2)) {
#    n
#  } else {
#    fib(subtract(n, 1), subtract(n, 2))
#  }
#}
##fun main() {
##  print(fib(10))
##}
#
#fun map[T, X](maybe: Maybe[T], mapper: T -> X): Maybe[X] {
#  return match maybe {
#    case Some t -> Some mapper(t),
#    case None -> None,
#  };
#}
#
#struct String {
#  len: U8,
#}
