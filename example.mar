# Welcome to Martinaise!
# This is the standard library. Be careful when deleting code here because this
# may crash the compiler.

# Nothing
# A type with only one instance. Functions that don't explicitly return a value
# return Nothing instead.
struct Nothing {}

# Never
# Some expressions always abort control flow, for example `return 3`. These
# evaluate to the Never type.
struct Never {} # TODO: Make this an enum

# Printing
# Values with a dump(writer) function can be printed. Writers are anything with
# a write(U8) function. The print function writes the dumped values to stdout.
struct StdoutWriter {}
fun write(sow: StdoutWriter, c: U8) { print_to_stdout(c) }
fun print[T](value: T) { value.dump(StdoutWriter.{}) }
fun println[T](value: T) { print(value) StdoutWriter.{}.write(10.to_U8()) }

# Bool
enum Bool { true, false }
fun not(a: Bool): Bool { if a { return Bool.false() } return Bool.true() }
fun and(a: Bool, b: Bool): Bool { if a { return b } return a }
fun or(a: Bool, b: Bool): Bool { if a { return Bool.true() } return b }
fun xor(a: Bool, b: Bool): Bool { if a { return not(b) } return b }
fun implies(a: Bool, b: Bool): Bool { if a { return b } return Bool.true() }
fun dump[W](b: Bool, writer: W) {
  if b {
    writer.write(116.to_U8()) # t
    writer.write(114.to_U8()) # r
    writer.write(117.to_U8()) # u
    writer.write(101.to_U8()) # e
  } else {
    writer.write(102.to_U8()) # f
    writer.write(97.to_U8())  # a
    writer.write(108.to_U8()) # l
    writer.write(115.to_U8()) # s
    writer.write(101.to_U8()) # e
  }
}

enum Maybe[T] { some: T, none }
fun flatten[T](maybe: Maybe[Maybe[T]]): Maybe[T] {
  switch maybe {
    some(inner) { inner }
    none { Maybe[T].none() }
  }
}
fun dump[T, W](maybe: Maybe[T], writer: W) {
  switch maybe {
    some(val) {
      writer.write(115.to_U8()) # s
      writer.write(111.to_U8()) # o
      writer.write(109.to_U8()) # m
      writer.write(101.to_U8()) # e
      writer.write(40.to_U8()) # (
      val.dump(writer)
      writer.write(41.to_U8()) # )
    }
    none {
      writer.write(110.to_U8()) # n
      writer.write(111.to_U8()) # o
      writer.write(110.to_U8()) # n
      writer.write(101.to_U8()) # e
    }
  }
}

# Ordering
enum Ordering { less, equal, greater }
fun is_less(o: Ordering): Bool {
  switch o {
    less { Bool.true() }
    equal { Bool.false() }
    greater { Bool.false() }
  }
}
fun is_equal(o: Ordering): Bool {
  switch o {
    less { Bool.false() }
    equal { Bool.true() }
    greater { Bool.false() }
  }
}
fun is_greater(o: Ordering): Bool {
  switch o {
    less { Bool.false() }
    equal { Bool.false() }
    greater { Bool.true() }
  }
}
fun is_less_or_equal(o: Ordering): Bool {
  switch o {
    less { Bool.true() }
    equal { Bool.true() }
    greater { Bool.false() }
  }
}
fun is_greater_or_equal(o: Ordering): Bool {
  switch o {
    less { Bool.false() }
    equal { Bool.true() }
    greater { Bool.true() }
  }
}
fun dump[W](o: Ordering, writer: W) {
  switch o {
    less {
      writer.write(108.to_U8()) # l
      writer.write(101.to_U8()) # e
      writer.write(115.to_U8()) # s
      writer.write(115.to_U8()) # s
    }
    equal {
      writer.write(101.to_U8()) # e
      writer.write(113.to_U8()) # q
      writer.write(117.to_U8()) # u
      writer.write(97.to_U8())  # a
      writer.write(108.to_U8()) # l
      writer.write(115.to_U8()) # s
    }
    greater {
      writer.write(103.to_U8()) # g
      writer.write(114.to_U8()) # r
      writer.write(101.to_U8()) # e
      writer.write(97.to_U8())  # a
      writer.write(116.to_U8()) # t
      writer.write(101.to_U8()) # e
      writer.write(114.to_U8()) # r
    }
  }
}

# Int
# Integers are built into the language. There are several types with different
# signedness and bit amount available as `{'U', 'I'} x {8, 16, 32, 64}`. For
# example, U64 is an unsigned integer of 64 bits.
# All integers also support the following mathematical operations:
# - add(Int, Int): Int
# - subtract(Int, Int): Int
# - multiply(Int, Int): Int
# - divide(Int, Int): Int
# - modulo(Int, Int): Int
# - compare_to(Int, Int): Ordering
# - to_<OtherInt>(Int): OtherInt, e.g. to_U8() for non-U8 ints
fun is_less_than(a: U8, b: U8): Bool { return a.compare_to(b).is_less() }
fun equals(a: U8, b: U8): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: U8, b: U8): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: U8, b: U8): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U8, b: U8): Bool { return a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U16, b: U16): Bool { return a.compare_to(b).is_less() }
fun equals(a: U16, b: U16): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: U16, b: U16): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: U16, b: U16): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U16, b: U16): Bool { return a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U32, b: U32): Bool { return a.compare_to(b).is_less() }
fun equals(a: U32, b: U32): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: U32, b: U32): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: U32, b: U32): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U32, b: U32): Bool { return a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U64, b: U64): Bool { return a.compare_to(b).is_less() }
fun equals(a: U64, b: U64): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: U64, b: U64): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: U64, b: U64): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U64, b: U64): Bool { return a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I8, b: I8): Bool { return a.compare_to(b).is_less() }
fun equals(a: I8, b: I8): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: I8, b: I8): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: I8, b: I8): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I8, b: I8): Bool { return a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I16, b: I16): Bool { return a.compare_to(b).is_less() }
fun equals(a: I16, b: I16): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: I16, b: I16): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: I16, b: I16): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I16, b: I16): Bool { return a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I32, b: I32): Bool { return a.compare_to(b).is_less() }
fun equals(a: I32, b: I32): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: I32, b: I32): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: I32, b: I32): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I32, b: I32): Bool { return a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I64, b: I64): Bool { return a.compare_to(b).is_less() }
fun equals(a: I64, b: I64): Bool { return a.compare_to(b).is_equal() }
fun is_greater_than(a: I64, b: I64): Bool { return a.compare_to(b).is_greater() }
fun is_at_least(a: I64, b: I64): Bool { return a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I64, b: I64): Bool { return a.compare_to(b).is_less_or_equal() }
fun dump[W](i: U8, writer: W) {
  #if i.is_at_least(100.to_U8()) {
    writer.write(i.divide(100.to_U8()).modulo(10.to_U8()).add(48.to_U8()))
  #}
  #if i.is_at_least(10.to_U8()) {
    writer.write(i.divide(10.to_U8()).modulo(10.to_U8()).add(48.to_U8()))
  #}
  writer.write(i.modulo(10.to_U8()).add(48.to_U8()))
}
fun dump[W](i: i16, writer: W) {
  # TODO: implement
  writer.write(i.divide(10).to_U8().add(48.to_U8()))
  writer.write(i.modulo(10).to_U8().add(48.to_U8()))
}

# Ref
# Martinaise has no typed pointers, but these two builtin functions exist:
# - address_of[T](T): U64
# - follow_address[T](U64): T
# - malloc(U64): U64
# - size_of_type[T](): U64
# Here, we build some type-safe abstractions on top.
struct Ref[T] { address: U64 }
fun ref[T](value: T): Ref[T] { Ref[T].{ address = address_of(value) } }
fun deref[T](ptr: Ref[T]): T { follow_address[T](ptr.address) }
fun cast[T, U](value: Ref[T]): Ref[U] { Ref[U].{ address = value.address } }
fun new[T](): Ref[T] { Ref[T].{ address = malloc(size_of_type[T]()) } }

struct Point[T] { x: T, y: T }
fun add[T](a: Point[T], b: Point[T]): Point[T] {
  return Point[T].{ x = a.x.add(b.x), y = a.y.add(b.y) }
}

struct Vec[T] {
  len: U64,
}
fun push[T](vec: Ref[Vec[T]], item: T) {
  #vec.len = vec.len.deref().add(1.to_U64())
  Nothing.{}
}

# TODO: string, result, vec, hash map, segment tree, treap

#struct Slice[T] { data: Box[T], len: U64 }
#fun get[T](slice: Slice[T], index: U64): T {
#  (data)
#}

##########

struct Foo {}
struct Bar[T] {}
fun foo[A](foo: Foo, a: A): Nothing { Nothing.{} }
fun foo[A, B](a: A, bar: Bar[B]): Nothing { Nothing.{} }

fun main(): I64 {
  #Foo.{}.foo(Bar[Foo].{})

  println(Maybe[U8].some(2.to_U8()))
  return 0

  #var vec = Vec[I64].{ len = 0.to_U64() }
  #vec.ref().push(3)
  #print(vec.len.to_U8().add(48.to_U8()))

  #print(72.to_U8())  # H
  #print(101.to_U8()) # e
  #print(108.to_U8()) # l
  #print(108.to_U8()) # l
  #print(111.to_U8()) # o
  #print(44.to_U8())  # ,
  #print(32.to_U8())  # <space>
  #print(119.to_U8()) # w
  #print(111.to_U8()) # o
  #print(114.to_U8()) # r
  #print(108.to_U8()) # l
  #print(100.to_U8()) # d
  #print(33.to_U8())  # !
  #print(10.to_U8())  # <newline>
  return multiply(add(3, 4), divide(4, 2)).modulo(10)
}

############################

#fun fib(n: U8) {
#  if (less_than(n, 2)) {
#    n
#  } else {
#    fib(subtract(n, 1), subtract(n, 2))
#  }
#}
##fun main() {
##  print(fib(10))
##}
#
#fun map[T, X](maybe: Maybe[T], mapper: T -> X): Maybe[X] {
#  return match maybe {
#    case Some t -> Some mapper(t),
#    case None -> None,
#  };
#}
#
#struct String {
#  len: U8,
#}
