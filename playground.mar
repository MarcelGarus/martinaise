struct Foo {}
struct Bar[T] {}
fun foo[A](foo: Foo, a: A) {}
fun foo[A, B](foo: A, b: Bar[B]) {}

struct Box[T] { val: T }
fun dump[T, W](box: Box[T], writer: W) { box.val.dump(writer) }

fun foo(b: Ref[Box[U8]]) {
  b.val = 200_u8
}

fun main(): I64 {
  |Foo.{}.foo(Bar[Foo].{}) | fails when uncommented (two matching functions)

  println(Maybe[Str].some("Hello, world!"))

  |println(Maybe[U8].some(2_u8))
  |println(fib(10_u64))

  |var box = new(Box[U8].{ val = 3_u8 })
  |box.foo()
  |println(box.deref())

  var v = vec[U8]()
  identity(&v).push(1_u8)
  identity(&v).push(2_u8)
  identity(&v).push(3_u8)
  println(v)

  var a = loop {
    println(3_u8)
    break(4_u8)
  }
  a.to_U64().dump(2_u64, StdoutWriter.{})
  println('!)

  123456789456_u64.dump_address(StdoutWriter.{})
  println('!)
  123456789456_u64.dump(16_u64, StdoutWriter.{})
  println('!)

  |var point_ref = new(Point[U8].{ x = 3_u8, y = 2_u8 })
  |println(point_ref)
  |println(point_ref.deref())
  |point_ref.x = 5_u8

  |println(Bool.true.implies(Bool.true.or(Bool.false)))

  |return 0_i64

  |var vec = Vec[I64].{ len = 0.to_U64() }
  |vec.ref().push(3)
  |print(vec.len_u8.add(48_u8))

  |print('H)
  |print('e)
  |print('l)
  |print('l)
  |print('o)
  |print(',)
  |print(' )
  |print('w)
  |print('o)
  |print('r)
  |print('l)
  |print('d)
  |print('!)
  |print('
  |)

  |return multiply(add(3_i64, 4_i64), divide(4_i64, 2_i64)).modulo(10_i64)
  return 0_i64
}

fun fib(n: U64): U64 {
  if n.is_at_most(1_u64) { n } else { fib(n.subtract(1_u64)).add(fib(n.subtract(2_u64))) }
}

|fun main() {
|  print(fib(10))
|}
|
|fun map[T, X](maybe: Maybe[T], mapper: T -> X): Maybe[X] {
|  return match maybe {
|    case Some t -> Some mapper(t),
|    case None -> None,
|  };
|}
|
|struct String {
|  len: U8,
|}
