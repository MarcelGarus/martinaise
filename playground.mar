enum CType { char: U8, short: U16, int: U32, long: U64 }
struct Foo {
  value: U32,
  flup: CType,
  foo: &Foo,
  baz: Maybe[Maybe[Str]],
  blub: Map[Str, U64],
}

struct CompileFun {
  foo: Foo,
  context: &Context,
  ast: Ast,
  mono: &Mono,
  fun_: &MonoFun,
  type_env: Map[Str, Type], | maps fun type args to concrete types
  next_label: U64,
  vars: Vars[MonoSlotRef],
  return_type: TypeSink,
  | When lowering loops, breaks and continues don't know where to jump yet.
  | Instead, they fill these structures with jump addresses that need to be
  | adjusted later.
  break_scopes: Stack[BreakScope],
  continue_scopes: Stack[ContinueScope],
}
struct Context {} | omitted
struct Ast { defs: Vec[AstDef] }
struct AstDef {} | omitted
struct Mono {} | omitted
struct MonoFun {} | omitted
struct Type { name: Str, args: Vec[Type] }
struct Vars[T] { visible: Vec[VarInScope[T]] }
struct VarInScope[T] { name: Str, data: T }
struct MonoSlotRef { index: U64 }
struct TypeSink { current: Maybe[Type] }
struct BreakScope {
  result: MonoSlotRef,
  type: Maybe[Type],
  breaks: Vec[U64],
}
struct ContinueScope { continues: Vec[U64] }

| Assembly  
| In the end, all Martinaise code is lowered to x86_64 NASM-style assembly. A
| big downside of this is that Martinaise is not portable. An upside is that you
| can easily switch back and forth between Martinaise and assembly. Using the
| asm keyword, you can implement functions in assembly language.
|
| Memory Layout  
| The memory layout depends on the type:
|
| - Builtin types (U8, U16, U32, U64, I8, I16, I32, I64) are always aligned to a
|   multiple of their size.
|
|  - Struct types have an alignment equal to the biggest alignment of their
|   fields. All fields with a size that is a multiple of this alignment are
|   moved to the front. All other fields are ordered in a way to minimize the
|   overall size. You should not depend on the order of these other fields.
| 
|   Example:
|
|  - Enum types contain the payload followed by a single byte indicating which
|   variant is active. The size reserved for the payload is the biggest size of
|   all the possible variant payloads.
|
| Calling Convention  
| Martinaise has its own calling convention. It is often less efficient than the
| cdecl and RISC-V calling conventions, but way simpler.
|
| - Registers  
|   Calling a function may change any register contents except the rsp (stack
|   pointer register). This means that functions are free to use any registers
|   they want for whatever purpose without first pushing contents onto the stack
|   and restoring them later on.
|
| - Arguments  
|   All arguments are passed on the stack. When a function starts executing, the
|   last value on the stack is the callee (the call instruction automatically
|   pushes it onto the stack). Below that is an address that indicates where the
|   return value should be saved to. Below that are the arguments, layed out as
|   if they were in an anonymous struct that is 8-byte aligned.
|
|   Example: foo(a: U16, b: U32, c: U32, d: U8) is called. When layouting a
|   struct containing a, b, c, and d its layout would look like this:
|
|   bbbbccccaad
|
|   This value is padded to a multiple of 8 bytes, so at the beginning of the
|   function execution, the stack looks like this:
|
|   [callee][return]bbbbccccaad.....[other stuff on the stack]
|   ▏       ▏       ▏       ▏       ▏
|   rsp    +8      +16     +24     +32
|
|   More notes about this:
|   - 1 character in this visualization represents one byte.
|   - The stack grows down to lower addresses, so the relevant parts are at the
|     lower addresses.
|   - The arguments all fulfill their alignment requirements.
|   - The arguments can be accessed like this:
|     - a: [rsp + 24]
|     - b: [rsp + 16]
|     - c: [rsp + 20]
|     - d: [rsp + 26]
|   - You can rely on the fact that all arguments with a size that is a multiple
|     of the highest alignment (4) are at the beginning in the order they were
|     declared (in this example, b and c). You should NOT depend on the order of
|     the other fields. This restrictions effectively prohibits you from
|     manually implementing asm functions that take multiple arguments with a
|     size that is not a multiple of the biggest alignment (such as this foo).
|     Instead, consider writing asm functions with arguments that are explicitly
|     of the same length and wrapping them with nicer-typed functions when
|     necessary.

| opaque U8 = 1 byte big, 1 byte aligned
| opaque U16 = 2 bytes big, 2 bytes aligned


fun syscall(number: U64, arg0: U64): U64 asm {
  ;        0       8       16      24      32
  ; stack: [callee][return][number][arg0  ]
  mov rax, [rsp + 16] ; syscall number
  mov rdi, [rsp + 24] ; argument 0
  syscall
  mov r8, [rsp + 8]
  mov [r8], rax ; write return value
  ret
}

fun syscall(number: U64, arg0: U64, arg1: U64): U64 asm {
  ;        0       8       16      24      32      40
  ; stack: [callee][return][number][arg0  ][arg1  ]
  mov rax, [rsp + 16] ; syscall number
  mov rdi, [rsp + 24] ; argument 0
  mov rsi, [rsp + 32] ; argument 1
  syscall
  mov r8, [rsp + 8]
  mov [r8], rax ; write return value
  ret
}

fun syscall(number: U64, arg0: U64, arg1: U64, arg2: U64): U64 asm {
  ;        0       8       16      24      32      40      48
  ; stack: [callee][return][number][arg0  ][arg1  ][arg2  ]
  mov r8, rax
  mov rax, [rsp + 16] ; syscall number
  mov rdi, [rsp + 24] ; argument 0
  mov rsi, [rsp + 32] ; argument 1
  mov rdx, [rsp + 40] ; argument 2
  syscall
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}

fun exit(status: U64): Never {
  syscall(60, status)
  halt()
}

fun asm_write(file: File, char: Char) {
  syscall(1, file.descriptor, char.&.to_address(), 1).ignore()
}

fun to_address[T](ref: &T): U64 asm {
  ;        0       8       16      24
  ; stack: [callee][return][ref   ]
  mov r8, [rsp + 16]
  mov r9, [rsp + 8]
  mov [r9], r8
  ret
}

fun main(args: Slice[Str]): Never {
  var stdout = File { descriptor = 1 }
  stdout.asm_write(#H)
  stdout.asm_write(#w)
  exit(42)
}

fun asm_add(a: U64, b: U64): U64 asm {
  ;        0       8       16      24      32
  ; stack: [callee][return][a     ][b     ]
  mov r8, [rsp + 16]
  add r8, [rsp + 24]
  mov r9, [rsp + 8]
  mov [r9], r8
  ret
}

fun mar_add(a: U64, b: U64): U64 { asm_add(a, b) }

fun main(): Never {
  | libc_write(2, #H.&.to_address(), 1)
  | libc_write(2, #e.&.to_address(), 1)
  | libc_write(2, #l.&.to_address(), 1)
  | libc_write(2, #l.&.to_address(), 1)
  | libc_write(2, #o.&.to_address(), 1)
  | libc_write(2, #!.&.to_address(), 1)
  | libc_write(2, newline.&.to_address(), 1)
  loop {
    var foo = mar_add(7, 35)
  }
  if Bool.true then var foo = 3
  | TODO: println("Hello, world!")
  exit(0)
}
