| Welcome to Martinaise!  
| Martinaise is a language that's designed for solving simple puzzles such as
| advent of code. Making a language that is widely-used is _not_ the goal.
| Instead, this is a small, recreational project.
| This is the standard library. Be careful when deleting code here because this
| may crash the compiler.

| Nothing  
| A type with only one instance. Functions without an explicit return type
| return Nothing. Bodies with no expressions inside return Nothing. This is the
| single Nothing instance: {}
struct Nothing {}
fun dump[W](nothing: Nothing, writer: W) { str("nothing").dump(writer) }
fun equals(a: Nothing, b: Nothing): Bool { Bool.true }

| Never  
| Some expressions always abort control flow, for example `return 3`. These
| evaluate to the Never type.
enum Never {}
fun panic(): Never { panic("panicked") }
fun unreachable(): Never { panic("unreachable") }
fun todo(): Never { panic("todo") }

| Printing  
| You should implement a dump(T, Writer) function for types that can be printed.
| The print and println functions can print any value with a dump(T, Writer)
| function. Writers are anything with a write(W, U8) function. The prints and
| printsln functions print the argument as a string.
struct StdoutWriter {} | Uses the builtin print_to_stdout function.
fun write(sow: StdoutWriter, c: U8) { print_to_stdout(c) } | TODO: add generic write builtin
fun print[T](value: T) { value.dump(StdoutWriter.{}) }
fun println[T](value: T) { print(value) println() }
fun println() { StdoutWriter.{}.write(newline()) }
fun prints(message: Slice[U8]) { print(str(message)) }
fun printsln(message: Slice[U8]) { println(str(message)) }

| Equality  
| You should implement an equals(T, T) function for types that can be compared
| for equality.
fun not_equals[T](a: T, b: T): Bool { not(a.equals(b)) }

| Hashing  
| You should implement a hash(T, Hasher) function for types that can be hashed.
| In this function, they can contribute some uniqueness/entropy to the Hasher by
| calling its contribute(U64) function. The Hasher uses the djb2 algorithm.
fun hash[T](value: T): U64 {
  var h = Hasher.{ state = 5381_U64 }
  value.hash(&h)
  h.state
}
struct Hasher { state: U64 }
fun contribute(hasher: &Hasher, val: U64) {
  hasher.state = hasher.state.multiply(33_U64).add(val)
}

| Char  
| Essentially just a U8, but it's formatted differently.
struct Char { value: U8 }
fun char(value: U8): Char { Char.{ value = value } }
fun dump[W](c: Char, writer: W) { writer.write(c.value) }
fun newline(): U8 { 10_U8 } | TODO: refactor to variable when we have global variables

| Str  
| Essentially just a Slice[U8], but it's formatted differently. There's no
| enforcement of UTF-8 or anything. When formatting strings, the raw bytes are
| simply sent to the writer.
struct Str { bytes: Slice[U8] }
fun str(bytes: Slice[U8]): Str { Str.{ bytes = bytes } }
fun dump[W](str: Str, writer: W) {
  for byte in &str.bytes.iter() do writer.write(byte)
}

| Bool  
| The usual boolean values true and false. The if construct expects a Bool as
| the condition.
enum Bool { true, false }
fun equals(a: Bool, b: Bool): Bool { if a then b else not(b) }
fun not(a: Bool): Bool { if a then Bool.false else Bool.true }
fun and(a: Bool, b: Bool): Bool { if a then b else a }
fun or(a: Bool, b: Bool): Bool { if a then Bool.true else b }
fun xor(a: Bool, b: Bool): Bool { if a then not(b) else b }
fun implies(a: Bool, b: Bool): Bool { if a then b else Bool.true }
fun dump[W](b: Bool, writer: W) {
  str({if b then "true" else "false"}).dump(writer)
}
fun hash(value: Bool, hasher: &Hasher) {
  hasher.contribute(if value then 0_U64 else 1_U64)
}

| Maybe  
| Represents optional values. Like Option in Rust, but with the cooler Haskell
| name. Martinaise has an orelse keyword, which you can write after a Maybe[T]
| to get the underlying T if it's a some, or execute the expression after the
| orelse if it's a none:
| - Maybe[U8].some(2_U8) orelse 3_U8 = 2_U8
| - Maybe[U8].none orelse 3_U8 = 3_U8
enum Maybe[T] { some: T, none }
fun unwrap[T](maybe: Maybe[T]): T { maybe orelse panic("called none.unwrap") }
fun flatten[T](maybe: Maybe[Maybe[T]]): Maybe[T] { inner orelse Maybe[T].none }
| TODO: remove when language feature exists
fun is_some[T](maybe: Maybe[T]): Bool {
  switch maybe case some Bool.true case none Bool.false
}
fun is_none[T](maybe: Maybe[T]): Bool {
  switch maybe case some Bool.false case none Bool.true
}
fun dump[T, W](maybe: Maybe[T], writer: W) {
  switch maybe
  case some(val) {
    str("some(").dump(writer)
    val.dump(writer)
    char(')).dump(writer)
  }
  case none str("none").dump(writer)
}
fun equals(a: Maybe[T], b: Maybe[T]): Bool {
  switch a
  case some(aa) { switch b case some(bb) aa.equals(bb) case none Bool.false }
  case none b.is_none()
}
fun hash[T](value: Maybe[T], hasher: &Hasher) {
  switch value
  case some(inner) {
    hasher.contribute('s.to_U64())
    inner.hash(hasher)
  }
  case none hasher.contribute('n.to_U64())
}

| Comparing  
| You should implement a compare_to(T, T): Ordering function for types that can
| be compared. This allows you to use functions such as is_at_least or min.
enum Ordering { less, equal, greater }
fun is_less(ord: Ordering): Bool {
  switch ord case less Bool.true case equal Bool.false case greater Bool.false
}
fun is_equal(ord: Ordering): Bool {
  switch ord case less Bool.false case equal Bool.true case greater Bool.false
}
fun is_greater(ord: Ordering): Bool {
  switch ord case less Bool.false case equal Bool.false case greater Bool.true
}
fun is_less_or_equal(ord: Ordering): Bool {
  switch ord case less Bool.true case equal Bool.true case greater Bool.false
}
fun is_greater_or_equal(ord: Ordering): Bool {
  switch ord case less Bool.false case equal Bool.true case greater Bool.true
}
fun equals(a: Ordering, b: Ordering): Bool {
  switch a
  case less b.is_less()
  case equal b.is_equal()
  case greater b.is_greater()
}
fun hash[Hasher](ord: Ordering, hasher: Hasher) {
  switch ord
  case less 'l.hash(hasher)
  case equal 'e.hash(hasher)
  case greater 'g.hash(hasher)
}
fun dump[W](ord: Ordering, writer: W) {
  {switch ord case less "less" case equal "equal" case greater "greater"}
    .dump(writer)
}
fun is_less_than[T](a: T, b: T): Bool { a.compare_to(b).is_less() }
fun is_greater_than[T](a: T, b: T): Bool { a.compare_to(b).is_greater() }
fun is_at_least[T](a: T, b: T): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most[T](a: T, b: T): Bool { a.compare_to(b).is_less_or_equal() }
fun min[T](a: T, b: T): T { if a.is_less_than(b) then a else b }
fun max[T](a: T, b: T): T { if a.is_greater_than(b) then a else b }

| Tuples  
fun tuple[A, B](a: A, b: B): Tuple[A, B] {
  Tuple[A, B].{ a = a, b = b }
}
fun tuple[A, B, C](a: A, b: B, c: C): Tuple[A, B, C] {
  Tuple[A, B, C].{ a = a, b = b, c = c }
}
struct Tuple[A, B] { a: A, b: B }
struct Tuple[A, B, C] { a: A, b: B, c: C }
fun dump[A, B, W](tuple: Tuple[A, B], writer: W) {
  '(.dump(writer)
  tuple.a.dump(writer)
  str(", ").dump(writer)
  tuple.b.dump(writer)
  ').dump(writer)
}
fun dump[A, B, C, W](tuple: Tuple[A, B, C], writer: W) {
  '(.dump(writer)
  tuple.a.dump(writer)
  str(", ").dump(writer)
  tuple.b.dump(writer)
  str(", ").dump(writer)
  tuple.c.dump(writer)
  ').dump(writer)
}

| Point  
struct Point[T] { x: T, y: T }
fun dump[T, W](point: Point[T], writer: W) {
  tuple(point.x, point.y).dump(writer)
}

| Int  
| Integers are built into the language. There are several types with different
| signedness and bit amount available as {U, I} x {8, 16, 32, 64}. For example,
| U64 is an unsigned integer of 64 bits.
| All integers also support the following mathematical operations:
| - add(Int, Int): Int
| - subtract(Int, Int): Int
| - multiply(Int, Int): Int
| - divide(Int, Int): Int
| - modulo(Int, Int): Int
| - compare_to(Int, Int): Ordering
| - to_<OtherInt>(Int): OtherInt, e.g. to_U8() for non-U8 ints
fun inc(a: U8): U8 { a.add(1_U8) }
fun inc(a: U16): U16 { a.add(1_U16) }
fun inc(a: U32): U32 { a.add(1_U32) }
fun inc(a: U64): U64 { a.add(1_U64) }
fun inc(a: I8): I8 { a.add(1_I8) }
fun inc(a: I16): I16 { a.add(1_I16) }
fun inc(a: I32): I32 { a.add(1_I32) }
fun inc(a: I64): I64 { a.add(1_I64) }
fun dec(a: U8): U8 { a.subtract(1_U8) }
fun dec(a: U16): U16 { a.subtract(1_U16) }
fun dec(a: U32): U32 { a.subtract(1_U32) }
fun dec(a: U64): U64 { a.subtract(1_U64) }
fun dec(a: I8): I8 { a.subtract(1_I8) }
fun dec(a: I16): I16 { a.subtract(1_I16) }
fun dec(a: I32): I32 { a.subtract(1_I32) }
fun dec(a: I64): I64 { a.subtract(1_I64) }
fun equals(a: U8, b: U8): Bool { a.compare_to(b).is_equal() }
fun equals(a: U16, b: U16): Bool { a.compare_to(b).is_equal() }
fun equals(a: U32, b: U32): Bool { a.compare_to(b).is_equal() }
fun equals(a: U64, b: U64): Bool { a.compare_to(b).is_equal() }
fun equals(a: I8, b: I8): Bool { a.compare_to(b).is_equal() }
fun equals(a: I16, b: I16): Bool { a.compare_to(b).is_equal() }
fun equals(a: I32, b: I32): Bool { a.compare_to(b).is_equal() }
fun equals(a: I64, b: I64): Bool { a.compare_to(b).is_equal() }
fun hash(value: U8, hasher: &Hasher) { hasher.contribute(value.to_U64()) }
fun hash(value: U16, hasher: &Hasher) { hasher.contribute(value.to_U64()) }
fun hash(value: U32, hasher: &Hasher) { hasher.contribute(value.to_U64()) }
fun hash(value: U64, hasher: &Hasher) { hasher.contribute(value) }
fun hash(value: I8, hasher: &Hasher) { hasher.contribute(value.to_U64()) }
fun hash(value: I16, hasher: &Hasher) { hasher.contribute(value.to_U64()) }
fun hash(value: I32, hasher: &Hasher) { hasher.contribute(value.to_U64()) }
fun hash(value: I64, hasher: &Hasher) { hasher.contribute(value.to_U64()) }
fun dump[W](int: U64, radix: U64, writer: W) {
  var divisor = 1_U64
  loop {
    if int.divide(divisor).is_less_than(radix) then break
    divisor = divisor.multiply(radix)
  }
  loop {
    writer.write(int.divide(divisor).modulo(radix).to_U8().digit_to_char())
    if divisor.equals(1_U64) then break
    divisor = divisor.divide(radix)
  }
}
fun digit_to_char(digit: U8): U8 {
  if digit.is_greater_than(9_U8)
  then digit.subtract(10_U8).add('a)
  else digit.add('0)
}
fun dump[W](int: U8, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U16, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U32, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U64, writer: W) { int.dump(10_U64, writer) }
fun parse_U64(bytes: Slice[U8]): U64 {
  var num = 0_U64
  for char in &bytes.iter() do {
    if not('0.until('9).contains(char))
    then panic("non-digit in supposed number")
    num = num.multiply(10_U64).add(char.subtract('0).to_U64())
  }
  num
}

| Range  
| Ranges have an inclusive start and exclusive end value.
struct Range[T] { start: T, end: T }
fun to[T](start: T, end: T): Range[T] { Range[T].{ start = start, end = end } }
fun until[T](start: T, end: T): Range[T] {
  Range[T].{ start = start, end = end.inc() }
}
fun range_by[T](start: T, len: T): Range[T] {
  Range[T].{ start = start, end = start.add(len) }
}
fun contains[T](range: Range[T], value: T): Bool {
  value.is_at_least(range.start).and(value.is_less_than(range.end))
}
fun is_empty[T](range: Range[T]): Bool { range.start.is_at_least(range.end) }
fun iter[T](range: Range[T]): RangeIter[T] { RangeIter[T].{ rest = range } }
struct RangeIter[T] { rest: Range[T] }
fun next[T](iter: &RangeIter[T]): Maybe[T] {
  if iter.rest.is_empty() then Maybe[T].none else {
    var current = iter.rest.start
    iter.rest.start = current.inc()
    Maybe[T].some(current)
  }
}

| Reference  
| References (pointers to memory locations) are built into the compiler. &T is a
| reference to a T. You can get a reference to a value using the & operator on
| an expression. You can follow a reference using the expr.* syntax. References
| can also be converted to and from the address they are pointing at these
| builtin functions:
| - to_address(&T): U64
| - to_reference[T](U64): &T
| The builtin memory allocation functions don't have anything to do with
| references â€“ they just deal with untyped memory. The following builtin
| functions are used to build type-safe abstractions on top:
| - size_of_type[T](): U64
| - malloc(U64): U64
fun ref[T](): &T { malloc(size_of_type[T]()).to_reference[T]() }
fun new[T](value: T): &T {
  var ref = ref[T]()
  ref.* = value
  ref
}
fun cast[T, U](value: &T): &U { value.to_address().to_reference[U]() }
fun add_offset[T](ref: &T, offset: U64): &T {
  ref.to_address().add(offset.multiply(size_of_type[T]())).to_reference[T]()
}
fun swap[T](a: &T, b: &T) {
  var tmp = a.*
  a.* = b.*
  b.* = tmp
}
fun dump_address[W](address: U64, writer: W) {
  | max U64 is  18446744073709551615
  var divisor = 1152921504606846976_U64 | 16 ^ something
  "0x".dump(writer)
  loop {
    writer.write(address.divide(divisor).modulo(16_U64).to_U8().digit_to_char())
    if divisor.equals(1_U64) then break
    divisor = divisor.divide(16_U64)
  }
}

| Slice  
| A slice is a memory region where values of the same type are right next to
| each other.
struct Slice[T] { data: &T, len: U64 }
fun empty_slice[T](): Slice[T] {
  Slice[T].{ data = 0_U64.to_reference[T](), len = 0_U64 }
}
fun uninitialized_slice[T](len: U64): Slice[T] {
  if len.equals(0_U64) then return empty_slice[T]()
  var data = malloc(len.multiply(size_of_type[T]())).to_reference[T]()
  Slice[T].{ data = data, len = len }
}
fun filled_slice[T](len: U64, fill: T): Slice[T] {
  var slice = uninitialized_slice[T](len)
  for i in &0_U64.to(len).iter() do slice.get_ref(i).* = fill
  slice
}
fun is_empty[T](slice: Slice[T]): Bool { slice.len.equals(0_U64) }
fun get[T](slice: Slice[T], index: U64): T { slice.data.add_offset(index).* }
fun get_ref[T](slice: Slice[T], index: U64): &T {
  if 0_U64.to(slice.len).contains(index)
  then slice.data.add_offset(index)
  else panic("index out of bounds")
}
fun subslice[T](slice: Slice[T], from: U64, to: U64): Slice[T] {
  if to.is_greater_than(slice.len)
  then panic("subslice needs to be inside original slice")
  Slice[T].{ data = slice.data.add_offset(from), len = to.subtract(from) }
}
fun subslice[T](slice: Slice[T], from: U64): Slice[T] {
  slice.subslice(from, slice.len)
}
fun copy_to[T](from: Slice[T], to: Slice[T]) {
  if not(from.len.equals(to.len)) then panic("copy_to slice lens don't match")
  for i in &0_U64.to(from.len).iter() do to.get_ref(i).* = from.get(i)
}
fun split(slice: Slice[U8], separator: Slice[U8]): Slice[Slice[U8]] {
  var result = vec[Slice[U8]]()
  for part in &slice.iter().iter_split(separator) do result.&.push(part)
  result.to_slice()
}
fun lines(slice: Slice[U8]): Slice[Slice[U8]] { slice.split("
") }
fun dump[T, W](slice: Slice[T], writer: W) {
  char('[).dump(writer)
  var first = Bool.true
  for item in &slice.iter() do {
    if first then first = Bool.false else str(", ").dump(writer)
    item.dump(writer)
  }
  char(']).dump(writer)
}
fun starts_with[T](slice: Slice[T], prefix: Slice[T]): Bool {
  if prefix.len.is_greater_than(slice.len) then return Bool.false
  for i in &0_U64.to(prefix.len).iter() do
    if not(slice.get(i).equals(prefix.get(i))) then return Bool.false
  Bool.true
}
fun ends_with[T](slice: Slice[T], suffix: Slice[T]): Bool {
  if suffix.len.is_greater_than(slice.len) then return Bool.false
  for i in &0_U64.to(suffix.len).iter() do
    if not(
      slice.get(slice.len.subtract(suffix.len).add(i)).equals(suffix.get(i))
    )
    then return Bool.false
  Bool.true
}
fun trim_prefix(slice: &Slice[U8], prefix: Slice[U8]) {
  if slice.starts_with(prefix)
  then slice.* = slice.subslice(prefix.len)
  else panic("slice doesn't start with prefix")
}
fun compare_to[T](a: Slice[T], b: Slice[T]): Ordering {
  var i = 0_U64
  loop {
    if i.equals(a.len).and(i.equals(b.len)) then return Ordering.equal
    if i.equals(a.len) then return Ordering.less
    if i.equals(b.len) then return Ordering.greater
    var ord = a.get(i).compare_to(b.get(i))
    if not(ord.is_equal()) then return ord
    i = i.inc()
  }
}
fun equals[T](a: Slice[T], b: Slice[T]): Bool {
  | TODO: support for types that only have equals, not compare_to
  if a.len.equals(b.len) then compare_to(a, b).is_equal() else Bool.false
}
fun hash[T](slice: Slice[T], hasher: &Hasher) {
  for item in &slice.iter() do item.hash(hasher)
}
fun find[T](slice: Slice[T], needle: T): Maybe[U64] {
  for i in &0_U64.to(slice.len).iter() do
    if slice.get(i).equals(needle) then return Maybe[U64].some(i)
  Maybe[U64].none
}
fun sort[T](slice: &Slice[T]) {
  | quick sort
  if slice.len.is_at_most(1_U64) then return {}
  var pivot = slice.get(slice.len.dec())
  var i = 0_U64
  for j in &0_U64.to(slice.len).iter() do
    if slice.get(j).is_less_than(pivot) then {
      i = i.inc()
      swap(slice.get_ref(i.dec()), slice.get_ref(j))
    }
  swap(slice.get_ref(i), slice.get_ref(slice.len.dec()))
  sort(&slice.subslice(0_U64, i))
  sort(&slice.subslice(min(i.inc(), slice.len.dec()), slice.len))
}
fun iter[T](slice: Slice[T]): SliceIter[T] {
  SliceIter[T].{ slice = slice, index = 0_U64 }
}
struct SliceIter[T] {
  slice: Slice[T],
  index: U64,
}
fun next[T](iter: &SliceIter[T]): Maybe[T] {
  var item = if iter.index.is_less_than(iter.slice.len)
    then Maybe[T].some(iter.slice.get(iter.index))
    else Maybe[T].none
  iter.index = iter.index.add(1_U64)
  item
}
fun rev_iter[T](slice: Slice[T]): SliceRevIter[T] {
  SliceRevIter[T].{ slice = slice, index = slice.len }
}
struct SliceRevIter[T] {
  slice: Slice[T],
  index: U64, | last yielded item
}
fun next[T](iter: &SliceRevIter[T]): Maybe[T] {
  if iter.index.is_greater_than(0_U64) then {
    iter.index = iter.index.subtract(1_U64)
    Maybe[T].some(iter.slice.get(iter.index))
  } else Maybe[T].none
}
fun iter_split[I](iter: I, separator: Slice[U8]): SplitIter[I] {
  SplitIter[I].{ iter = iter, separator = separator }
}
struct SplitIter[I] { iter: I, separator: Slice[U8] }
fun next[I](self: &SplitIter[I]): Maybe[Slice[U8]] {
  var line = vec[U8]()
  loop
    switch self.iter.&.next()
    case none
      if line.len.is_greater_than(0_U64)
      then break
      else return Maybe[Slice[U8]].none
    case some(c) {
      line.&.push(c)
      if line.to_slice().subslice(line.len.subtract(self.separator.len))
        .equals(self.separator)
      then return Maybe[Slice[U8]].some(
        line.to_slice().subslice(0_U64, line.len.subtract(self.separator.len))
      )
    }
  Maybe[Slice[U8]].some(line.to_slice())
}
fun min[T](slice: Set[T]): Maybe[T] {
  var candidate = Maybe[T].none
  for item in &slice.iter() do
    switch candidate
    case some(c) candidate = Maybe[T].some(min(c, item))
    case none candidate = Maybe[T].some(item)
  return candidate
}
|fun enumerate[I](iter: I): Enumerated[I] {
|  Enumerated[I].{ iter = iter, counter = 0_U64 }
|}
|struct Enumerated[T, I] { iter: I, counter: U64 }
| TODO: Support inferring part of the return type like here
|fun next[I](self: &Enumerated[I]): Maybe[Pair[U64, _]] { ... }

| Vec  
| A growable array where you can efficiently push and pop data to/from the back.
| This is implemented using a fixed-size slice. Once it fills up, a new slice is
| allocated and the old items are copied over.
struct Vec[T] { data: Slice[T], len: U64 }
fun vec[T](): Vec[T] { Vec[T].{ data = empty_slice[T](), len = 0_U64 } }
| TODO: remove when there are slice literals
fun vec[T](a: T): Vec[T] { var v = vec[T]() v.&.push(a) v }
fun vec[T](a: T, b: T): Vec[T] { var v = vec[T]() v.&.push(a) v.&.push(b) v }
fun vec[T](a: T, b: T, c: T): Vec[T] {
  var v = vec[T]()
  v.&.push(a)
  v.&.push(b)
  v.&.push(c)
  v
}
fun vec[T](a: T, b: T, c: T, d: T): Vec[T] {
  var v = vec[T]()
  v.&.push(a)
  v.&.push(b)
  v.&.push(c)
  v.&.push(d)
  v
}
fun push[T](vec: &Vec[T], item: T) {
  if vec.data.len.equals(0_U64) then vec.data = uninitialized_slice[T](8_U64)
  if vec.data.len.equals(vec.len) then {
    var new_data = uninitialized_slice[T](vec.data.len.multiply(2_U64))
    vec.data.copy_to(new_data.subslice(0_U64, vec.data.len))
    vec.data = new_data
  }
  vec.data.get_ref(vec.len).* = item
  vec.len = vec.len.add(1_U64)
}
| TODO: return a Maybe
fun pop[T](vec: &Vec[T]): T { vec.len.&.dec_mut() vec.data.get(vec.len) }
fun get[T](vec: Vec[T], index: U64): T { vec.data.get(index) }
fun get_ref[T](vec: Vec[T], index: U64): &T { vec.data.get_ref(index) }
fun to_slice[T](vec: Vec[T]): Slice[T] { vec.data.subslice(0_U64, vec.len) }
fun equals[T](a: Vec[T], b: Vec[T]): Bool { a.to_slice().equals(b.to_slice()) }
fun iter[T](vec: Vec[T]): SliceIter[T] { vec.to_slice().iter() }
fun dump[T, W](vec: Vec[T], writer: W) { vec.to_slice().dump(writer) }

| Stack  
| Something where you can push and pop items. Essentially just a Vec, but
| sometimes this type expresses the intent more clearly.
struct Stack[T] { vec: Vec[T] }
fun push[T](stack: &Stack[T], item: T) { stack.vec.push(item) }
fun pop[T](stack: &Stack[T]) { stack.vec.pop() }
fun peek[T](stack: &Stack[T]): T { stack.peek(0_U64) }
fun peek[T](stack: &Stack[T], n: U64): T {
  stack.vec.get(stack.vec.len.subtract(1_U64).subtract(n))
}
fun equals[T](a: Stack[T], b: Stack[T]): Bool { a.vec.equals(b.vec) }
fun dump[T, W](stack: Stack[T], writer: W) { stack.vec.dump(writer) }

| Deque  
| A growable array-like structure where you can push and pop from both ends.
| It maintains an inclusive start and an exclusive end index. Basically, there
| are two possibilities how this can be layed out:
|
| Start before end:           End before start:
| [-][0][1][2][3][4][-][-]    [3][4][-][-][-][0][1][2]
|     s              e               e        s
struct Deque[T] { data: Slice[T], start: U64, end: U64 }
fun deque[T](): Deque[T] {
  Deque[T].{ data = uninitialized_slice[T](8_U64), start = 0_U64, end = 0_U64 }
}
fun len[T](deque: Deque[T]): U64 {
  if deque.end.is_at_least(deque.start)
  then deque.end.subtract(deque.start)
  else deque.start.add(deque.data.len).subtract(deque.end)
}
fun is_empty[T](deque: Deque[T]): Bool { deque.len().equals(0_U64) }
fun reserve[T](deque: &Deque[T], size: U64) {
  if deque.data.len.is_at_least(size) then return
  var slices = deque.to_slices()
  var total_len = deque.len()
  deque.data = uninitialized_slice[T](size)
  slices.a.copy_to(deque.data.subslice(0_U64, slices.a.len))
  slices.b.copy_to(deque.data.subslice(slices.a.len, total_len))
  deque.start = 0_U64
  deque.end = total_len
}
fun push_front[T](deque: &Deque[T], item: T) {
  if deque.data.len.equals(deque.len().dec())
  then deque.reserve(deque.data.len.multiply(2_U64))
  deque.start = if deque.start.equals(0_U64)
    then deque.data.len
    else deque.start.dec()
  deque.data.get_ref(deque.start).* = item
}
fun pop_front[T](deque: &Deque[T]): T {
  if deque.is_empty() then panic("pop_front on empty deque")
  var item = deque.data.get(deque.start)
  deque.start = deque.start.inc().modulo(deque.data.len)
  item
}
fun push_back[T](deque: &Deque[T], item: T) {
  if deque.data.len.equals(deque.len().dec())
  then deque.reserve(deque.data.len.multiply(2_U64))
  deque.data.get_ref(deque.end).* = item
  deque.end = deque.end.inc().modulo(deque.data.len)
}
fun pop_back[T](deque: &Deque[T]): T {
  if deque.is_empty() then panic("pop_back on empty deque")
  deque.end = if deque.end.equals(0_U64)
    then deque.data.len
    else deque.end.dec()
  deque.data.get(deque.end)
}
fun get[T](deque: Deque[T], index: U64): T { deque.get_ref(index).* }
fun get_ref[T](deque: Deque[T], index: U64): &T {
  deque.data.get_ref(index.add(deque.start).modulo(deque.data.len))
}
fun to_slices[T](deque: Deque[T]): Tuple[Slice[T], Slice[T]] {
  if deque.end.is_at_least(deque.start)
  then tuple(deque.data.subslice(deque.start, deque.end), empty_slice[T]())
  else tuple(
    deque.data.subslice(deque.start, deque.data.len),
    deque.data.subslice(0_U64, deque.start)
  )
}
fun equals[T](a: Deque[T], b: Deque[T]): Bool {
  if a.len().notEquals(b.len()) then return Bool.false
  for i in 0_U64.to(a.len()) do
    if a.get(i).notEquals(b.get(i)) then return Bool.false
  Bool.true
}

| Map   
| Stores key-value-pairs for efficient lookup. The key has to support hash and
| equals.
struct Map[K, V] { buckets: Slice[MapBucket[K, V]], size: U64 }
enum MapBucket[K, V] { empty, filled: MapEntry[K, V] }
struct MapEntry[K, V] { key: K, value: V }
fun map[K, V](): Map[K, V] {
  Map[K, V].{
    buckets = filled_slice(8_U64, MapBucket[K, V].empty),
    size = 0_U64,
  }
}
fun is_empty[K, V](map: Map[K, V]): Bool { map.size.equals(0_U64) }
fun insert[K, V](map: &Map[K, V], key: K, value: V) {
  var fill_percentage = 100_U64.multiply(map.size).divide(map.buckets.len)
  if fill_percentage.is_at_least(60_U64) then {
    var old_buckets = map.buckets
    map.* = Map[K, V].{
      buckets = filled_slice(
        map.buckets.len.multiply(2_U64),
        MapBucket[K, V].empty
      ),
      size = 0_U64,
    }
    for bucket in &old_buckets.iter() do
      switch bucket
      case empty {}
      case filled(entry) map.raw_insert(entry.key, entry.value)
  }
  map.raw_insert(key, value)
}
fun raw_insert[K, V](map: &Map[K, V], key: K, value: V) {
  var i = key.hash().modulo(map.buckets.len)
  loop {
    var bucket = map.buckets.get_ref(i)
    switch bucket.*
    case empty {
      bucket.* = MapBucket[K, V].filled(MapEntry[K, V].{ key = key, value = value })
      map.size = map.size.add(1_U64)
      break
    }
    case filled(entry)
      if entry.key.equals(key) then {
        bucket.* = MapBucket[K, V].filled(MapEntry[K, V].{ key = key, value = value })
        break
      } else i = i.add(1_U64).modulo(map.buckets.len)
  }
}
fun contains[K, V](map: Map[K, V], key: K): Bool { map.get(key).is_some() }
fun get[K, V](map: Map[K, V], key: K): Maybe[V] {
  switch map.get_ref(key)
  case some(val) Maybe[V].some(val.*)
  case none Maybe[V].none
}
fun get_ref[K, V](map: Map[K, V], key: K): Maybe[&V] {
  var i = key.hash().modulo(map.buckets.len)
  loop {
    var bucket = map.buckets.get_ref(i)
    switch bucket.*
    case empty return Maybe[&V].none
    case filled(entry)
      if entry.key.equals(key)
      then return Maybe[&V].some(&entry.value)
      else i = i.add(1_U64).modulo(map.buckets.len)
  }
  | TODO: make it so that this is no longer necessary
  Maybe[&V].none
}
fun dump[K, V, W](map: Map[K, V], writer: W) {
  char('{).dump(writer)
  var first = Bool.true
  for bucket in &map.buckets.iter() do
    switch bucket
    case empty {}
    case filled(entry) {
      if first then first = Bool.false else str(", ").dump(writer)
      entry.key.dump(writer)
      str(": ").dump(writer)
      entry.value.dump(writer)
    }
  char('}).dump(writer)
}
fun iter[K, V](map: Map[K, V]): MapIter[K, V] {
  MapIter[K, V].{ buckets = map.buckets, index = 0_U64 }
}
struct MapIter[K, V] { buckets: Slice[MapBucket[K, V]], index: U64 }
fun next[K, V](map: &MapIter[K, V]): Maybe[MapEntry[K, V]] {
  loop {
    if map.index.is_at_least(map.buckets.len)
    then return Maybe[MapEntry[K, V]].none
    map.index = map.index.add(1_U64)
    switch map.buckets.get(map.index.subtract(1_U64))
    case empty {}
    case filled(entry) return Maybe[MapEntry[K, V]].some(entry)
  }
  Maybe[MapEntry[K, V]].none | TODO: remove
}

| Set  
struct Set[T] { map: Map[T, Nothing] }
fun set[T](): Set[T] { Set[T].{ map = map[T, Nothing]() } }
fun is_empty[T](set: Set[T]): Bool { set.map.size.equals(0_U64) }
fun insert[T](set: &Set[T], value: T) { set.map.&.insert(value, {}) }
fun contains[T](set: &Set[T], value: T): Bool { set.map.get(value).is_some() }
fun dump[T, W](set: Set[T], writer: W) {
  char('{).dump(writer)
  var first = Bool.true
  for item in &set.iter() do {
    if first then first = Bool.false else str(", ").dump(writer)
    item.dump(writer)
  }
  char('}).dump(writer)
}
fun iter[T](set: Set[T]): SetIter[T] {
  SetIter[T].{ buckets = set.map.buckets, index = 0_U64 }
}
struct SetIter[T] { buckets: Slice[MapBucket[T, Nothing]], index: U64 }
fun next[T](set: &SetIter[T]): Maybe[T] {
  loop {
    if set.index.is_at_least(set.buckets.len) then return Maybe[T].none
    set.index = set.index.add(1_U64)
    switch set.buckets.get(set.index.subtract(1_U64))
    case empty {}
    case filled(entry) return Maybe[T].some(entry.key)
  }
  Maybe[U64].none | TODO: remove
}

| TODO: segment tree, treap
