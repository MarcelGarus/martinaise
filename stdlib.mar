| Welcome to Martinaise!
| This is the standard library. Be careful when deleting code here because this
| may crash the compiler.

| Nothing
| A type with only one instance. Functions that don't explicitly return a value
| return Nothing instead.
struct Nothing {}

| Never
| Some expressions always abort control flow, for example `return 3`. These
| evaluate to the Never type.
struct Never {} | TODO: Make this an enum

fun identity[T](value: T): T { value }

| Printing
| Values with a dump(writer) function can be printed. Writers are anything with
| a write(U8) function. The print function writes the dumped values to stdout
| using the builtin function print_to_stdout(U8).
struct StdoutWriter {}
fun write(sow: StdoutWriter, c: U8) { print_to_stdout(c) }
fun print[T](value: T) { value.dump(StdoutWriter.{}) }
fun println[T](value: T) { print(value) StdoutWriter.{}.write(10_u8) }

| Bool
enum Bool { true, false }
fun not(a: Bool): Bool { if a { Bool.false } else { Bool.true } }
fun and(a: Bool, b: Bool): Bool { if a { b } else { a } }
fun or(a: Bool, b: Bool): Bool { if a { Bool.true } else { b } }
fun xor(a: Bool, b: Bool): Bool { if a { not(b) } else { b } }
fun implies(a: Bool, b: Bool): Bool { if a { b } else { Bool.true } }
fun dump[W](b: Bool, writer: W) {
  if b { "true" } else { "false" }.dump(writer)
}

| Maybe
| Like Option in Rust, but with the cooler Haskell name.
enum Maybe[T] { some: T, none }
fun flatten[T](maybe: Maybe[Maybe[T]]): Maybe[T] {
  switch maybe { some(inner) { inner } none { Maybe[T].none() } }
}
fun dump[T, W](maybe: Maybe[T], writer: W) {
  switch maybe {
    some(val) { "some(".dump(writer) val.dump(writer) ').dump(writer) }
    none { "none".dump(writer) }
  }
}
fun unwrap[T](maybe: Maybe[T]): T {
  switch maybe {
    some(val) { return val }
    none { println("Called none.unwrap") return 0_u8 }
  }
}

| Ordering
enum Ordering { less, equal, greater }
fun is_less(ord: Ordering): Bool {
  switch ord { less { Bool.true } equal { Bool.false } greater { Bool.false } }
}
fun is_equal(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.true } greater { Bool.false } }
}
fun is_greater(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.false } greater { Bool.true } }
}
fun is_less_or_equal(ord: Ordering): Bool {
  switch ord { less { Bool.true } equal { Bool.true } greater { Bool.false } }
}
fun is_greater_or_equal(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.true } greater { Bool.true } }
}
fun dump[W](ord: Ordering, writer: W) {
  switch ord {
    less { "less" }
    equal { "equal" }
    greater { "greater" }
  }.dump(writer)
}

| Int
| Integers are built into the language. There are several types with different
| signedness and bit amount available as {U, I} x {8, 16, 32, 64}. For example,
| U64 is an unsigned integer of 64 bits.
| All integers also support the following mathematical operations:
| - add(Int, Int): Int
| - subtract(Int, Int): Int
| - multiply(Int, Int): Int
| - divide(Int, Int): Int
| - modulo(Int, Int): Int
| - compare_to(Int, Int): Ordering
| - to_<OtherInt>(Int): OtherInt, e.g. to_U8() for non-U8 ints
fun is_less_than(a: U8, b: U8): Bool { a.compare_to(b).is_less() }
fun equals(a: U8, b: U8): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U8, b: U8): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U8, b: U8): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U8, b: U8): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U16, b: U16): Bool { a.compare_to(b).is_less() }
fun equals(a: U16, b: U16): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U16, b: U16): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U16, b: U16): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U16, b: U16): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U32, b: U32): Bool { a.compare_to(b).is_less() }
fun equals(a: U32, b: U32): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U32, b: U32): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U32, b: U32): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U32, b: U32): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: U64, b: U64): Bool { a.compare_to(b).is_less() }
fun equals(a: U64, b: U64): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: U64, b: U64): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: U64, b: U64): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: U64, b: U64): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I8, b: I8): Bool { a.compare_to(b).is_less() }
fun equals(a: I8, b: I8): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I8, b: I8): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I8, b: I8): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I8, b: I8): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I16, b: I16): Bool { a.compare_to(b).is_less() }
fun equals(a: I16, b: I16): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I16, b: I16): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I16, b: I16): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I16, b: I16): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I32, b: I32): Bool { a.compare_to(b).is_less() }
fun equals(a: I32, b: I32): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I32, b: I32): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I32, b: I32): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I32, b: I32): Bool { a.compare_to(b).is_less_or_equal() }
fun is_less_than(a: I64, b: I64): Bool { a.compare_to(b).is_less() }
fun equals(a: I64, b: I64): Bool { a.compare_to(b).is_equal() }
fun is_greater_than(a: I64, b: I64): Bool { a.compare_to(b).is_greater() }
fun is_at_least(a: I64, b: I64): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most(a: I64, b: I64): Bool { a.compare_to(b).is_less_or_equal() }
fun dump[W](int: U64, radix: U64, writer: W) {
  var divisor = 1_u64
  loop {
    if int.divide(divisor).is_less_than(radix) { break }
    divisor = divisor.multiply(radix)
  }
  loop {
    writer.write(int.divide(divisor).modulo(radix).to_U8().digit_to_char())
    if divisor.equals(1_u64) { break }
    divisor = divisor.divide(radix)
  }
}
fun digit_to_char(digit: U8): U8 {
  if digit.is_greater_than(9_u8) {
    digit.subtract(10_u8).add('a.value)
  } else {
    digit.add('0.value)
  }
}
fun dump[W](int: U8, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U16, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U32, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U64, writer: W) { int.dump(10_u64, writer) }

| Reference
| References (pointers to memory locations) are built into the compiler. &T is a
| reference to a T. You can get a reference to a value using the & operator on
| an expression. You can follow a reference using the expr.* syntax. References
| can also be converted to and from the address they are pointing at these
| builtin functions:
| - to_address(&T): U64
| - to_reference[T](U64): &T
| The builtin memory allocation functions don't have anything to do with
| references â€“ they just deal with untyped memory. The following builtin
| functions are used to build type-safe abstractions on top:
| - size_of_type[T](): U64
| - malloc(U64): U64
fun cast[T, U](value: &T): &U { value.to_address().to_reference[U]() }
fun new[T](value: T): &T {
  var ref = malloc(size_of_type[T]()).to_reference[T]()
  ref.* = value
  ref
}
fun add[T](ref: &T, offset: U64): &T {
  ref.to_address().add(offset.multiply(size_of_type[T]())).to_reference[T]()
}
fun dump_address[W](address: U64, writer: W) {
  | max U64 is  18446744073709551615
  var divisor = 1152921504606846976_u64 | 16 ^ something
  "0x".dump(writer)
  loop {
    writer.write(address.divide(divisor).modulo(16_u64).to_U8().digit_to_char())
    if divisor.equals(1_u64) { break }
    divisor = divisor.divide(16_u64)
  }
}

| Slice
| A slice is a memory region where values of the same type are right next to
| each other.
struct Slice[T] { data: &T, len: U64 }
fun get[T](slice: Slice[T], index: U64): &T { slice.data.add(index) }
fun subslice[T](slice: Slice[T], from: U64, to: U64): Slice[T] {
  Slice[T].{ data = slice.data.add(from), len = to.subtract(from) }
}
fun dump[T, W](slice: Slice[T], writer: W) {
  '[.dump(writer)
  var index = 0_u64
  loop {
    if index.equals(slice.len) { break }
    if index.is_greater_than(0_u64) { ", ".dump(writer) }
    slice.get(index).*.dump(writer)
    index = index.add(1_u64)
  }
  '].dump(writer)
}
fun equals[T](a: Slice[T], b: Slice[T]): Bool {
  if not(a.len.equals(b.len)) { return Bool.false }
  var i = 0_u64
  loop {
    if i.equals(a.len) { break }
    if not(a.get(i).*.equals(b.get(i).*)) { return Bool.false }
    i = i.add(1_u64)
  }
  return Bool.true
}
fun iter[T](slice: Slice[T]): SliceIter[T] {
  SliceIter[T].{ slice = slice, index = 0_u64 }
}
struct SliceIter[T] {
  slice: Slice[T],
  index: U64,
}
fun next[T](iter: &SliceIter[T]): Maybe[&T] {
  var item = if iter.*.index.is_less_than(iter.*.slice.len) {
    Maybe[&T].some(iter.*.slice.get(iter.*.index))
  } else {
    Maybe[&T].none
  }
  iter.*.index = iter.*.index.add(1_u64)
  item
}

| Vec
struct Vec[T] {
  data: &T,
  len: U64,
  capacity: U64,
}
fun vec[T](): Vec[T] {
  Vec[T].{ data = 0_u64.to_reference[T](), capacity = 0_u64, len = 0_u64 }
}
fun push[T](vec: &Vec[T], item: T) {
  if vec.*.capacity.equals(0_u64) {
    vec.*.capacity = 8_u64
    vec.*.data = malloc(vec.*.capacity.multiply(size_of_type[T]())).to_reference[T]()
  }
  if vec.*.capacity.equals(vec.*.len) {
    var previous_data = vec.*.data
    vec.*.capacity = vec.*.capacity.multiply(2_u64)
    vec.*.data = malloc(vec.*.capacity.multiply(size_of_type[T]())).to_reference[T]()
    var i = 0_u64
    loop {
      if i.equals(vec.*.len) { break }
      var new_item = vec.*.data.add(i)
      new_item.* = previous_data.add(i).*
      i = i.add(1_u64)
    }
  }
  var new_item = vec.*.data.add(vec.*.len)
  new_item.* = item
  vec.*.len = vec.*.len.add(1_u64)
}
fun get[T](vec: Vec[T], index: U64): &T {
  | TODO: enable check when panic exists
  |if index.is_less_than(vec.len) {
    vec.data.add(index)
  |}
}
fun to_slice[T](vec: Vec[T]): Slice[T] {
  Slice[T].{ data = vec.data, len = vec.len }
}
fun iter[T](vec: Vec[T]): SliceIter[T] { vec.to_slice().iter() }
fun dump[T, W](vec: Vec[T], writer: W) {
  '[.dump(writer)
  var index = 0_u64
  loop {
    if index.equals(vec.len) { break }
    if index.is_greater_than(0_u64) { ", ".dump(writer) }
    vec.get(index).*.dump(writer)
    index = index.add(1_u64)
  }
  '].dump(writer)
}

| Char
| Essentially just a U8, but it's formatted differently.
struct Char { value: U8 }
fun dump[W](c: Char, writer: W) { writer.write(c.value) }
fun newline_char(): Char { Char.{ value = 10_u8 } }

| Str
| Strings are essentially just a Slice[U8], but they are formatted differently.
struct Str { bytes: Slice[U8] }
fun dump[W](str: Str, writer: W) {
  var index = 0_u64
  loop {
    if index.equals(str.bytes.len) { break }
    writer.write(str.bytes.get(index).*)
    index = index.add(1_u64)
  }
}

struct Point[T] { x: T, y: T }
fun add[T](a: Point[T], b: Point[T]): Point[T] {
  return Point[T].{ x = a.x.add(b.x), y = a.y.add(b.y) }
}
fun dump[T, W](point: Point[T], writer: W) {
  '(.dump(writer)
  point.x.dump(writer)
  ',.dump(writer)
  ' .dump(writer)
  point.y.dump(writer)
  ').dump(writer)
}

| TODO: string, range, result, hash map, segment tree, treap
