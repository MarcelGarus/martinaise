| Welcome to Martinaise!
| This is the standard library. Be careful when deleting code here because this
| may crash the compiler.

| Nothing
| A type with only one instance. Functions that don't explicitly return a value
| return Nothing instead.
struct Nothing {}
fun dump[W](nothing: Nothing, writer: W) { "nothing".dump(writer) }

| Never
| Some expressions always abort control flow, for example `return 3`. These
| evaluate to the Never type.
struct Never {} | TODO: Make this an enum

fun identity[T](value: T): T { value }
fun notEquals[T](a: T, b: T): Bool { not(a.equals(b)) }

| Printing
| The print and println functions can print any value with a dump(writer)
| function. Writers are anything with a write(U8) function. The prints and
| printlns functions print the argument as a string.
struct StdoutWriter {}
fun write(sow: StdoutWriter, c: U8) {
  print_to_stdout(c) | This is a builtin function.
}
fun print[T](value: T) { value.dump(StdoutWriter.{}) }
fun println[T](value: T) { print(value) StdoutWriter.{}.write(newline()) }
fun prints(message: Slice[U8]) { print(str(message)) }
fun printsln(message: Slice[U8]) { println(str(message)) }
fun newline(): U8 { 10_U8 }

| Char
| Essentially just a U8, but it's formatted differently. When you write
| something like 'a in the source code, the corresponding Char is created.
struct Char { value: U8 }
fun char(value: U8): Char { Char.{ value = value } }
fun dump[W](c: Char, writer: W) { writer.write(c.value) }
| TODO: refactor to variable when we have global variables

| Str
| Strings are essentially just a Slice[U8], but they are formatted differently.
struct Str { bytes: Slice[U8] }
fun str(bytes: Slice[U8]): Str { Str.{ bytes = bytes } }
fun dump[W](str: Str, writer: W) {
  var index = 0_U64
  loop {
    if index.equals(str.bytes.len) { break }
    writer.write(str.bytes.get(index))
    index = index.add(1_U64)
  }
}

| Bool
enum Bool { true, false }
fun not(a: Bool): Bool { if a { Bool.false } else { Bool.true } }
fun and(a: Bool, b: Bool): Bool { if a { b } else { a } }
fun or(a: Bool, b: Bool): Bool { if a { Bool.true } else { b } }
fun xor(a: Bool, b: Bool): Bool { if a { not(b) } else { b } }
fun implies(a: Bool, b: Bool): Bool { if a { b } else { Bool.true } }
fun dump[W](b: Bool, writer: W) {
  if b { "true" } else { "false" }.dump(writer)
}

| Maybe
| Like Option in Rust, but with the cooler Haskell name.
enum Maybe[T] { some: T, none }
fun flatten[T](maybe: Maybe[Maybe[T]]): Maybe[T] {
  switch maybe { some(inner) { inner } none { Maybe[T].none() } }
}
fun is_some[T](maybe: Maybe[T]): Bool {
  switch maybe { some(_) { Bool.true } none { Bool.false } }
}
fun is_none[T](maybe: Maybe[T]): Bool {
  switch maybe { some(_) { Bool.false } none { Bool.true } }
}
fun dump[T, W](maybe: Maybe[T], writer: W) {
  switch maybe {
    some(val) { "some(".dump(writer) val.dump(writer) ').dump(writer) }
    none { "none".dump(writer) }
  }
}
fun unwrap[T](maybe: Maybe[T]): T {
  switch maybe {
    some(val) { return val }
    none { panic("Called none.unwrap") }
  }
}

| Ordering
enum Ordering { less, equal, greater }
fun is_less(ord: Ordering): Bool {
  switch ord { less { Bool.true } equal { Bool.false } greater { Bool.false } }
}
fun is_equal(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.true } greater { Bool.false } }
}
fun is_greater(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.false } greater { Bool.true } }
}
fun is_less_or_equal(ord: Ordering): Bool {
  switch ord { less { Bool.true } equal { Bool.true } greater { Bool.false } }
}
fun is_greater_or_equal(ord: Ordering): Bool {
  switch ord { less { Bool.false } equal { Bool.true } greater { Bool.true } }
}
fun dump[W](ord: Ordering, writer: W) {
  switch ord {
    less { "less" }
    equal { "equal" }
    greater { "greater" }
  }.dump(writer)
}

| Pair
struct Pair[A, B] { a: A, b: B }
|fun enumerate[I](iter: I): Enumerated[I] {
|  Enumerated[I].{ iter = iter, counter = 0_U64 }
|}
|struct Enumerated[T, I] { iter: I, counter: U64 }
| TODO: Support inferring part of the return type like here
|fun next[I](self: &Enumerated[I]): Maybe[Pair[U64, _]] {
|  var line = vec[U8]()
|  loop {
|    switch &self.*.iter.&.next() {
|      none {
|        if line.len.is_greater_than(0_U64) { break } else { return Maybe[Slice[U8]].none }
|        Nothing.{}
|      }
|      some(c) {
|        if c.equals(newline()) {
|          break
|        } else {
|          line.&.push(c)
|        }
|      }
|    }
|  }
|  Maybe[Slice[U8]].some(line.to_slice())
|}

| Int
| Integers are built into the language. There are several types with different
| signedness and bit amount available as {U, I} x {8, 16, 32, 64}. For example,
| U64 is an unsigned integer of 64 bits.
| All integers also support the following mathematical operations:
| - add(Int, Int): Int
| - subtract(Int, Int): Int
| - multiply(Int, Int): Int
| - divide(Int, Int): Int
| - modulo(Int, Int): Int
| - compare_to(Int, Int): Ordering
| - to_<OtherInt>(Int): OtherInt, e.g. to_U8() for non-U8 ints
fun inc(a: U8): U8 { a.add(1_U8) }
fun inc(a: U16): U16 { a.add(1_U16) }
fun inc(a: U32): U32 { a.add(1_U32) }
fun inc(a: U64): U64 { a.add(1_U64) }
fun inc(a: I8): I8 { a.add(1_I8) }
fun inc(a: I16): I16 { a.add(1_I16) }
fun inc(a: I32): I32 { a.add(1_I32) }
fun inc(a: I64): I64 { a.add(1_I64) }
fun equals(a: U8, b: U8): Bool { a.compare_to(b).is_equal() }
fun equals(a: U16, b: U16): Bool { a.compare_to(b).is_equal() }
fun equals(a: U32, b: U32): Bool { a.compare_to(b).is_equal() }
fun equals(a: U64, b: U64): Bool { a.compare_to(b).is_equal() }
fun equals(a: I8, b: I8): Bool { a.compare_to(b).is_equal() }
fun equals(a: I16, b: I16): Bool { a.compare_to(b).is_equal() }
fun equals(a: I32, b: I32): Bool { a.compare_to(b).is_equal() }
fun equals(a: I64, b: I64): Bool { a.compare_to(b).is_equal() }
fun is_less_than[T](a: T, b: T): Bool { a.compare_to(b).is_less() }
fun is_greater_than[T](a: T, b: T): Bool { a.compare_to(b).is_greater() }
fun is_at_least[T](a: T, b: T): Bool { a.compare_to(b).is_greater_or_equal() }
fun is_at_most[T](a: T, b: T): Bool { a.comapre_to(b).is_less_or_equal() }
fun min[T](a: T, b: T): T { if a.is_less_than(b) { a } else { b } }
fun max[T](a: T, b: T): T { if a.is_greater_than(b) { a } else { b } }
fun dump[W](int: U64, radix: U64, writer: W) {
  var divisor = 1_U64
  loop {
    if int.divide(divisor).is_less_than(radix) { break }
    divisor = divisor.multiply(radix)
  }
  loop {
    writer.write(int.divide(divisor).modulo(radix).to_U8().digit_to_char())
    if divisor.equals(1_U64) { break }
    divisor = divisor.divide(radix)
  }
}
fun digit_to_char(digit: U8): U8 {
  if digit.is_greater_than(9_U8) {
    digit.subtract(10_U8).add('a)
  } else {
    digit.add('0)
  }
}
fun dump[W](int: U8, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U16, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U32, writer: W) { int.to_U64().dump(writer) }
fun dump[W](int: U64, writer: W) { int.dump(10_U64, writer) }
fun parse_U64(bytes: Slice[U8]): U64 {
  var num = 0_U64
  for char in &bytes.iter() {
    if not('0.until('9).contains(char)) { panic("non-digit in supposed number") }
    num = num.multiply(10_U64).add(char.subtract('0).to_U64())
  }
  num
}

| Range
| Ranges have an inclusive start and exclusive end value.
struct Range[T] { start: T, end: T }
fun to[T](start: T, end: T): Range[T] { Range[T].{ start = start, end = end } }
fun until[T](start: T, end: T): Range[T] { Range[T].{ start = start, end = end.inc() } }
fun contains[T](range: Range[T], value: T): Bool {
  value.is_at_least(range.start).and(value.is_less_than(range.end))
}
fun is_empty[T](range: Range[T]): Bool { range.start.is_at_least(range.end) }
fun iter[T](range: Range[T]): RangeIter[T] { RangeIter[T].{ rest = range } }
struct RangeIter[T] { rest: Range[T] }
fun next[T](iter: &RangeIter[T]): Maybe[T] {
  if iter.*.rest.is_empty() {
    Maybe[T].none
  } else {
    var current = iter.*.rest.start
    iter.*.rest.start = current.inc()
    Maybe[T].some(current)
  }
}

| Reference
| References (pointers to memory locations) are built into the compiler. &T is a
| reference to a T. You can get a reference to a value using the & operator on
| an expression. You can follow a reference using the expr.* syntax. References
| can also be converted to and from the address they are pointing at these
| builtin functions:
| - to_address(&T): U64
| - to_reference[T](U64): &T
| The builtin memory allocation functions don't have anything to do with
| references â€“ they just deal with untyped memory. The following builtin
| functions are used to build type-safe abstractions on top:
| - size_of_type[T](): U64
| - malloc(U64): U64
fun cast[T, U](value: &T): &U { value.to_address().to_reference[U]() }
fun new[T](value: T): &T {
  var ref = malloc(size_of_type[T]()).to_reference[T]()
  ref.* = value
  ref
}
fun add[T](ref: &T, offset: U64): &T {
  ref.to_address().add(offset.multiply(size_of_type[T]())).to_reference[T]()
}
fun dump_address[W](address: U64, writer: W) {
  | max U64 is  18446744073709551615
  var divisor = 1152921504606846976_U64 | 16 ^ something
  "0x".dump(writer)
  loop {
    writer.write(address.divide(divisor).modulo(16_U64).to_U8().digit_to_char())
    if divisor.equals(1_U64) { break }
    divisor = divisor.divide(16_U64)
  }
}

| Slice
| A slice is a memory region where values of the same type are right next to
| each other.
struct Slice[T] { data: &T, len: U64 }
fun empty_slice[T](): Slice[T] {
  Slice[T].{ data = 0_U64.to_reference[T](), len = 0_U64 }
}
fun is_empty[T](slice: Slice[T]): Bool { slice.len.equals(0_U64) }
fun get[T](slice: Slice[T], index: U64): T { slice.data.add(index).* }
fun get_mut[T](slice: Slice[T], index: U64): &T {
  if 0_U64.to(slice.len).contains(index) {
    slice.data.add(index)
  } else {
    panic("Index out of bounds")
  }
}
fun subslice[T](slice: Slice[T], from: U64, to: U64): Slice[T] {
  Slice[T].{ data = slice.data.add(from), len = to.subtract(from) }
}
fun subslice[T](slice: Slice[T], from: U64): Slice[T] {
  slice.subslice(from, slice.len)
}
fun split(slice: Slice[U8], separator: Slice[U8]): Slice[Slice[U8]] {
  var result = vec[Slice[U8]]()
  for part in &slice.iter().iter_split(separator) {
    result.&.push(part)
  }
  result.to_slice()
}
fun lines(slice: Slice[U8]): Slice[Slice[U8]] { slice.split("
") }
fun dump[T, W](slice: Slice[T], writer: W) {
  char('[).dump(writer)
  var index = 0_U64
  loop {
    if index.equals(slice.len) { break }
    if index.is_greater_than(0_U64) { char(',).dump(writer) char(' ).dump(writer) }
    slice.get(index).dump(writer)
    index = index.add(1_U64)
  }
  char(']).dump(writer)
}
fun starts_with[T](slice: Slice[T], prefix: Slice[T]): Bool {
  if prefix.len.is_greater_than(slice.len) { return Bool.false }
  for i in &0_U64.to(prefix.len).iter() {
    if not(slice.get(i).equals(prefix.get(i))) { return Bool.false }
  }
  Bool.true
}
fun trim_prefix(slice: &Slice[U8], prefix: Slice[U8]) {
  if slice.*.starts_with(prefix) {
    slice.* = slice.*.subslice(prefix.len)
  } else {
    panic("Slice doesn't start with prefix")
  }
}
fun equals[T](a: Slice[T], b: Slice[T]): Bool {
  if a.len.equals(b.len) { starts_with(a, b) } else { Bool.false }
}
fun iter[T](slice: Slice[T]): SliceIter[T] {
  SliceIter[T].{ slice = slice, index = 0_U64 }
}
struct SliceIter[T] {
  slice: Slice[T],
  index: U64,
}
fun next[T](iter: &SliceIter[T]): Maybe[T] {
  var item = if iter.*.index.is_less_than(iter.*.slice.len) {
    Maybe[T].some(iter.*.slice.get(iter.*.index))
  } else {
    Maybe[T].none
  }
  iter.*.index = iter.*.index.add(1_U64)
  item
}
fun dump[T, W](iter: SliceIter[T], writer: W) {
  "<slice iter>".dump(writer)
}
fun rev_iter[T](slice: Slice[T]): SliceRevIter[T] {
  SliceRevIter[T].{ slice = slice, index = slice.len }
}
struct SliceRevIter[T] {
  slice: Slice[T],
  index: U64, | last yielded item
}
fun next[T](iter: &SliceRevIter[T]): Maybe[T] {
  if iter.*.index.is_greater_than(0_U64) {
    iter.*.index = iter.*.index.subtract(1_U64)
    Maybe[T].some(iter.*.slice.get(iter.*.index))
  } else {
    Maybe[T].none
  }
}
fun dump[T, W](iter: SliceRevIter[T], writer: W) {
  "<rev slice iter>".dump(writer)
}
fun iter_split[I](iter: I, separator: Slice[U8]): SplitIter[I] {
  SplitIter[I].{ iter = iter, separator = separator }
}
struct SplitIter[I] { iter: I, separator: Slice[U8] }
fun next[I](self: &SplitIter[I]): Maybe[Slice[U8]] {
  var line = vec[U8]()
  loop {
    switch self.*.iter.&.next() {
      none {
        if line.len.is_greater_than(0_U64) { break } else { return Maybe[Slice[U8]].none }
      }
      some(c) {
        line.&.push(c)
        if line.to_slice().subslice(line.len.subtract(self.*.separator.len)).equals(self.*.separator) {
          return Maybe[Slice[U8]].some(
            line.to_slice().subslice(0_U64, line.len.subtract(self.*.separator.len))
          )
        }
      }
    }
  }
  Maybe[Slice[U8]].some(line.to_slice())
}

| Vec
struct Vec[T] {
  data: &T,
  len: U64,
  capacity: U64,
}
fun vec[T](): Vec[T] {
  Vec[T].{ data = 0_U64.to_reference[T](), capacity = 0_U64, len = 0_U64 }
}
fun push[T](vec: &Vec[T], item: T) {
  if vec.*.capacity.equals(0_U64) {
    vec.*.capacity = 8_U64
    vec.*.data = malloc(vec.*.capacity.multiply(size_of_type[T]())).to_reference[T]()
  }
  if vec.*.capacity.equals(vec.*.len) {
    var previous_data = vec.*.data
    vec.*.capacity = vec.*.capacity.multiply(2_U64)
    vec.*.data = malloc(vec.*.capacity.multiply(size_of_type[T]())).to_reference[T]()
    var i = 0_U64
    loop {
      if i.equals(vec.*.len) { break }
      var new_item = vec.*.data.add(i)
      new_item.* = previous_data.add(i).*
      i = i.add(1_U64)
    }
  }
  var new_item = vec.*.data.add(vec.*.len)
  new_item.* = item
  vec.*.len = vec.*.len.add(1_U64)
}
fun get[T](vec: Vec[T], index: U64): T { vec.get_mut(index).* }
fun get_mut[T](vec: Vec[T], index: U64): &T {
  if 0_U64.to(vec.len).contains(index) {
    vec.data.add(index)
  } else {
    panic("Index out of bounds")
  }
}
fun to_slice[T](vec: Vec[T]): Slice[T] {
  Slice[T].{ data = vec.data, len = vec.len }
}
fun iter[T](vec: Vec[T]): SliceIter[T] { vec.to_slice().iter() }
fun dump[T, W](vec: Vec[T], writer: W) { vec.to_slice().dump(writer) }

struct Point[T] { x: T, y: T }
fun add[T](a: Point[T], b: Point[T]): Point[T] {
  Point[T].{ x = a.x.add(b.x), y = a.y.add(b.y) }
}
fun dump[T, W](point: Point[T], writer: W) {
  '(.dump(writer)
  point.x.dump(writer)
  ',.dump(writer)
  ' .dump(writer)
  point.y.dump(writer)
  ').dump(writer)
}

| TODO: result, hash map, segment tree, treap
