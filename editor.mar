| Editor  

| SDL2 Bindings  
| SDL2 has to be linked together with this program. Here are some wrappers that
| call the linked SDL functions. All SDL functions follow the system V calling
| convention, which means that the stack needs to be aligned to 16 bytes.

fun raw_sdl_init(flags: U64): U64 asm {
  mov rdi, [rsp + 16] ; flags
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_Init
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_quit() asm {
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_Quit
  add rsp, 8
  pop rsp
	; return
  ret
}
fun raw_sdl_get_error(): U64 asm {
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_GetError
  add rsp, 8
  pop rsp
	; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_delay(millis: U64) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_Delay
  add rsp, 8
  pop rsp
	; return
  ret
}

fun raw_sdl_create_window(
  title: OsStr, x: U64, y: U64, width: U64, height: U64
): Address asm {
  mov rdi, [rsp + 16] ; title
  mov rsi, [rsp + 24] ; x
  mov rdx, [rsp + 32] ; y
  mov rcx, [rsp + 40] ; width
  mov r8, [rsp + 48]  ; height
  mov r9, 4
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_CreateWindow
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_destroy_window(window: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_DestroyWindow
  add rsp, 8
  pop rsp
	; return
  ret
}

fun raw_sdl_create_renderer(window: Address): Address asm {
  mov rdi, [rsp + 16]
  mov rsi, -1
  mov rdx, 6
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_CreateRenderer
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_destroy_renderer(renderer: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_DestroyRenderer
  add rsp, 8
  pop rsp
	; return
  ret
}

fun raw_sdl_set_render_draw_color(
  renderer: Address, r: U64, g: U64, b: U64, a: U64
) asm {
  mov rdi, [rsp + 16]
  mov rsi, [rsp + 24]
  mov rdx, [rsp + 32]
  mov rcx, [rsp + 40]
  mov r8, [rsp + 48]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_SetRenderDrawColor
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_clear(renderer: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderClear
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_fill_rect(renderer: Address, rect: Address) asm {
  mov rdi, [rsp + 16] ; renderer
  mov rsi, [rsp + 24] ; rect
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderFillRect
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_present(renderer: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderPresent
  add rsp, 8
  pop rsp
  ; return
  ret
}

fun raw_sdl_poll_event(event: Address): U64 asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_PollEvent
  add rsp, 8
  pop rsp
	; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}

| Colors  

struct Color { r: U8, g: U8, b: U8 }

fun color(hex: U64): Color {
  Color {
    r = {hex / 16#10000}.and(16#ff).to_U8(),
    g = {hex / 16#100}.and(16#ff).to_U8(),
    b = {hex / 16#1}.and(16#ff).to_U8(),
  }
}
fun write[W](writer: W, color: Color) {
  writer."#
    '{if color.r >= 16:U8 then "" else "0"}{color.r.radix(16)}
    '{if color.g >= 16:U8 then "" else "0"}{color.g.radix(16)}
    '{if color.b >= 16:U8 then "" else "0"}{color.b.radix(16)}"
}

var black = color(16#000000)
var white = color(16#ffffff)
var red   = color(16#ff0000)

| Offset  

struct Offset { x: U64, y: U64 }

fun @(x: U64, y: U64): Offset { Offset { x, y } }
var origin = 0 @ 0
fun +(a: Offset, b: Offset): Offset { {a.x + b.x} @ {a.y + b.y} }
fun -(a: Offset, b: Offset): Offset { {a.x - b.x} @ {a.y - b.y} }
fun *(a: Offset, b: U64): Offset { b * a }
fun *(a: U64, b: Offset): Offset { {a * b.x} @ {a * b.y} }

| Rectangle  

struct Rect { offset: Offset, size: Offset }

fun @(offset: Offset, size: Offset): Rect { Rect { offset, size } }

| SDL wrappers  
| These are some type-safe wrappers around the SDL functions.

fun init_sdl(): Result[Nothing, U64] {
  var result = raw_sdl_init(62001)
  if result == 0 then ok[Nothing, U64]({}) else error[Nothing, U64](result)
}
fun quit_sdl() { raw_sdl_quit() }
fun delay(millis: U64) { raw_sdl_delay(millis) }

| A handle to an actual window that is opened.
struct Window { handle: Address }

fun create_window(title: Str, position: Offset, size: Offset): Window {
  var handle = raw_sdl_create_window(
    title.to_os_str(), position.x, position.y, size.x, size.y)
  Window { handle }
}
fun destroy(window: Window) { window.handle.raw_sdl_destroy_window() }

| A renderer is a stateful entity linked to a window. It is double-buffered, so
| all operations are hidden until you call renderer.present().
struct Renderer { handle: Address }

fun create_renderer(window: Window): Renderer {
  var handle = window.handle.raw_sdl_create_renderer()
  Renderer { handle }
}
fun destroy(renderer: Renderer) { renderer.handle.raw_sdl_destroy_renderer() }

fun set_color(renderer: Renderer, color: Color) {
  renderer.handle.raw_sdl_set_render_draw_color(
    color.r.to_U64(), color.g.to_U64(), color.b.to_U64(), 16#ff)
}
fun clear(renderer: Renderer) { renderer.handle.raw_sdl_render_clear() }
fun draw(renderer: Renderer, rect: Rect) {
  var sdl_rect = SdlRect {
    x = rect.offset.x.to_I32(), y = rect.offset.y.to_I32(),
    w = rect.size.x.to_I32(),   h = rect.size.y.to_I32(),
  }
  renderer.handle.raw_sdl_render_fill_rect(sdl_rect.&.to_address())
}
struct SdlRect { x: I32, y: I32, w: I32, h: I32 }
fun present(renderer: Renderer) { renderer.handle.raw_sdl_render_present() }

| Event handling.
enum Event {
  quit,
  text_input: Str,
  key_down: U8,
}
var event_buffer = uninitialized_slice[U8](2048).data.to_address()
fun poll_event(): Maybe[Event] {
  loop {
    if raw_sdl_poll_event(event_buffer) == 0 then break
    var type = event_buffer.cast[Address, &U32]().*
    | Events: https://wiki.libsdl.org/SDL2/SDL_Event
    | Event types: https://github.com/libsdl-org/SDL/blob/cacac6cc341d5856d1857bdcf7390551eed54865/include/SDL3/SDL_events.h
    if type == 16#100:U32 then return some(Event.quit)
    else if type == 16#303:U32 then {
      | TextInput {
      |   type: U32
      |   timestamp: U32
      |   windowId: U32
      |   text: char[32] (null terminated)
      | }
      var text = {event_buffer + 12}.cast[Address, OsStr]().to_str()
      return some(Event.text_input(text))
    }
    else if type == 16#300:U32 then {
      | KeyDown {
      |   type: U32
      |   timestamp: U32
      |   windowId: U32
      |   state: U8
      |   repeat: U8
      |   keysym: Keysym {
      |     scancode: Scancode: U32
      |     sym: Keycode: U8
      |     mod: U16
      |     _unused: U32
      |   }
      | }
      var keycode = {event_buffer + 16}.cast[Address, &U8]().*
      println("keycode = {keycode}")
      return some(Event.key_down(keycode))
    }
    else {
      stderr."unhandled event type 0x{type.radix(16)}{newline}"
      continue
    }
  }
  return none[Event]()
}

| Editor  

struct Editor {
  text: Vec[Char],
}

| Rendering  
| All letters are sized 5x8 pixels.

var pixel_size = 4

struct Glyph { a: U8, b: U8, c: U8, d: U8, e: U8 }
fun glyph(a: U64, b: U64, c: U64, d: U64, e: U64): Glyph {
  Glyph { a = a.to_U8(), b = b.to_U8(), c = c.to_U8(), d = d.to_U8(), e = e.to_U8() }
}
var font = {
  var map = map[Char, Glyph]().&
  map.put(newline,
              glyph(2#00100000, 2#01110000, 2#00100000, 2#00111000, 2#00000000))
  map.put(# , glyph(2#00000000, 2#00000000, 2#00000000, 2#00000000, 2#00000000))
  map.put(#!, glyph(2#00000000, 2#00000000, 2#01011111, 2#00000000, 2#00000000))
  map.put(#", glyph(2#00000000, 2#00000111, 2#00000000, 2#00000111, 2#00000000))
  map.put(##, glyph(2#00010100, 2#01111111, 2#00010100, 2#01111111, 2#00010100))
  map.put(#$, glyph(2#00100100, 2#00101010, 2#01101011, 2#00101010, 2#00010010))
  map.put(#%, glyph(2#01000011, 2#00110000, 2#00001000, 2#00000110, 2#01100001))
  map.put(#&, glyph(2#00110000, 2#01001010, 2#01011101, 2#00110010, 2#01001000))
  map.put(#', glyph(2#00000000, 2#00000000, 2#00000111, 2#00000000, 2#00000000))
  map.put(#(, glyph(2#00000000, 2#00111110, 2#01000001, 2#01000001, 2#00000000))
  map.put(#), glyph(2#00000000, 2#01000001, 2#01000001, 2#00111110, 2#00000000))
  map.put(#*, glyph(2#00000000, 2#00010100, 2#00001000, 2#00010100, 2#00000000))
  map.put(#+, glyph(2#00001000, 2#00001000, 2#00111110, 2#00001000, 2#00001000))
  map.put(#,, glyph(2#00000000, 2#10000000, 2#01100000, 2#00000000, 2#00000000))
  map.put(#-, glyph(2#00001000, 2#00001000, 2#00001000, 2#00001000, 2#00001000))
  map.put(#., glyph(2#00000000, 2#00000000, 2#01100000, 2#00000000, 2#00000000))
  map.put(#/, glyph(2#00000000, 2#00000000, 2#01100000, 2#00000000, 2#00000000))
  map.put(#0, glyph(2#00111110, 2#01010001, 2#01001001, 2#01000101, 2#00111110))
  map.put(#1, glyph(2#01000000, 2#01000010, 2#01111111, 2#01000000, 2#01000000))
  map.put(#2, glyph(2#01100010, 2#01010001, 2#01001001, 2#01001001, 2#01000110))
  map.put(#3, glyph(2#00100010, 2#01000001, 2#01001001, 2#01001001, 2#00110110))
  map.put(#4, glyph(2#00011000, 2#00010100, 2#00010010, 2#00010001, 2#01111111))
  map.put(#5, glyph(2#00100111, 2#01000101, 2#01000101, 2#00111001, 2#00100111))
  map.put(#6, glyph(2#00111100, 2#01001010, 2#01001001, 2#01001001, 2#00110000))
  map.put(#7, glyph(2#00000011, 2#00000001, 2#01110001, 2#00001001, 2#00000111))
  map.put(#8, glyph(2#00110110, 2#01001001, 2#01001001, 2#00001001, 2#00110110))
  map.put(#9, glyph(2#00000110, 2#01001001, 2#01001001, 2#00101001, 2#00011110))
  map.put(#:, glyph(2#00000000, 2#00000000, 2#01100110, 2#00000000, 2#00000000))
  map.put(#;, glyph(2#00000000, 2#10000000, 2#01100110, 2#00000000, 2#00000000))
  map.put(#<, glyph(2#00001000, 2#00010100, 2#00100010, 2#01000001, 2#00000000))
  map.put(#=, glyph(2#00100100, 2#00100100, 2#00100100, 2#00100100, 2#00100100))
  map.put(#>, glyph(2#00000000, 2#01000001, 2#00100010, 2#00010100, 2#00001000))
  map.put(#?, glyph(2#00000010, 2#00000001, 2#01010001, 2#00001001, 2#00000110))
  map.put(#@, glyph(2#00111110, 2#01000001, 2#01011101, 2#01010001, 2#00011110))
  map.put(#A, glyph(2#01111110, 2#00000101, 2#00000101, 2#00000101, 2#01111110))
  map.put(#B, glyph(2#01111111, 2#01000101, 2#01000101, 2#01000101, 2#00111010))
  map.put(#C, glyph(2#00111110, 2#01000001, 2#01000001, 2#01000001, 2#00100010))
  map.put(#D, glyph(2#01111111, 2#01000001, 2#01000001, 2#01000001, 2#00111110))
  map.put(#E, glyph(2#01111111, 2#01000101, 2#01000101, 2#01000001, 2#01000001))
  map.put(#F, glyph(2#01111111, 2#00000101, 2#00000101, 2#00000001, 2#00000001))
  map.put(#G, glyph(2#00111110, 2#01000001, 2#01000001, 2#01000101, 2#00111101))
  map.put(#H, glyph(2#01111111, 2#00000100, 2#00000100, 2#00000100, 2#01111111))
  map.put(#I, glyph(2#00000000, 2#01000001, 2#01111111, 2#01000001, 2#00000000))
  map.put(#J, glyph(2#00100000, 2#01000000, 2#01000000, 2#01000000, 2#00111111))
  map.put(#K, glyph(2#01111111, 2#00000100, 2#00000100, 2#00001010, 2#01110001))
  map.put(#L, glyph(2#01111111, 2#01000000, 2#01000000, 2#01000000, 2#01000000))
  map.put(#M, glyph(2#01111111, 2#00000010, 2#00000100, 2#00000010, 2#01111111))
  map.put(#N, glyph(2#01111111, 2#00000010, 2#00000100, 2#00001000, 2#01111111))
  map.put(#O, glyph(2#00111110, 2#01000001, 2#01000001, 2#01000001, 2#00111110))
  map.put(#P, glyph(2#01111111, 2#00000101, 2#00000101, 2#00000101, 2#00000010))
  map.put(#Q, glyph(2#00111110, 2#01000001, 2#01000001, 2#00100001, 2#01011110))
  map.put(#R, glyph(2#01111111, 2#00000101, 2#00000101, 2#00000101, 2#01111010))
  map.put(#S, glyph(2#00100010, 2#01000101, 2#01000101, 2#01000101, 2#00111001))
  map.put(#T, glyph(2#00000001, 2#00000001, 2#01111111, 2#00000001, 2#00000001))
  map.put(#U, glyph(2#00111111, 2#01000000, 2#01000000, 2#01000000, 2#00111111))
  map.put(#V, glyph(2#00001111, 2#00110000, 2#01000000, 2#00110000, 2#00001111))
  map.put(#W, glyph(2#01111111, 2#00100000, 2#00010000, 2#00100000, 2#01111111))
  map.put(#X, glyph(2#01110001, 2#00001010, 2#00000100, 2#00001010, 2#01110001))
  map.put(#Y, glyph(2#00000001, 2#00000010, 2#01111100, 2#00000010, 2#00000001))
  map.put(#Z, glyph(2#01100001, 2#01010001, 2#01001001, 2#01000101, 2#01000011))
  map.put(#[, glyph(2#00000000, 2#01111111, 2#01000001, 2#01000001, 2#00000000))
  map.put(#\, glyph(2#00000001, 2#00000110, 2#00001000, 2#00110000, 2#01000000))
  map.put(#], glyph(2#00000000, 2#01000001, 2#01000001, 2#01111111, 2#00000000))
  map.put(#^, glyph(2#00000100, 2#00000010, 2#00000001, 2#00000010, 2#00000100))
  map.put(#_, glyph(2#10000000, 2#10000000, 2#10000000, 2#10000000, 2#10000000))
  map.put(#`, glyph(2#00000000, 2#00000000, 2#00000001, 2#00000010, 2#00000000))
  map.put(#a, glyph(2#00100000, 2#01010100, 2#01010100, 2#01010100, 2#01111000))
  map.put(#b, glyph(2#01111111, 2#01001000, 2#01000100, 2#01000100, 2#00111000))
  map.put(#c, glyph(2#00111000, 2#01000100, 2#01000100, 2#01000100, 2#00101000))
  map.put(#d, glyph(2#00111000, 2#01000100, 2#01000100, 2#01001000, 2#01111111))
  map.put(#e, glyph(2#00111000, 2#01010100, 2#01010100, 2#01010100, 2#01011000))
  map.put(#f, glyph(2#00000100, 2#00000100, 2#01111110, 2#00000101, 2#00000101))
  map.put(#g, glyph(2#10011000, 2#10100100, 2#10100100, 2#10100100, 2#01111100))
  map.put(#h, glyph(2#01111111, 2#00001000, 2#00000100, 2#00000100, 2#01111000))
  map.put(#i, glyph(2#01000100, 2#01000100, 2#01111101, 2#01000000, 2#01000000))
  map.put(#j, glyph(2#01000000, 2#10000000, 2#10000100, 2#10000100, 2#01111101))
  map.put(#k, glyph(2#01111111, 2#00010000, 2#00010000, 2#00101000, 2#01000100))
  map.put(#l, glyph(2#01000001, 2#01000001, 2#01111111, 2#01000000, 2#01000000))
  map.put(#m, glyph(2#01111100, 2#00000100, 2#00011000, 2#00000100, 2#01111000))
  map.put(#n, glyph(2#01111100, 2#00000100, 2#00000100, 2#00000100, 2#01111000))
  map.put(#o, glyph(2#00111000, 2#01000100, 2#01000100, 2#01000100, 2#00111000))
  map.put(#p, glyph(2#11111100, 2#00101000, 2#00100100, 2#00100100, 2#00011000))
  map.put(#q, glyph(2#00011000, 2#00100100, 2#00100100, 2#00101000, 2#11111100))
  map.put(#r, glyph(2#01111100, 2#00001000, 2#00000100, 2#00000100, 2#00001000))
  map.put(#s, glyph(2#01001000, 2#01010100, 2#01010100, 2#01010100, 2#00100100))
  map.put(#t, glyph(2#00000100, 2#00000100, 2#00111111, 2#01000100, 2#01000100))
  map.put(#u, glyph(2#00111100, 2#01000000, 2#01000000, 2#01000000, 2#01111100))
  map.put(#v, glyph(2#00001100, 2#00110000, 2#01000000, 2#00110000, 2#00001100))
  map.put(#w, glyph(2#00111100, 2#01000000, 2#01110000, 2#01000000, 2#01111100))
  map.put(#x, glyph(2#01000100, 2#00101000, 2#00010000, 2#00101000, 2#01000100))
  map.put(#y, glyph(2#10011100, 2#10100000, 2#10100000, 2#10100000, 2#01111100))
  map.put(#z, glyph(2#01000100, 2#01100100, 2#01010100, 2#01001100, 2#01000100))
  map.put(#{, glyph(2#00000000, 2#00001000, 2#00110110, 2#01000001, 2#00000000))
  map.put(#|, glyph(2#00000000, 2#00000000, 2#01111111, 2#00000000, 2#00000000))
  map.put(#}, glyph(2#00000000, 2#01000001, 2#00110110, 2#00001000, 2#00000000))
  map.put(#~, glyph(2#00001000, 2#00000100, 2#00000100, 2#00001000, 2#00000100))
  map.*
}

fun render_char(renderer: Renderer, offset: Offset, char: Char) {
  switch font.get_maybe(char)
  case none
    renderer.draw({offset.x @ offset.y} @ {{5 * pixel_size} @ {8 * pixel_size}})
  case some(glyph)
    for x in 0..5 do for y in 0..8 do {
      var glyph_col =
        if x == 0 then glyph.a else if x == 1 then glyph.b
        else if x == 2 then glyph.c else if x == 3 then glyph.d else glyph.e
      var bit = glyph_col
      for i in 0..y do bit = bit / 2:U8
      var is_set = bit.modulo(2:U8) == 1:U8
      if is_set then renderer.draw(
        {{offset.x + {pixel_size * x}} @ {offset.y + {pixel_size * y}}} @
        {pixel_size @ pixel_size})
    }
}

fun main(args: Slice[Str]): Never {
  if args.len < 2 then {
    eprintln("Usage: editor <file>")
    exit(1:U8)
  }

  var file = args.get(1)
  var content = file.read_file().unwrap().to_str()

  init_sdl().unwrap()
  var window = create_window("Martinaise Editor", 500 @ 100, 1080 @ 920)
  var renderer = window.create_renderer()

  var editor = Editor { text = vec[Char]() }
  for char in content do editor.text.&.push(char)

  loop {
    switch poll_event()
    case none delay(100)
    case some(event)
      switch event
      case quit break
      case text_input(text) {
        stderr."Text input {text}{newline}"
        for char in text do editor.text.&.push(char)
      }
      case key_down(keycode) {
        stderr."Key down {keycode}{newline}"
        if keycode == 40:U8 then {
          println("Newline!")
          editor.text.&.push(newline)
        }
      }

    renderer.set_color(black)
    renderer.clear()
    renderer.set_color(red)

    var row = 0
    var col = 0
    for char in editor.text do {
      var base_x = {col * 6 * pixel_size} + 20
      var base_y = {row * 9 * pixel_size} + 20
      if char == newline then {
        row = row + 1
        col = 0
      } else {
        col = col + 1
        renderer.render_char(base_x @ base_y, char)
      }
    }

    renderer.present()
  }

  println("destroying stuff")
  renderer.destroy()
  window.destroy()

  quit_sdl()

  exit(0:U8)
}
