| Whirling  

| How Rendering Works  
| We create an SDL texture and render everything to that. This corresponds to
| the pixely design. This texture is then rendered to the window, scaled up to
| fill it.

| Colors  

struct Color { r: U8, g: U8, b: U8 }

fun color(hex: U64): Color {
  Color {
    r = {hex / 16#10000}.and(16#ff).to_U8(),
    g = {hex / 16#100}.and(16#ff).to_U8(),
    b = {hex / 16#1}.and(16#ff).to_U8(),
  }
}
fun write[W](writer: W, color: Color) {
  writer."#
    '{if color.r >= 16:U8 then "" else "0"}{color.r.radix(16)}
    '{if color.g >= 16:U8 then "" else "0"}{color.g.radix(16)}
    '{if color.b >= 16:U8 then "" else "0"}{color.b.radix(16)}"
}

| Thank you to @antoniusnaumann for the color theme!
var background   = color(16#1c1c1e)
var foreground   = color(16#f2f2f7)
var grey         = color(16#999999)
var dark_grey    = color(16#555555)
var blue         = color(16#1a94ff)
var purple       = color(16#d189f5)
var green        = color(16#41d496)
var lime         = color(16#7dd70f)
var yellow       = color(16#ffd60a)
var light_yellow = color(16#ffea80)
var orange       = color(16#ff9f0a)
var red          = color(16#ff5959)
var dark_red     = color(16#992222)

| Offset  

struct Offset { x: I32, y: I32 }

fun @(x: I32, y: I32): Offset { Offset { x, y } }
var origin = 0:I32 @ 0:I32
fun +(a: Offset, b: Offset): Offset { {a.x + b.x} @ {a.y + b.y} }
fun -(a: Offset, b: Offset): Offset { {a.x - b.x} @ {a.y - b.y} }
fun *(a: Offset, b: I32): Offset { b * a }
fun *(a: I32, b: Offset): Offset { {a * b.x} @ {a * b.y} }

| Rectangle  

struct Rect { offset: Offset, size: Offset }

fun @(offset: Offset, size: Offset): Rect { Rect { offset, size } }

| SDL2 Bindings  
| SDL2 has to be linked together with this program. Here are some wrappers that
| call the linked SDL functions. All SDL functions follow the system V calling
| convention, which means that the stack needs to be aligned to 16 bytes.

fun raw_sdl_init(flags: U64): U64 asm {
  mov rdi, [rsp + 16] ; flags
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_Init
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_quit() asm {
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_Quit
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_get_error(): U64 asm {
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_GetError
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_delay(millis: U64) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_Delay
  add rsp, 8
  pop rsp
  ; return
  ret
}

fun raw_sdl_create_window(
  title: OsStr, x: U64, y: U64, width: U64, height: U64
): Address asm {
  mov rdi, [rsp + 16] ; title
  mov rsi, [rsp + 24] ; x
  mov rdx, [rsp + 32] ; y
  mov rcx, [rsp + 40] ; width
  mov r8, [rsp + 48]  ; height
  mov r9, 4
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_CreateWindow
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_destroy_window(window: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_DestroyWindow
  add rsp, 8
  pop rsp
  ; return
  ret
}

fun raw_sdl_create_renderer(window: Address): Address asm {
  mov rdi, [rsp + 16]
  mov rsi, -1
  mov rdx, 6
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_CreateRenderer
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_destroy_renderer(renderer: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_DestroyRenderer
  add rsp, 8
  pop rsp
  ; return
  ret
}

fun raw_sdl_create_texture(
  renderer: Address, format: U32, access: I32, width: I32, height: I32
): Address asm {
  mov rdi, [rsp + 16] ; renderer
  mov rsi, [rsp + 24] ; format
  mov rdx, [rsp + 28] ; access
  mov rcx, [rsp + 32] ; width
  mov r8, [rsp + 36]  ; height
  mov r9, 4
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_CreateTexture
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}
fun raw_sdl_destroy_texture(texture: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_DestroyTexture
  add rsp, 8
  pop rsp
  ; return
  ret
}

fun raw_sdl_set_render_target(renderer: Address, texture: Address) asm {
  mov rdi, [rsp + 16] ; renderer
  mov rsi, [rsp + 24] ; texture
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_SetRenderTarget
  add rsp, 8
  pop rsp
  ; return
  ret
}

fun raw_sdl_set_render_draw_color(
  renderer: Address, r: U64, g: U64, b: U64, a: U64
) asm {
  mov rdi, [rsp + 16]
  mov rsi, [rsp + 24]
  mov rdx, [rsp + 32]
  mov rcx, [rsp + 40]
  mov r8, [rsp + 48]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_SetRenderDrawColor
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_clear(renderer: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderClear
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_copy(
  renderer: Address, texture: Address, src: Address, dest: Address
) asm {
  mov rdi, [rsp + 16] ; renderer
  mov rsi, [rsp + 24] ; texture
  mov rdx, [rsp + 32] ; src
  mov rcx, [rsp + 40] ; dst
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderCopy
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_draw_point(renderer: Address, x: I32, y: I32) asm {
  mov rdi, [rsp + 16] ; renderer
  mov rsi, [rsp + 24] ; x
  mov rdx, [rsp + 28] ; y
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderDrawPoint
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_fill_rect(renderer: Address, rect: Address) asm {
  mov rdi, [rsp + 16] ; renderer
  mov rsi, [rsp + 24] ; rect
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderFillRect
  add rsp, 8
  pop rsp
  ; return
  ret
}
fun raw_sdl_render_present(renderer: Address) asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_RenderPresent
  add rsp, 8
  pop rsp
  ; return
  ret
}

fun raw_sdl_poll_event(event: Address): U64 asm {
  mov rdi, [rsp + 16]
  ; make the call with a 16-bytes-aligned stack
  mov rbp, rsp
  and rsp, 0xfffffffffffffff0
  push rbp
  sub rsp, 8
  call SDL_PollEvent
  add rsp, 8
  pop rsp
  ; return
  mov r8, [rsp + 8]
  mov [r8], rax
  ret
}

| SDL wrappers  
| These are some type-safe wrappers around the SDL functions.

fun init_sdl(): Result[Nothing, U64] {
  var result = raw_sdl_init(62001)
  if result == 0 then ok[Nothing, U64]({}) else error[Nothing, U64](result)
}
fun quit_sdl() { raw_sdl_quit() }
fun delay(millis: U64) { raw_sdl_delay(millis) }

| A handle to an actual window that is opened.
struct Window { handle: Address }

fun create_window(title: Str, position: Offset, size: Offset): Window {
  var handle = raw_sdl_create_window(
    title.to_os_str(),
    position.x.cast[I32, U32]().to_U64(),
    position.y.cast[I32, U32]().to_U64(),
    size.x.cast[I32, U32]().to_U64(),
    size.y.cast[I32, U32]().to_U64(),
  )
  Window { handle }
}
fun destroy(window: Window) { window.handle.raw_sdl_destroy_window() }

| A renderer is a stateful entity linked to a window. It is double-buffered, so
| all operations are hidden until you call renderer.present().
struct Renderer { handle: Address }

fun create_renderer(window: Window): Renderer {
  var handle = window.handle.raw_sdl_create_renderer()
  Renderer { handle }
}
fun destroy(renderer: Renderer) { renderer.handle.raw_sdl_destroy_renderer() }

| A texture is a buffer for pixel data.
struct Texture { handle: Address }
enum TextureAccess { static, streaming, target }

fun create_texture(
  renderer: Renderer, access: TextureAccess, size: Offset
): Texture {
  var handle = renderer.handle.raw_sdl_create_texture(
    372645892:U32, | SDL_PIXELFORMAT_ARGB8888
    switch access
    case static 0:I32
    case streaming 1:I32
    case target 2:I32,
    size.x,
    size.y,
  )
  Texture { handle }
}
fun destroy(texture: Texture) { texture.handle.raw_sdl_destroy_texture() }

fun set_target(renderer: Renderer, texture: Texture) {
  renderer.handle.raw_sdl_set_render_target(texture.handle)
}
fun reset_target_to_window(renderer: Renderer) {
  renderer.handle.raw_sdl_set_render_target(null)
}

fun set_color(renderer: Renderer, color: Color) {
  renderer.handle.raw_sdl_set_render_draw_color(
    color.r.to_U64(), color.g.to_U64(), color.b.to_U64(), 16#ff)
}
fun clear(renderer: Renderer) { renderer.handle.raw_sdl_render_clear() }
fun draw(renderer: Renderer, point: Offset) {
  renderer.handle.raw_sdl_render_draw_point(point.x, point.y)
}
fun draw(renderer: Renderer, rect: Rect) {
  renderer.handle.raw_sdl_render_fill_rect(rect.&.to_address())
}
fun draw(renderer: Renderer, texture: Texture) {
  renderer.handle.raw_sdl_render_copy(texture.handle, null, null)
}
fun present(renderer: Renderer) { renderer.handle.raw_sdl_render_present() }

| Event handling.
enum Event {
  quit,
  text_input: Str,
  key_down: KeyDown,
  mouse_wheel: I32,
}
struct KeyDown { keycode: U8, modifiers: Modifiers }
struct Modifiers { value: U16 }
fun ctrl(mod: Modifiers): Bool {
  {mod.value.to_U64().and(64) != 0} / {mod.value.to_U64().and(128) != 0}
}
fun shift(mod: Modifiers): Bool {
  {mod.value.to_U64().and(1) != 0} / {mod.value.to_U64().and(2) != 0}
}

var event_buffer = uninitialized_slice[U8](2048).data.to_address()
fun poll_event(): Maybe[Event] {
  loop {
    if raw_sdl_poll_event(event_buffer) == 0 then break
    var type = event_buffer.cast[Address, &U32]().*
    | Events: https://wiki.libsdl.org/SDL2/SDL_Event
    | Event types: https://github.com/libsdl-org/SDL/blob/cacac6cc341d5856d1857bdcf7390551eed54865/include/SDL3/SDL_events.h
    if type == 16#100:U32 then return some(Event.quit)
    else if type == 16#303:U32 then {
      | offset | TextInput {
      |      0 |   type: U32
      |      4 |   timestamp: U32
      |      8 |   windowId: U32
      |     12 |   text: char[32] (null terminated)
      |        | }
      var text = {event_buffer + 12}.cast[Address, OsStr]().to_str()
      return some(Event.text_input(text))
    }
    else if type == 16#300:U32 then {
      | offset | KeyDown {
      |      0 |   type: U32
      |      4 |   timestamp: U32
      |      8 |   windowId: U32
      |     12 |   state: U8
      |     13 |   repeat: U8
      |     16 |   keysym: Keysym {
      |     16 |     scancode: Scancode: U32
      |     20 |     sym: Keycode: U8
      |     24 |     mod: U16
      |     28 |     _unused: U32
      |        |   }
      |        | }
      var keycode = {event_buffer + 20}.cast[Address, &U8]().*
      var mod = {event_buffer + 24}.cast[Address, &U16]().*
      return some(Event.key_down(KeyDown {
        keycode, modifiers = Modifiers { value = mod }
      }))
    }
    else if type == 16#403:U32 then {
      | offset | MouseWheel {
      |      0 |   type: U32
      |      4 |   timestamp: U32
      |      8 |   windowId: U32
      |     12 |   which: U32
      |     16 |   x: I32
      |     20 |   y: I32
      |     24 |   direction: U32 (normal or flipped)
      |     28 |   preciseX: Float
      |        |   preciseY: Float
      |        | }
      var y = {event_buffer + 20}.cast[Address, &I32]().*
      return some(Event.mouse_wheel(y))
    }
    else {
      stderr."unhandled event type 0x{type.radix(16)}{newline}"
      continue
    }
  }
  return none[Event]()
}

| Tokenizer  
| Instead of a full parser, syntax highlighting works with a simple tokenizer,
| making it more robust.

enum Token {
  comment,
  comment_title,
  name,
  declaration,
  control,
  type,
  function,
  literal,
  literal_support,
  operator,
  punctuation,
  default_,
}

var declaration_keywords = vec("fun", "var", "struct", "enum", "opaque")
var control_keywords = vec("if", "then", "else", "switch", "case", "default",
  "orelse", "loop", "for", "in", "do", "break", "continue", "return")
var operator_chars = "%!~@^\/`.&*+$-<>="

fun tokenize(input: Slice[Char], out: &Vec[Token]) {
  out.len = 0

  var cursor = 0
  loop {
    if cursor >= input.len then break
    var char = input.get(cursor)

    if char == #| then {
      var end = cursor
      loop {
        var c = input.get_maybe(end) orelse break
        if c == newline then break else end = end + 1
      }
      var comment = input.subslice(cursor..end).to_str()
      var token =
        if comment.ends_with("  ") then Token.comment_title else Token.comment
      for i in cursor..end do out.push(token)
      cursor = end
      continue
    }

    if {#A..=#Z}.contains(char) / {#a..=#z}.contains(char) / {char == #_} then {
      var is_type = {#A..=#Z}.contains(char) / {char == #_}
      var end = cursor
      loop {
        var c = input.get_maybe(end) orelse break
        if {#A..=#Z}.contains(c) / {#a..=#z}.contains(c) / {c == #_}
          / {#0..=#9}.contains(c)
        then end = end + 1
        else break
      }
      var word = input.subslice(cursor..end).to_str()
      var char_after_end = input.get_maybe(end) orelse #.
      var token =
        if is_type then Token.type else
          if {char_after_end == #(} / {char_after_end == #[}
          then Token.function
          else if declaration_keywords.iter().&.contains(word)
            then Token.declaration
            else if control_keywords.iter().&.contains(word)
              then Token.control
              else Token.name
      for i in cursor..end do out.push(token)
      cursor = end
      continue
    }

    if {#0..=#9}.contains(char) then {
      var end = cursor
      loop {
        var c = input.get_maybe(end) orelse break
        if {#0..=#9}.contains(c) / {c == #_} then end = end + 1 else break
      }
      var is_radix =
        switch input.get_maybe(end)
        case none false
        case some(char) char == ##
      if is_radix then {
        end = end + 1
        for i in cursor..end do out.push(Token.literal_support)
        cursor = end
        loop {
          var c = input.get_maybe(end) orelse break
          if {#0..=#9}.contains(c) / {c == #_}
            / {#a..=#z}.contains(c) / {#A..=#Z}.contains(c)
          then end = end + 1
          else break
        }
      }
      for i in cursor..end do out.push(Token.literal)
      cursor = end
      continue
    }

    if operator_chars.iter().&.contains(char) then {
      var end = cursor
      loop {
        var c = input.get_maybe(end) orelse break
        if operator_chars.iter().&.contains(c) then end = end + 1 else break
      }
      var name = input.subslice(cursor..end).to_str()
      var token =
        if {name == "."} / {name == "="}
        then Token.punctuation
        else Token.operator
      for i in cursor..end do out.push(token)
      cursor = end
      continue
    }

    if {char == #(} / {char == #)} / {char == #[} / {char == #]} / {char == #{}
      / {char == #}} / {char == #,} / {char == #.} / {char == #:}
    then {
      out.push(Token.punctuation)
      cursor = cursor + 1
      continue
    }

    if char == ## then {
      out.push(Token.literal_support)
      out.push(Token.literal)
      cursor = cursor + 2
      continue
    }

    var metaness = 0
    loop
      if {input.get_maybe(cursor) orelse break} == #'
      then {
        metaness = metaness + 1
        cursor = cursor + 1
        out.push(Token.literal)
      }
      else break
    if input.get_maybe(cursor) == some(#") then {
      cursor = cursor + 1
      out.push(Token.literal)
      loop {
        var string_ends = {input.get_maybe(cursor) orelse break} == #"
        for i in 0..metaness do {
          var char = input.get_maybe(cursor + i + 1)
            orelse {string_ends = false break }
          if char != #' then string_ends = false
        }
        if string_ends then {
          cursor = cursor + metaness + 1
          for i in 0..{metaness + 1} do out.push(Token.literal)
          break
        }
        out.push(Token.literal)
        cursor = cursor + 1
      }
      continue
    }

    out.push(Token.default_)
    cursor = cursor + 1
  }
}

| The Actual Editor  

var editor_size = 513:I32 @ 400:I32
var pixel_size = 2:I32
var window_size = editor_size * pixel_size

| Whirling  
| This is the name of the text area itself.

struct Whirling {
  text: Vec[Char],
  lines: Vec[U64],
  tokens: Vec[Token],
  needs_tokenization: Bool,
  scroll: I32,
  cursor: U64,
}

fun whirling(text: Str): Whirling {
  var whirling = Whirling {
    text    = vec[Char](),
    lines   = vec[U64](),
    tokens  = vec[Token](),
    needs_tokenization = false,
    scroll  = 0:I32,
    cursor  = 0,
  }
  for char in text do whirling.text.&.push(char)
  whirling.&.text_updated()
  whirling
}
| Calculates lines and tokens based on the text. Is pretty expensive.
fun text_updated(whirling: &Whirling) {
  whirling.lines.len = 0
  whirling.lines.&.push(0)
  for char in whirling.text.iter().enumerate() do
    if char.item == newline then whirling.lines.&.push(char.index)
  tokenize(whirling.text.to_slice(), whirling.tokens.&)
  whirling.needs_tokenization = false
}

| Given a cursor between 0 and text.len (inclusive), returns the start of the
| line that the cursor is in. This position is either 0 or right after a newline
| character.
fun line_start(whirling: Whirling, cursor: U64): U64 {
  loop {
    if cursor == 0 then break
    cursor = cursor - 1
    var is_at_end = false
    if cursor == whirling.text.len then is_at_end = true
    else if whirling.text.get(cursor) == newline then is_at_end = true
    if is_at_end then { cursor = cursor + 1 break }
  }
  cursor
}
| Given a cursor between 0 and text.len (inclusive), returns the end of the line
| that the cursor is in. This position is either text.len or it contains a
| newline character.
fun line_end(whirling: Whirling, cursor: U64): U64 {
  loop {
    if cursor == whirling.text.len then break
    if whirling.text.get(cursor) == newline then break
    cursor = cursor + 1
  }
  cursor
}

fun input(whirling: &Whirling, str: Str) {
  whirling.text.&.make_space_at(whirling.cursor, str.len, 0:U8.to_char())
  str.chars().copy_to(
    whirling.text.to_slice().subslice(whirling.cursor ..+ str.len))
  if not(str.chars().iter().&.contains(newline)) then {
    whirling.tokens.&.make_space_at(whirling.cursor, str.len, Token.default_)
    for line in whirling.lines.iter().enumerate() do
      whirling.lines.get_ref(line.index).* =
        if line.item >= whirling.cursor
        then line.item + str.len
        else line.item
    whirling.needs_tokenization = true
  } else whirling.text_updated()
  whirling.cursor = whirling.cursor + str.len
  whirling.scroll_cursor_into_view()
}
fun enter(whirling: &Whirling) { whirling.input("{newline}") }
fun backspace(whirling: &Whirling) {
  if whirling.cursor == 0 then return {}
  var index = whirling.cursor - 1
  var removed = whirling.text.get(index)
  whirling.text.&.remove(index..+1)
  if removed == newline then whirling.text_updated() else {
    whirling.tokens.&.remove(index..+1)
    for line in whirling.lines.iter().enumerate() do
      whirling.lines.get_ref(line.index).* =
        if line.item >= whirling.cursor
        then line.item - 1
        else line.item
    whirling.needs_tokenization = true
  }
  whirling.cursor = whirling.cursor - 1
  whirling.scroll_cursor_into_view()
}
fun delete(whirling: &Whirling) {
  if whirling.cursor == whirling.text.len then return {}
  whirling.cursor = whirling.cursor + 1
  whirling.backspace()
}

fun move_left(whirling: &Whirling) {
  if whirling.cursor == 0 then return {}
  whirling.cursor = whirling.cursor - 1
  whirling.scroll_cursor_into_view()
}
fun move_right(whirling: &Whirling) {
  if whirling.cursor == whirling.text.len then return {}
  whirling.cursor = whirling.cursor + 1
  whirling.scroll_cursor_into_view()
}
fun move_up(whirling: &Whirling) {
  var start_of_line = whirling.line_start(whirling.cursor)
  if start_of_line == 0 then return {}
  var chars_before = whirling.cursor - start_of_line
  var end_of_previous_line = start_of_line - 1
  var start_of_previous_line = whirling.line_start(end_of_previous_line)
  whirling.cursor = {start_of_previous_line + chars_before}
    .clamp(0, end_of_previous_line)
  whirling.scroll_cursor_into_view()
}
fun move_down(whirling: &Whirling) {
  var end_of_line = whirling.line_end(whirling.cursor)
  if end_of_line == whirling.text.len then return {}
  var start_of_line = whirling.line_start(whirling.cursor)
  var chars_before = whirling.cursor - start_of_line
  var start_of_next_line = end_of_line + 1
  var end_of_next_line = whirling.line_end(start_of_next_line)
  whirling.cursor = {start_of_next_line + chars_before}.clamp(0, end_of_next_line)
  whirling.scroll_cursor_into_view()
}
fun move_start(whirling: &Whirling) {
  whirling.cursor = whirling.line_start(whirling.cursor)
  whirling.scroll_cursor_into_view()
}
fun move_end(whirling: &Whirling) {
  whirling.cursor = whirling.line_end(whirling.cursor)
  whirling.scroll_cursor_into_view()
}

| Control + arrow keys move one word.
| Concretely:
| 1. Skip spaces
| 2. How many characters of punctuation follow?
|    0: Skip all letters
|    1: Skip the punctuation, then all letters after it
|    2: Skip all punctutation
fun is_word(char: Char): Bool {
  {#a..=#z}.contains(char) / {#A..=#Z}.contains(char) / {char == #_}
    / {#0..=#9}.contains(char)
}
fun is_punctuation(char: Char): Bool { {char != space} & not(char.is_word()) }
fun find_word_boundary[I](iter: &Iter[Char, I]): U64 {
  var consumed = 0
  var char = loop {
    var char = iter.next() orelse return consumed
    if char != space then break(char)
    consumed = consumed + 1
  }
  consumed = consumed + 1
  if char.is_punctuation()
  then {
    var char = iter.next() orelse return consumed
    if char == space then return consumed
    consumed = consumed + 1
    if char.is_word()
    then loop {
      if {iter.next() orelse return consumed}.is_word().not()
      then return consumed
      consumed = consumed + 1
    }
    else loop {
      if {iter.next() orelse return consumed}.is_punctuation().not()
      then return consumed
      consumed = consumed + 1
    }
  }
  else loop {
    if {iter.next() orelse return consumed}.is_word().not()
    then return consumed
    consumed = consumed + 1
  }
}
fun move_ctrl_left(whirling: &Whirling) {
  var amount_to_move = whirling.text.to_slice()
    .subslice(0..whirling.cursor).rev_iter().&.find_word_boundary()
  whirling.cursor = whirling.cursor - amount_to_move
  whirling.scroll_cursor_into_view()
}
fun move_ctrl_right(whirling: &Whirling) {
  var amount_to_move = whirling.text.to_slice()
    .subslice(whirling.cursor..whirling.text.len).iter().&.find_word_boundary()
  whirling.cursor = whirling.cursor + amount_to_move
  whirling.scroll_cursor_into_view()
}

fun scroll_to(whirling: &Whirling, y: I32) {
  var viewport_height = 9:I32 * whirling.lines.len.to_I32() + 3:I32
  whirling.scroll = y.clamp(
    0:I32,
    max(viewport_height - editor_size.y, 0:I32),
  )
}
fun scroll_by(whirling: &Whirling, amount: I32) {
  whirling.scroll_to(whirling.scroll + amount)
}
fun scroll_line_to_center(whirling: &Whirling, line: U64) {
  var scroll_so_line_is_at_center = 2:I32 | top padding
    + {9:I32 * line.to_I32()}
    - 4:I32 | about 9/2 to center the line
    - {editor_size.y.to_U64() / 2}.to_I32()
  whirling.scroll_to(scroll_so_line_is_at_center)
}
fun scroll_line_into_view(whirling: &Whirling, line: U64) {
  var scroll_so_line_is_at_center = 2:I32 | top padding
    + {9:I32 * line.to_I32()}
    - 4:I32 | about 9/2 to center the line
    - {editor_size.y.to_U64() / 2}.to_I32()
  var leeway = {editor_size.y.to_U64() / 4}.to_I32()
  whirling.scroll_to(whirling.scroll.clamp(
    scroll_so_line_is_at_center - leeway,
    scroll_so_line_is_at_center + leeway,
  ))
}
fun scroll_cursor_into_view(whirling: &Whirling) {
  var line = 0
  for l in whirling.lines.iter().enumerate() do
    if l.item > whirling.cursor then { line = l.index break }
  whirling.scroll_line_into_view(line)
}

fun handle_event(whirling: &Whirling, event: Event) {
  switch event
  case text_input(text) whirling.&.input(text)
  case key_down(keydown) {
    var keycode = keydown.keycode
    var modifiers = keydown.modifiers

    if keycode == 8:U8 then whirling.&.backspace()
    else if keycode == 13:U8 then whirling.&.enter()
    else if keycode == 74:U8 then whirling.&.move_start()
    else if keycode == 77:U8 then whirling.&.move_end()
    else if keycode == 79:U8 then {
      if modifiers.ctrl()
      then whirling.&.move_ctrl_right()
      else whirling.&.move_right()
    }
    else if keycode == 80:U8 then {
      if modifiers.ctrl()
      then whirling.&.move_ctrl_left()
      else whirling.&.move_left()
    }
    else if keycode == 81:U8 then whirling.&.move_down()
    else if keycode == 82:U8 then whirling.&.move_up()
    else if keycode == 103:U8 then {
      |if modifiers.ctrl() then whirling.&.go_to()
    }
    else if keycode == 127:U8 then whirling.&.delete()
    else stderr."Key down {keycode}{newline}"
  }
  case mouse_wheel(amount) whirling.&.scroll_by({0:I32 - 10:I32} * amount)
  default {}
}

| All letters are sized 5x8 pixels.
struct Glyph { a: U8, b: U8, c: U8, d: U8, e: U8 }
fun glyph(a: U64, b: U64, c: U64, d: U64, e: U64): Glyph {
  Glyph { a = a.to_U8(), b = b.to_U8(), c = c.to_U8(), d = d.to_U8(), e = e.to_U8() }
}
var font = {
  var map = map[Char, Glyph]().&
  map.put(newline,
              glyph(2#00100000, 2#01110000, 2#00100000, 2#00111000, 2#00000000))
  map.put(# , glyph(2#00000000, 2#00000000, 2#00000000, 2#00000000, 2#00000000))
  map.put(#!, glyph(2#00000000, 2#00000000, 2#01011111, 2#00000000, 2#00000000))
  map.put(#", glyph(2#00000000, 2#00000111, 2#00000000, 2#00000111, 2#00000000))
  map.put(##, glyph(2#00010100, 2#01111111, 2#00010100, 2#01111111, 2#00010100))
  map.put(#$, glyph(2#00100100, 2#00101010, 2#01101011, 2#00101010, 2#00010010))
  map.put(#%, glyph(2#01000011, 2#00110000, 2#00001000, 2#00000110, 2#01100001))
  map.put(#&, glyph(2#00110000, 2#01001010, 2#01011101, 2#00110010, 2#01001000))
  map.put(#', glyph(2#00000000, 2#00000000, 2#00000111, 2#00000000, 2#00000000))
  map.put(#(, glyph(2#00000000, 2#00111110, 2#01000001, 2#01000001, 2#00000000))
  map.put(#), glyph(2#00000000, 2#01000001, 2#01000001, 2#00111110, 2#00000000))
  map.put(#*, glyph(2#00000000, 2#00010100, 2#00001000, 2#00010100, 2#00000000))
  map.put(#+, glyph(2#00001000, 2#00001000, 2#00111110, 2#00001000, 2#00001000))
  map.put(#,, glyph(2#00000000, 2#10000000, 2#01100000, 2#00000000, 2#00000000))
  map.put(#-, glyph(2#00001000, 2#00001000, 2#00001000, 2#00001000, 2#00001000))
  map.put(#., glyph(2#00000000, 2#00000000, 2#01100000, 2#00000000, 2#00000000))
  map.put(#/, glyph(2#00100000, 2#00010000, 2#00001000, 2#00000100, 2#00000010))
  map.put(#0, glyph(2#00111110, 2#01010001, 2#01001001, 2#01000101, 2#00111110))
  map.put(#1, glyph(2#01000000, 2#01000010, 2#01111111, 2#01000000, 2#01000000))
  map.put(#2, glyph(2#01100010, 2#01010001, 2#01001001, 2#01001001, 2#01000110))
  map.put(#3, glyph(2#00100010, 2#01000001, 2#01001001, 2#01001001, 2#00110110))
  map.put(#4, glyph(2#00011000, 2#00010100, 2#00010010, 2#00010001, 2#01111111))
  map.put(#5, glyph(2#00100111, 2#01000101, 2#01000101, 2#01000101, 2#00111001))
  map.put(#6, glyph(2#00111100, 2#01001010, 2#01001001, 2#01001001, 2#00110000))
  map.put(#7, glyph(2#00000011, 2#00000001, 2#01110001, 2#00001001, 2#00000111))
  map.put(#8, glyph(2#00110110, 2#01001001, 2#01001001, 2#01001001, 2#00110110))
  map.put(#9, glyph(2#00000110, 2#01001001, 2#01001001, 2#00101001, 2#00011110))
  map.put(#:, glyph(2#00000000, 2#00000000, 2#01100110, 2#00000000, 2#00000000))
  map.put(#;, glyph(2#00000000, 2#10000000, 2#01100110, 2#00000000, 2#00000000))
  map.put(#<, glyph(2#00001000, 2#00010100, 2#00100010, 2#01000001, 2#00000000))
  map.put(#=, glyph(2#00100100, 2#00100100, 2#00100100, 2#00100100, 2#00100100))
  map.put(#>, glyph(2#00000000, 2#01000001, 2#00100010, 2#00010100, 2#00001000))
  map.put(#?, glyph(2#00000010, 2#00000001, 2#01010001, 2#00001001, 2#00000110))
  map.put(#@, glyph(2#00111110, 2#01000001, 2#01011101, 2#01010001, 2#00011110))
  map.put(#A, glyph(2#01111110, 2#00000101, 2#00000101, 2#00000101, 2#01111110))
  map.put(#B, glyph(2#01111111, 2#01000101, 2#01000101, 2#01000101, 2#00111010))
  map.put(#C, glyph(2#00111110, 2#01000001, 2#01000001, 2#01000001, 2#00100010))
  map.put(#D, glyph(2#01111111, 2#01000001, 2#01000001, 2#01000001, 2#00111110))
  map.put(#E, glyph(2#01111111, 2#01000101, 2#01000101, 2#01000001, 2#01000001))
  map.put(#F, glyph(2#01111111, 2#00000101, 2#00000101, 2#00000001, 2#00000001))
  map.put(#G, glyph(2#00111110, 2#01000001, 2#01000001, 2#01000101, 2#00111101))
  map.put(#H, glyph(2#01111111, 2#00000100, 2#00000100, 2#00000100, 2#01111111))
  map.put(#I, glyph(2#00000000, 2#01000001, 2#01111111, 2#01000001, 2#00000000))
  map.put(#J, glyph(2#00100000, 2#01000000, 2#01000000, 2#01000000, 2#00111111))
  map.put(#K, glyph(2#01111111, 2#00000100, 2#00000100, 2#00001010, 2#01110001))
  map.put(#L, glyph(2#01111111, 2#01000000, 2#01000000, 2#01000000, 2#01000000))
  map.put(#M, glyph(2#01111111, 2#00000010, 2#00000100, 2#00000010, 2#01111111))
  map.put(#N, glyph(2#01111111, 2#00000010, 2#00000100, 2#00001000, 2#01111111))
  map.put(#O, glyph(2#00111110, 2#01000001, 2#01000001, 2#01000001, 2#00111110))
  map.put(#P, glyph(2#01111111, 2#00000101, 2#00000101, 2#00000101, 2#00000010))
  map.put(#Q, glyph(2#00111110, 2#01000001, 2#01000001, 2#00100001, 2#01011110))
  map.put(#R, glyph(2#01111111, 2#00000101, 2#00000101, 2#00000101, 2#01111010))
  map.put(#S, glyph(2#00100010, 2#01000101, 2#01000101, 2#01000101, 2#00111001))
  map.put(#T, glyph(2#00000001, 2#00000001, 2#01111111, 2#00000001, 2#00000001))
  map.put(#U, glyph(2#00111111, 2#01000000, 2#01000000, 2#01000000, 2#00111111))
  map.put(#V, glyph(2#00001111, 2#00110000, 2#01000000, 2#00110000, 2#00001111))
  map.put(#W, glyph(2#01111111, 2#00100000, 2#00010000, 2#00100000, 2#01111111))
  map.put(#X, glyph(2#01110001, 2#00001010, 2#00000100, 2#00001010, 2#01110001))
  map.put(#Y, glyph(2#00000001, 2#00000010, 2#01111100, 2#00000010, 2#00000001))
  map.put(#Z, glyph(2#01100001, 2#01010001, 2#01001001, 2#01000101, 2#01000011))
  map.put(#[, glyph(2#00000000, 2#01111111, 2#01000001, 2#01000001, 2#00000000))
  map.put(#\, glyph(2#00000001, 2#00000110, 2#00001000, 2#00110000, 2#01000000))
  map.put(#], glyph(2#00000000, 2#01000001, 2#01000001, 2#01111111, 2#00000000))
  map.put(#^, glyph(2#00000100, 2#00000010, 2#00000001, 2#00000010, 2#00000100))
  map.put(#_, glyph(2#10000000, 2#10000000, 2#10000000, 2#10000000, 2#10000000))
  map.put(#`, glyph(2#00000000, 2#00000000, 2#00000001, 2#00000010, 2#00000000))
  map.put(#a, glyph(2#00100000, 2#01010100, 2#01010100, 2#01010100, 2#01111000))
  map.put(#b, glyph(2#01111111, 2#01001000, 2#01000100, 2#01000100, 2#00111000))
  map.put(#c, glyph(2#00111000, 2#01000100, 2#01000100, 2#01000100, 2#00101000))
  map.put(#d, glyph(2#00111000, 2#01000100, 2#01000100, 2#01001000, 2#01111111))
  map.put(#e, glyph(2#00111000, 2#01010100, 2#01010100, 2#01010100, 2#01011000))
  map.put(#f, glyph(2#00000100, 2#00000100, 2#01111110, 2#00000101, 2#00000101))
  map.put(#g, glyph(2#10011000, 2#10100100, 2#10100100, 2#10100100, 2#01111100))
  map.put(#h, glyph(2#01111111, 2#00001000, 2#00000100, 2#00000100, 2#01111000))
  map.put(#i, glyph(2#01000100, 2#01000100, 2#01111101, 2#01000000, 2#01000000))
  map.put(#j, glyph(2#01000000, 2#10000000, 2#10000100, 2#10000100, 2#01111101))
  map.put(#k, glyph(2#01111111, 2#00010000, 2#00010000, 2#00101000, 2#01000100))
  map.put(#l, glyph(2#01000001, 2#01000001, 2#01111111, 2#01000000, 2#01000000))
  map.put(#m, glyph(2#01111100, 2#00000100, 2#00011000, 2#00000100, 2#01111000))
  map.put(#n, glyph(2#01111100, 2#00000100, 2#00000100, 2#00000100, 2#01111000))
  map.put(#o, glyph(2#00111000, 2#01000100, 2#01000100, 2#01000100, 2#00111000))
  map.put(#p, glyph(2#11111100, 2#00101000, 2#00100100, 2#00100100, 2#00011000))
  map.put(#q, glyph(2#00011000, 2#00100100, 2#00100100, 2#00101000, 2#11111100))
  map.put(#r, glyph(2#01111100, 2#00001000, 2#00000100, 2#00000100, 2#00001000))
  map.put(#s, glyph(2#01001000, 2#01010100, 2#01010100, 2#01010100, 2#00100100))
  map.put(#t, glyph(2#00000100, 2#00000100, 2#00111111, 2#01000100, 2#01000100))
  map.put(#u, glyph(2#00111100, 2#01000000, 2#01000000, 2#01000000, 2#01111100))
  map.put(#v, glyph(2#00001100, 2#00110000, 2#01000000, 2#00110000, 2#00001100))
  map.put(#w, glyph(2#00111100, 2#01000000, 2#01110000, 2#01000000, 2#01111100))
  map.put(#x, glyph(2#01000100, 2#00101000, 2#00010000, 2#00101000, 2#01000100))
  map.put(#y, glyph(2#10011100, 2#10100000, 2#10100000, 2#10100000, 2#01111100))
  map.put(#z, glyph(2#01000100, 2#01100100, 2#01010100, 2#01001100, 2#01000100))
  map.put(#{, glyph(2#00001000, 2#00001000, 2#00110110, 2#01000001, 2#00000000))
  map.put(#|, glyph(2#00000000, 2#00000000, 2#01111111, 2#00000000, 2#00000000))
  map.put(#}, glyph(2#00000000, 2#01000001, 2#00110110, 2#00001000, 2#00001000))
  map.put(#~, glyph(2#00001000, 2#00000100, 2#00000100, 2#00001000, 2#00000100))
  map.*
}

fun render(renderer: Renderer, char: Char, offset: Offset) {
  switch font.get_maybe(char)
  case none renderer.draw({offset.x @ offset.y} @ {5:I32 @ 8:I32})
  case some(glyph)
    for x in 0..5 do for y in 0..8 do {
      var glyph_col =
        if x == 0 then glyph.a else if x == 1 then glyph.b
        else if x == 2 then glyph.c else if x == 3 then glyph.d else glyph.e
      var bit = glyph_col
      for i in 0..y do bit = bit / 2:U8
      var is_set = bit.modulo(2:U8) == 1:U8
      if is_set then renderer.draw(
        {offset.x + x.to_I32()} @ {offset.y + y.to_I32()})
    }
}

fun y_of_line(whirling: Whirling, line: U64): I32 {
  9:I32 * line.to_I32() + 2:I32 - whirling.scroll
}
fun num_line_number_digits(whirling: Whirling): U64 {
  var biggest = whirling.lines.len
  var digits = 1
  var divisor = 1
  loop if biggest / divisor < 10 then break else {
    digits  = digits + 1
    divisor = divisor * 10
  }
  digits
}
fun x_of_line_start(whirling: Whirling): I32 {
  6:I32 * whirling.num_line_number_digits().to_I32() + 5:I32
}

fun render(renderer: Renderer, whirling: Whirling) {
  renderer.set_color(background)
  renderer.clear()
  renderer.set_color(foreground)

  var visible_lines =
    {{{whirling.scroll - 2:I32}.max(0:I32).to_U64() / 9}.to_I32() - 1:I32}
      .max(0:I32).to_U64()
    ..
    {{{whirling.scroll + editor_size.y - 2:I32}.max(0:I32).to_U64() / 9}
      .to_I32() + 1:I32}
      .max(0:I32).to_U64().clamp(0, whirling.lines.len)
  | println("lines {visible_lines} are visible ({visible_lines.end - visible_lines.start} lines)")

  var visible_chars = {whirling.lines.get(visible_lines.start)}
    ..{if visible_lines.end == whirling.lines.len
       then whirling.text.len
       else whirling.lines.get(visible_lines.end)}
  | println("chars {visible_chars} are visible")

  | Line numbers
  {
    var divisor = 1
    for i in 1..whirling.num_line_number_digits() do divisor = divisor * 10

    renderer.set_color(dark_grey)
    for line in visible_lines do {
      var divisor = divisor
      var index = 0
      loop {
        var char = {line / divisor}.modulo(10).to_U8().digit_to_char()
        renderer.render(char,
          {2:I32 + {6 * index}.to_I32()} @ whirling.y_of_line(line))
        if divisor == 1 then break
        divisor = divisor / 10
        index = index + 1
      }
    }
  }

  | Characters
  var row = visible_lines.start
  var col = 0
  var x_of_line_start = whirling.x_of_line_start()
  for index in visible_chars do {
    var char = whirling.text.get(index)

    var x = x_of_line_start + {6:I32 * col.to_I32()}
    var y = whirling.y_of_line(row)

    if index == whirling.cursor then {
      renderer.set_color(grey)
      renderer.draw({x @ {y - 1:I32}} @ {2:I32 @ 9:I32})
    }

    if char == newline then {
      row = row + 1
      col = 0
      continue
    }

    var color =
      switch whirling.tokens.get(index)
      case comment         lime
      case comment_title   yellow
      case literal         red
      case literal_support dark_red
      case declaration     blue
      case control         purple
      case type            green
      case function        orange
      case name            light_yellow
      case operator        orange
      case punctuation     grey
      case default_        foreground
    renderer.set_color(color)
    renderer.render(char, x @ y)

    col = col + 1
  }
}

| Goto  
| Mode where you can enter a line number and you jump to that line. Press enter
| to move the cursor to the line, or escape to stay where you are.

struct Goto {
  whirling: &Whirling,
  original_scroll: I32,
  line: U64,
  active: Bool,
}

fun goto(whirling: &Whirling): Goto {
  Goto { whirling, original_scroll = 0:I32, line = 0, active = false }
}
fun reset(goto: &Goto) {
  goto.original_scroll = goto.whirling.scroll
  goto.line            = 0
  goto.active          = false
}
fun scroll_to_target(goto: Goto) {
  if goto.active
  then goto.whirling.scroll_line_to_center(goto.line.clamp(0, goto.whirling.lines.len - 1))
  else goto.whirling.scroll_to(goto.original_scroll)
}
| returns whether this mode should be exited
fun handle_event(goto: &Goto, event: Event): Bool {
  switch event
  case key_down(keydown) {
    var keycode = keydown.keycode
    var modifiers = keydown.modifiers

    if {48:U8 ..= 57:U8}.contains(keycode) then {
      | a digit key was pressed
      goto.active = true
      var digit = {keycode - 48:U8}.to_U64()
      goto.line = goto.line * 10 + digit
      goto.scroll_to_target()
    }
    if keycode == 8:U8 then {
      | backspace was pressed
      goto.line = goto.line / 10
      if goto.line == 0 then goto.active = false
      goto.scroll_to_target()
    }
    if keycode == 13:U8 then {
      | enter was pressed
      if goto.active then {
        var line = goto.line.clamp(0, goto.whirling.lines.len - 1)
        goto.whirling.cursor = goto.whirling.lines.get(line)
      }
      return true
    }
    stderr."Key down {keycode}{newline}"
  }
  case mouse_wheel goto.whirling.&.handle_event(event)
  default {}
  return false
}

fun render(renderer: Renderer, goto: Goto) {
  renderer.render(goto.whirling.*)
  if goto.active then {
    var y = goto.whirling.y_of_line(goto.line)

    var divisor = 1
    for i in 1..goto.whirling.num_line_number_digits() do divisor = divisor * 10

    renderer.set_color(red)
    var index = 0
    var had_non_zero = false
    loop {
      var digit = {goto.line / divisor}.modulo(10)
      if had_non_zero / {digit != 0} / {divisor == 1} then {
        had_non_zero = true
        var char = digit.to_U8().digit_to_char()
        renderer.render(char, {2:I32 + {6 * index}.to_I32()} @ y)
      }
      if divisor == 1 then break
      divisor = divisor / 10
      index = index + 1
    }
  }
}

| Outline  
| An outline view containing all definitions and header comments so you can move
| a great distance quickly.

struct Outline {
  whirling: &Whirling,
  parts: Vec[OutlinePart],
}
struct OutlinePart { offset: U64, text: Str }

fun outline(whirling: &Whirling): Outline {
  Outline { whirling, parts = vec[OutlinePart]() }
}
fun reset(outline: &Outline) {
  outline.parts.&.clear()
  for i in 0..outline.whirling.text.len do {
    var is_start_of_line = i == 0
    if not(is_start_of_line) then
      if outline.whirling.text.get(i - 1) == newline then is_start_of_line = true
    if not(is_start_of_line) then continue
    var rest = outline.whirling.text.to_slice().without_first(i).to_str()

    var is_def = rest.starts_with("fun ") / rest.starts_with("var ")
      / rest.starts_with("struct ") / rest.starts_with("enum ")
      / rest.starts_with("opaque ")
    if not(is_def) then continue

    var end = i
    loop if end >= outline.whirling.text.len then break else {
      var char = outline.whirling.text.get(end)
      if {char == #=} / {char == #{} then break
      end = end + 1
    }
    outline.parts.&.push(OutlinePart {
      offset = i,
      text = outline.whirling.text.to_str().substr(i, end),
    })
  }
}

fun handle_event(outline: &Outline, event: Event) {}

fun render(renderer: Renderer, outline: Outline) {
  renderer.set_color(foreground)
  renderer.draw({0:I32 @ 0:I32} @ {5:I32 @ 8:I32})

  for part in outline.parts.iter().enumerate() do {
    var y = part.index.to_I32() * 9:I32
    for char in part.item.text.iter().enumerate() do {
      var x = 20:I32 + {4:I32 * 6:I32} + 10:I32
        + {char.index.to_I32() * 6:I32}
      renderer.render(char.item, x @ y)
    }
    | if index == whirling.cursor then {
    |   renderer.set_color(grey)
    |   renderer.draw({x @ {y - 1}} @ {2:I32 @ 9:I32})
    | }
  }
}

| Rags  
| This is the entire editor.

struct Rags {
  file: Str,
  whirling: &Whirling,
  goto: Goto,
  outline: Outline,
  mode: RagsMode,
}
enum RagsMode { edit, goto, outline }

fun rags(file: Str, text: Str): Rags {
  var whirling = whirling(text).put_on_heap()
  Rags {
    file,
    whirling,
    goto = goto(whirling),
    outline = outline(whirling),
    mode = RagsMode.edit,
  }
}

fun handle_event(rags: &Rags, event: Event) {
  if event is key_down(keydown) then {
    var keycode = keydown.keycode
    var modifiers = keydown.modifiers

    | Ctrl + G enters goto mode
    if keycode == 103:U8 & modifiers.ctrl() then {
      rags.mode = if rags.mode is goto then RagsMode.edit else {
        rags.goto.&.reset()
        RagsMode.goto
      }
      return {}
    }
    | Ctrl + O enters outline mode
    if keycode == 111:U8 & modifiers.ctrl() then {
      rags.mode = if rags.mode is outline then RagsMode.edit else {
        rags.outline.&.reset()
        RagsMode.outline
      }
      return {}
    }
    | Ctrl + S saves
    if keycode == 115:U8 & modifiers.ctrl() then {
      var content = rags.whirling.text.to_slice().to_str().bytes()
      rags.file.write_file(content).unwrap()
      return {}
    }
    stderr."Key down {keycode}{newline}"
  }

  switch rags.mode
  case edit rags.whirling.&.handle_event(event)
  case goto if rags.goto.&.handle_event(event) then rags.mode = RagsMode.edit
  case outline rags.outline.&.handle_event(event)
}

fun render(renderer: Renderer, rags: Rags) {
  switch rags.mode
  case edit renderer.render(rags.whirling.*)
  case goto renderer.render(rags.goto)
  case outline renderer.render(rags.outline)
}

| The Main Part  

fun main(args: Slice[Str]): Never {
  if args.len < 2 then {
    eprintln("Usage: editor <file>")
    exit(1:U8)
  }

  var file = args.get(1)
  var content = file.read_file().unwrap().to_str()

  init_sdl().unwrap()
  var window = create_window(
    "{file} - Martinaise Editor",
    50:I32 @ 50:I32, window_size
  )
  var renderer = window.create_renderer()
  var texture = renderer.create_texture(TextureAccess.target, editor_size)

  var rags = rags(file, content)

  loop {
    var quit = false
    var event_happened = false
    loop {
      switch poll_event()
      case none break
      case some(event) {
        event_happened = true
        switch event
        case quit { quit = true break }
        default rags.&.handle_event(event)
      }
    }
    if quit then break

    renderer.set_target(texture)
    renderer.render(rags)
    renderer.reset_target_to_window()
    renderer.draw(texture)
    renderer.present()

    if not(event_happened) then {
      if rags.whirling.needs_tokenization
      then rags.whirling.&.text_updated()
      else delay(16)
      continue
    }
  }

  println("destroying stuff")
  texture.destroy()
  renderer.destroy()
  window.destroy()

  quit_sdl()

  exit(0:U8)
}
