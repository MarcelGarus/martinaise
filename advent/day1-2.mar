fun windows(s: Slice[U8]): Windows { Windows.{ slice = s, index = 0_U64 } }
struct Windows { slice: Slice[U8], index: U64 }
fun next(iter: &Windows): Maybe[Slice[U8]] {
  var item = if iter.*.index.is_less_than(iter.*.slice.len) {
    Maybe[Slice[U8]].some(iter.*.slice.subslice(iter.*.index))
  } else {
    Maybe[Slice[U8]].none
  }
  iter.*.index = iter.*.index.add(1_U64)
  item
}

fun rev_windows(s: Slice[U8]): RevWindows {
  RevWindows.{ slice = s, index = s.len }
}
struct RevWindows { slice: Slice[U8], index: U64 }
fun next(iter: &RevWindows): Maybe[Slice[U8]] {
  iter.*.index = iter.*.index.subtract(1_U64)
  if iter.*.index.is_less_than(iter.*.slice.len) {
    Maybe[Slice[U8]].some(iter.*.slice.subslice(iter.*.index))
  } else {
    Maybe[Slice[U8]].none
  }
}

fun find_first_digit[I](iter: I, digit_names: Vec[Slice[U8]]): U8 {
  loop {
    var part = switch iter.next() { some(p) { p } none { empty_slice[U8]() } }
    if '0.to('9).contains(part.get(0_U64)) {
      break(part.get(0_U64).subtract('0))
    }
    var j = 0_U8
    for name in &digit_names.iter() {
      if part.starts_with(name) { break }
      j = j.add(1_U8)
    }
    if j.is_less_than(digit_names.len.to_U8()) { break(j.add(1_U8)) }
  }
}

fun main(): I64 {
  var digit_names = vec[Slice[U8]]()
  identity(&digit_names).push("one")
  identity(&digit_names).push("two")
  identity(&digit_names).push("three")
  identity(&digit_names).push("four")
  identity(&digit_names).push("five")
  identity(&digit_names).push("six")
  identity(&digit_names).push("seven")
  identity(&digit_names).push("eight")
  identity(&digit_names).push("nine")

  var sum = 0_U64
  for line in &read_file("advent/day1-2.smol").lines().iter() {
    var first_digit = (&line.windows()).find_first_digit(digit_names)
    var last_digit = (&line.rev_windows()).find_first_digit(digit_names)
    sum = sum.add(first_digit.to_U64().multiply(10_U64).add(last_digit.to_U64()))
  }
  println(sum)
  return 0_I64
}
