fun windows(s: Slice[U8]): Windows { Windows.{ slice = s, index = 0_U64 } }
struct Windows { slice: Slice[U8], index: U64 }
fun next(iter: &Windows): Maybe[Slice[U8]] {
  var item = if iter.index.is_less_than(iter.slice.len)
    then Maybe[Slice[U8]].some(iter.slice.subslice(iter.index))
    else Maybe[Slice[U8]].none
  iter.index = iter.index.add(1_U64)
  item
}

fun rev_windows(s: Slice[U8]): RevWindows {
  RevWindows.{ slice = s, index = s.len }
}
struct RevWindows { slice: Slice[U8], index: U64 }
fun next(iter: &RevWindows): Maybe[Slice[U8]] {
  iter.index = iter.index.subtract(1_U64)
  if iter.index.is_less_than(iter.slice.len)
  then Maybe[Slice[U8]].some(iter.slice.subslice(iter.index))
  else Maybe[Slice[U8]].none
}

fun find_first_digit[I](iter: I, digit_names: Vec[Slice[U8]]): U8 {
  loop {
    var part = switch iter.next() case some(p) p case none empty_slice[U8]()
    if '0.to('9).contains(part.get(0_U64))
    then break(part.get(0_U64).subtract('0))
    var j = 0_U8
    for name in &digit_names.iter() do {
      if part.starts_with(name) then break
      j = j.add(1_U8)
    }
    if j.is_less_than(digit_names.len.to_U8()) then break(j.add(1_U8))
  }
}

fun main(): I64 {
  var digit_names = vec[Slice[U8]]()
  digit_names.&.push("one")
  digit_names.&.push("two")
  digit_names.&.push("three")
  digit_names.&.push("four")
  digit_names.&.push("five")
  digit_names.&.push("six")
  digit_names.&.push("seven")
  digit_names.&.push("eight")
  digit_names.&.push("nine")

  var sum = 0_U64
  for line in &read_file("advent/day1-2.smol").lines().iter() do {
    var first_digit = line.windows().&.find_first_digit(digit_names)
    var last_digit = line.rev_windows().&.find_first_digit(digit_names)
    sum = sum
      .add(first_digit.to_U64().multiply(10_U64).add(last_digit.to_U64()))
  }
  println(sum)
  return 0_I64
}
